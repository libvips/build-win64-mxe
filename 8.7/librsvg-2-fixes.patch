This file is part of MXE. See LICENSE.md for licensing information.

Contains ad hoc patches for cross building.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: "fix@me" <fix@me>
Date: Mon, 27 Sep 2010 12:00:52 +0200
Subject: [PATCH 1/4] fix .pc requirements


diff --git a/librsvg.pc.in b/librsvg.pc.in
index 1111111..2222222 100644
--- a/librsvg.pc.in
+++ b/librsvg.pc.in
@@ -9,7 +9,7 @@ css_supported=true
 Name: librsvg
 Description: library that renders svg files
 Version: @VERSION@
-Requires: glib-2.0 gio-2.0 gdk-pixbuf-2.0 cairo
+Requires: glib-2.0 gio-2.0 gdk-pixbuf-2.0 cairo libgsf-1 pangocairo libcroco-0.6
 Requires.private:
 Libs: -L${libdir} -lrsvg-@RSVG_API_MAJOR_VERSION@ -lm
 Cflags: -I${includedir}/librsvg-@RSVG_API_VERSION@

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Sun, 27 Jan 2019 14:00:00 +0200
Subject: [PATCH 2/4] Fix Windows build and static linking

Partially from:
https://aur.archlinux.org/cgit/aur.git/tree/makefile-fix.patch?h=mingw-w64-librsvg

diff --git a/Makefile.am b/Makefile.am
index 1111111..2222222 100644
--- a/Makefile.am
+++ b/Makefile.am
@@ -4,6 +4,7 @@ NULL =
 BUILT_SOURCES =
 
 lib_LTLIBRARIES = librsvg-@RSVG_API_MAJOR_VERSION@.la
+noinst_LTLIBRARIES = librsvg_internals.la
 
 bin_PROGRAMS = rsvg-convert
 if HAVE_GTK_3
@@ -25,7 +26,7 @@ librsvg_@RSVG_API_MAJOR_VERSION@_la_SOURCES =	\
 	librsvg/rsvg.h				\
 	$(NULL)
 
-RUST_SRC =							\
+librsvg_internals_la_SOURCES =	\
 	Cargo.toml						\
 	rsvg_internals/Cargo.toml				\
 	rsvg_internals/build.rs					\
@@ -112,7 +113,8 @@ RUST_SRC =							\
 	rsvg_internals/src/viewport.rs				\
 	rsvg_internals/src/xml.rs				\
 	rsvg_internals/src/xml2.rs				\
-	rsvg_internals/src/xml2_load.rs
+	rsvg_internals/src/xml2_load.rs		\
+	$(NULL)
 
 RUST_EXTRA = 						\
 	Cargo.lock					\
@@ -139,6 +141,10 @@ cargo_verbose_0 =
 cargo_verbose_1 = --verbose
 
 RUST_LIB=@abs_top_builddir@/target/@RUST_TARGET_SUBDIR@/librsvg_internals.a
+RUST_LIB_WIN=@abs_top_builddir@/target/@RUST_TARGET_SUBDIR@/rsvg_internals.lib
+RUST_LIB_TARGET=@abs_top_builddir@/.libs/librsvg_internals.a
+RUST_LT_LIB=@abs_top_builddir@/target/@RUST_TARGET_SUBDIR@/librsvg_internals.la
+RUST_LT_TARGET=@abs_top_builddir@/librsvg_internals.la
 CARGO_TARGET_DIR=@abs_top_builddir@/target
 
 check-local:
@@ -162,12 +168,19 @@ dist-hook:
 	mkdir .cargo &&								\
 	cp cargo-vendor-config .cargo/config)
 
-$(RUST_LIB): $(RUST_SRC)
+librsvg_internals.la: $(librsvg_internals_la_SOURCES)
 	+cd $(top_srcdir)/rsvg_internals &&					\
 	PKG_CONFIG_ALLOW_CROSS=1						\
 	PKG_CONFIG='$(PKG_CONFIG)'						\
 	CARGO_TARGET_DIR=$(CARGO_TARGET_DIR)					\
-	$(CARGO) build $(CARGO_VERBOSE) $(CARGO_TARGET_ARGS) $(CARGO_RELEASE_ARGS)
+	$(CARGO) build $(CARGO_VERBOSE) $(CARGO_TARGET_ARGS) $(CARGO_RELEASE_ARGS) \
+	&& mkdir -p `dirname $(RUST_LIB_TARGET)`	\
+	&& if [[ -e $(RUST_LIB_WIN) ]] ; then 		\
+		cp $(RUST_LIB_WIN) $(RUST_LIB_TARGET);	\
+	else										\
+		cp $(RUST_LIB) $(RUST_LIB_TARGET);		\
+	fi											\
+	&& cp $(RUST_LT_LIB) $(RUST_LT_TARGET)
 
 librsvg_@RSVG_API_MAJOR_VERSION@_la_CPPFLAGS = \
 	-I$(top_srcdir) 			\
@@ -193,7 +206,7 @@ librsvg_@RSVG_API_MAJOR_VERSION@_la_LDFLAGS = \
 	$(AM_LDFLAGS)
 
 librsvg_@RSVG_API_MAJOR_VERSION@_la_LIBADD = \
-	$(RUST_LIB)		\
+	librsvg_internals.la \
 	$(LIBRSVG_LIBS) 	\
 	$(LIBM)			\
 	$(DLOPEN_LIBS)
@@ -261,7 +274,7 @@ dist_doc_DATA =				\
 	code-of-conduct.md
 
 EXTRA_DIST =				\
-	$(RUST_SRC)			\
+	$(librsvg_internals_la_SOURCES)		\
 	$(RUST_EXTRA)			\
 	librsvg.doap			\
 	AUTHORS				\
diff --git a/rsvg_internals/build.rs b/rsvg_internals/build.rs
index 1111111..2222222 100644
--- a/rsvg_internals/build.rs
+++ b/rsvg_internals/build.rs
@@ -2,12 +2,16 @@ extern crate phf_codegen;
 
 use std::env;
 use std::fs::File;
+use std::fs;
 use std::io::{BufWriter, Write};
+use std::os::unix::fs::symlink;
 use std::path::Path;
+use std::path::PathBuf;
 
 fn main() {
     generate_phf_of_svg_attributes();
     generate_srgb_tables();
+    generate_convenience_lib("librsvg_internals").unwrap();
 }
 
 /// Creates a perfect hash function (PHF) to map SVG attribute names to enum values.
@@ -254,3 +258,60 @@ fn generate_srgb_tables() {
     print_table(&mut file, "LINEARIZE", &linearize_table);
     print_table(&mut file, "UNLINEARIZE", &unlinearize_table);
 }
+
+/// Generate libtool archive file ${lib}.la
+/// From https://docs.rs/libtool/0.1.1/libtool/
+/// Upstream doesn't handle some of the directory structure we use in librsvg,
+/// use a few extra environment variables to properly determine the target paths.
+pub fn generate_convenience_lib(lib: &str) -> std::io::Result<()> {
+    let self_version = env!("CARGO_PKG_VERSION");
+    let profile = env::var("PROFILE").unwrap();
+    let target_arch = env::var("TARGET").unwrap();
+    let target_dir_env = env::var("CARGO_TARGET_DIR").unwrap();
+
+    /* Check if the output directory will include the arch */
+    let target_dir = if PathBuf::from(format!("{}/{}",
+                                target_dir_env, target_arch)).exists() {
+        format!("{}/{}/{}", target_dir_env, target_arch, profile)
+    } else {
+        format!("{}/{}", target_dir_env, profile)
+    };
+
+    /* Location of original static library */
+    let old_lib_path = PathBuf::from(format!("{}/{}.a",
+                                            target_dir, lib));
+    /* Paths for new .la file and symlinks */
+    let libs_dir = format!("{}/.libs", target_dir);
+    let libs_path = PathBuf::from(&libs_dir);
+    let la_path = PathBuf::from(format!("{}/{}.la",
+                                        target_dir, lib));
+    let new_lib_path = PathBuf::from(format!("{}/{}.a", libs_dir, lib));
+
+    match fs::create_dir_all(&libs_path) {
+        Ok(()) => println!("libs_path created"),
+        _ => panic!("Failed to create libs_path"),
+    }
+
+    if la_path.exists() {
+        fs::remove_file(&la_path)?;
+    }
+
+    /* PathBuf.exists() traverses symlinks so just try and remove it */
+    match fs::remove_file(&new_lib_path) {
+        Ok(_v) => {},
+        Err(e) => println!("Error removing symlink: {:?}", e),
+    }
+
+    let mut file = File::create(&la_path)?;
+    writeln!(file, "# {}.la - a libtool library file", lib)?;
+    writeln!(file, "# Generated by libtool-rust {}", self_version)?;
+    writeln!(file, "dlname=''")?;
+    writeln!(file, "library_names=''")?;
+    writeln!(file, "old_library='{}.a'", lib)?;
+    writeln!(file, "inherited_linker_flags=' '")?;
+    writeln!(file, "installed=no")?;
+    writeln!(file, "shouldnotlink=no")?;
+
+    symlink(&old_lib_path, &new_lib_path)?;
+    Ok(())
+}

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Sun, 27 Jan 2019 15:00:00 +0200
Subject: [PATCH 3/4] Revert "Include Rust debuginfo in release builds"

This reverts commit 8215d7f1f581f0aaa317cccc3e974c61d1a6ad84.

diff --git a/Cargo.toml b/Cargo.toml
index 1111111..2222222 100644
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -5,7 +5,6 @@ members = [
 
 [profile.release]
 lto = true
-debug = true
 
 [profile.bench]
 lto = true

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Federico Mena Quintero <federico@gnome.org>
Date: Thu, 21 Feb 2019 18:08:00 -0600
Subject: [PATCH 4/4] wip: Test the part of rsvg_handle_new_from_file() that
 decides between files and URLs

This does not quite work yet; the tests fail on Linux, and I'm not
sure they are correct on Windows.

This commit introduces a PathOrUrl enum, which gets created out of
a *const libc::c_char.  The idea is that it will figure out whether
the string that comes from C represents a path or a URL, so the code
can decide whether to call gio::File::new_for_path() or
gio::File::new_for_uri().

diff --git a/rsvg_internals/src/handle.rs b/rsvg_internals/src/handle.rs
index 1111111..2222222 100644
--- a/rsvg_internals/src/handle.rs
+++ b/rsvg_internals/src/handle.rs
@@ -1024,18 +1024,16 @@ pub unsafe extern "C" fn rsvg_handle_rust_new_from_file(
     filename: *const libc::c_char,
     error: *mut *mut glib_sys::GError,
 ) -> *mut RsvgHandle {
-    // This API lets the caller pass a URI, or a file name in the operating system's
-    // encoding.  So, first we'll see if it's UTF-8, and in that case, try the URL version.
-    // Otherwise, we'll try building a path name.
+    let file = match PathOrUrl::new(filename) {
+        Ok(PathOrUrl::Path(path)) => gio::File::new_for_path(path),
 
-    let cstr = CStr::from_ptr(filename);
+        Ok(PathOrUrl::Url(url)) => gio::File::new_for_uri(url.as_str()),
 
-    let file = cstr
-        .to_str()
-        .map_err(|_| ())
-        .and_then(|utf8| Url::parse(utf8).map_err(|_| ()))
-        .and_then(|url| Ok(gio::File::new_for_uri(url.as_str())))
-        .unwrap_or_else(|_| gio::File::new_for_path(PathBuf::from_glib_none(filename)));
+        Err(e) => {
+            set_gerror(error, 0, &format!("{}", e));
+            return ptr::null_mut();
+        }
+    };
 
     rsvg_handle_rust_new_from_gfile_sync(file.to_glib_none().0, 0, ptr::null_mut(), error)
 }
@@ -1124,3 +1122,111 @@ pub unsafe extern "C" fn rsvg_handle_rust_new_from_data(
     gobject_sys::g_object_unref(raw_stream as *mut _);
     ret
 }
+
+/// Detects whether a `*const libc::c_char` is a path or a URI
+///
+/// `rsvg_handle_new_from_file()` takes a `filename` argument, and advertises
+/// that it will detect either a file system path, or a proper URI.  It will then use
+/// `gio::File::new_for_path()` or `gio::File::new_for_uri()` as appropriate.
+///
+/// This enum does the magic heuristics to figure this out.
+enum PathOrUrl {
+    Path(PathBuf),
+    Url(Url),
+}
+
+impl PathOrUrl {
+    unsafe fn new(s: *const libc::c_char) -> Result<PathOrUrl, LoadingError> {
+        // We do this with the glib C function like in the original implementation
+
+        let cstr = CStr::from_ptr(s);
+
+        Ok(cstr
+            .to_str()
+            .map_err(|_| ())
+            .and_then(|utf8| Url::parse(utf8).map_err(|_| ()))
+            .and_then(|url| {
+                if url.origin().is_tuple() || url.scheme() == "file" {
+                    Ok(PathOrUrl::Url(url))
+                } else {
+                    Ok(PathOrUrl::Path(url.to_file_path()?))
+                }
+            })
+            .unwrap_or_else(|_| PathOrUrl::Path(PathBuf::from_glib_none(s))))
+        // let scheme = glib_sys::g_uri_parse_scheme(s);
+        //
+        // if scheme.is_null() {
+        // Ok(PathOrUrl::Path(PathBuf::from_glib_none(s)))
+        // } else {
+        // glib_sys::g_free(scheme as *mut _);
+        //
+        // let cstr = CStr::from_ptr(s);
+        //
+        // cstr.to_str()
+        // .map_err(|_| ())
+        // .and_then(|utf8| Url::parse(utf8).map_err(|_| ()))
+        // .map(|url| PathOrUrl::Url(url))
+        // .map_err(|_| LoadingError::BadUrl)
+        // }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn path_or_url_unix() {
+        unsafe {
+            match PathOrUrl::new(b"/foo/bar\0" as *const u8 as *const _).unwrap() {
+                PathOrUrl::Path(_) => (),
+                _ => panic!("unix filename should be a PathOrUrl::Path"),
+            }
+
+            match PathOrUrl::new(b"foo/bar\0" as *const u8 as *const _).unwrap() {
+                PathOrUrl::Path(_) => (),
+                _ => panic!("unix filename should be a PathOrUrl::Path"),
+            }
+        }
+    }
+
+    #[test]
+    fn path_or_url_windows() {
+        unsafe {
+            match PathOrUrl::new(b"c:/foo/bar\0" as *const u8 as *const _).unwrap() {
+                PathOrUrl::Path(_) => (),
+                _ => panic!("windows filename should be a PathOrUrl::Path"),
+            }
+
+            match PathOrUrl::new(b"C:/foo/bar\0" as *const u8 as *const _).unwrap() {
+                PathOrUrl::Path(_) => (),
+                _ => panic!("windows filename should be a PathOrUrl::Path"),
+            }
+        }
+    }
+
+    #[test]
+    fn path_or_url_unix_url() {
+        unsafe {
+            match PathOrUrl::new(b"file:///foo/bar\0" as *const u8 as *const _).unwrap() {
+                PathOrUrl::Url(_) => (),
+                _ => panic!("file:// unix filename should be a PathOrUrl::Url"),
+            }
+        }
+    }
+
+    #[test]
+    fn path_or_url_windows_url() {
+        unsafe {
+            match PathOrUrl::new(b"file://c:/foo/bar\0" as *const u8 as *const _).unwrap() {
+                PathOrUrl::Url(_) => (),
+                _ => panic!("file:// windows filename should be a PathOrUrl::Url"),
+            }
+
+            match PathOrUrl::new(b"file://C:/foo/bar\0" as *const u8 as *const _).unwrap() {
+                PathOrUrl::Url(_) => (),
+                _ => panic!("file:// windows filename should be a PathOrUrl::Url"),
+            }
+        }
+    }
+}
