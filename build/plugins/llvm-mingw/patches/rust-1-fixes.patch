This file is part of MXE. See LICENSE.md for licensing information.

Contains ad hoc patches for cross building.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Tue, 15 Sep 2020 11:50:00 +0200
Subject: [PATCH 1/5] Add llvm-mingw i686/ARMv7 targets

Upstream-Status: Pending

diff --git a/compiler/rustc_target/src/spec/armv7_pc_windows_gnullvm.rs b/compiler/rustc_target/src/spec/armv7_pc_windows_gnullvm.rs
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/compiler/rustc_target/src/spec/armv7_pc_windows_gnullvm.rs
@@ -0,0 +1,17 @@
+use crate::spec::{FramePointer, Target};
+
+pub fn target() -> Target {
+    let mut base = super::windows_gnullvm_base::opts();
+    base.max_atomic_width = Some(64);
+    base.frame_pointer = FramePointer::Always; // Required for backtraces
+    base.features = "+v7,+thumb-mode,+thumb2,+vfp3,+neon".into();
+    base.linker = Some("armv7-w64-mingw32-clang".into());
+
+    Target {
+        llvm_target: "armv7-pc-windows-gnu".into(),
+        pointer_width: 32,
+        data_layout: "e-m:w-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64".into(),
+        arch: "arm".into(),
+        options: base,
+    }
+}
diff --git a/compiler/rustc_target/src/spec/i686_pc_windows_gnullvm.rs b/compiler/rustc_target/src/spec/i686_pc_windows_gnullvm.rs
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/compiler/rustc_target/src/spec/i686_pc_windows_gnullvm.rs
@@ -0,0 +1,19 @@
+use crate::spec::{FramePointer, Target};
+
+pub fn target() -> Target {
+    let mut base = super::windows_gnullvm_base::opts();
+    base.cpu = "pentium4".into();
+    base.max_atomic_width = Some(64);
+    base.frame_pointer = FramePointer::Always; // Required for backtraces
+    base.linker = Some("i686-w64-mingw32-clang".into());
+
+    Target {
+        llvm_target: "i686-pc-windows-gnu".into(),
+        pointer_width: 32,
+        data_layout: "e-m:x-p:32:32-p270:32:32-p271:32:32-p272:64:64-\
+            i64:64-f80:32-n8:16:32-a:0:32-S32"
+            .into(),
+        arch: "x86".into(),
+        options: base,
+    }
+}
diff --git a/compiler/rustc_target/src/spec/mod.rs b/compiler/rustc_target/src/spec/mod.rs
index 1111111..2222222 100644
--- a/compiler/rustc_target/src/spec/mod.rs
+++ b/compiler/rustc_target/src/spec/mod.rs
@@ -1246,7 +1246,9 @@ supported_targets! {
     ("x86_64-uwp-windows-gnu", x86_64_uwp_windows_gnu),
 
     ("aarch64-pc-windows-gnullvm", aarch64_pc_windows_gnullvm),
+    ("armv7-pc-windows-gnullvm", armv7_pc_windows_gnullvm),
     ("x86_64-pc-windows-gnullvm", x86_64_pc_windows_gnullvm),
+    ("i686-pc-windows-gnullvm", i686_pc_windows_gnullvm),
 
     ("aarch64-pc-windows-msvc", aarch64_pc_windows_msvc),
     ("aarch64-uwp-windows-msvc", aarch64_uwp_windows_msvc),

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Tue, 22 Sep 2020 10:00:00 +0200
Subject: [PATCH 2/5] Ensure that std/unwind can be successfully built on
 llvm-mingw

Fixes undefined symbol errors while linking these crates on llvm-mingw
(targeting ARMv7).

Details:
ld.lld: error: undefined symbol: __gnu_unwind_frame
>>> referenced by libstd-<HASH>.rlib(<O_FILE>):(std::personality::gcc::rust_eh_personality::continue_unwind::<HASH>)

ld.lld: error: undefined symbol: _Unwind_VRS_Get
>>> referenced by libunwind-<HASH>.rlib(<O_FILE>):(unwind::libunwind::_Unwind_GetGR::<HASH>)

ld.lld: error: undefined symbol: _Unwind_VRS_Set
>>> referenced by libunwind-<HASH>.rlib(<O_FILE>):(unwind::libunwind::_Unwind_SetGR::<HASH>)

Upstream-Status: Pending

diff --git a/library/std/src/personality/gcc.rs b/library/std/src/personality/gcc.rs
index 1111111..2222222 100644
--- a/library/std/src/personality/gcc.rs
+++ b/library/std/src/personality/gcc.rs
@@ -85,7 +85,7 @@ const UNWIND_DATA_REG: (i32, i32) = (10, 11); // x10, x11
 // https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c
 
 cfg_if::cfg_if! {
-    if #[cfg(all(target_arch = "arm", not(target_os = "ios"), not(target_os = "watchos"), not(target_os = "netbsd")))] {
+    if #[cfg(all(target_arch = "arm", not(target_os = "ios"), not(target_os = "watchos"), not(target_os = "netbsd"), not(target_os = "windows")))] {
         // ARM EHABI personality routine.
         // https://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf
         //
diff --git a/library/unwind/src/libunwind.rs b/library/unwind/src/libunwind.rs
index 1111111..2222222 100644
--- a/library/unwind/src/libunwind.rs
+++ b/library/unwind/src/libunwind.rs
@@ -117,7 +117,7 @@ extern "C" {
 }
 
 cfg_if::cfg_if! {
-if #[cfg(any(target_os = "ios", target_os = "watchos", target_os = "netbsd", not(target_arch = "arm")))] {
+if #[cfg(any(target_os = "ios", target_os = "watchos", target_os = "netbsd", target_os = "windows", not(target_arch = "arm")))] {
     // Not ARM EHABI
     #[repr(C)]
     #[derive(Copy, Clone, PartialEq)]
@@ -131,7 +131,7 @@ if #[cfg(any(target_os = "ios", target_os = "netbsd", not(target_arch = "arm")))
     pub use _Unwind_Action::*;
 
     #[cfg_attr(
-        all(feature = "llvm-libunwind", any(target_os = "fuchsia", target_os = "linux")),
+        all(feature = "llvm-libunwind", any(target_os = "fuchsia", target_os = "linux", target_os = "windows")),
         link(name = "unwind", kind = "static", modifiers = "-bundle")
     )]
     extern "C" {

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Tue, 30 Aug 2022 23:20:27 +0200
Subject: [PATCH 3/5] windows-gnullvm: avoid linking to libunwind statically

Avoid linking against the static variant of libunwind, which is not
always available. Instead, prefer to use the unwind library from the
toolchain, which the linker will automatically include, depending
on what's available, and depending on the -static flag.

See: https://github.com/rust-lang/rust/pull/103894

Upstream-Status: Pending

diff --git a/compiler/rustc_target/src/spec/windows_gnullvm_base.rs b/compiler/rustc_target/src/spec/windows_gnullvm_base.rs
index 1111111..2222222 100644
--- a/compiler/rustc_target/src/spec/windows_gnullvm_base.rs
+++ b/compiler/rustc_target/src/spec/windows_gnullvm_base.rs
@@ -8,7 +8,7 @@ pub fn opts() -> TargetOptions {
     // but LLVM maintainers rejected it: https://reviews.llvm.org/D51440
     let pre_link_args = TargetOptions::link_args(
         LinkerFlavor::Gnu(Cc::Yes, Lld::No),
-        &["-nolibc", "--unwindlib=none"],
+        &["-nolibc"],
     );
     // Order of `late_link_args*` does not matter with LLD.
     let late_link_args = TargetOptions::link_args(
diff --git a/library/unwind/src/lib.rs b/library/unwind/src/lib.rs
index 1111111..2222222 100644
--- a/library/unwind/src/lib.rs
+++ b/library/unwind/src/lib.rs
@@ -3,7 +3,6 @@
 #![feature(link_cfg)]
 #![feature(staged_api)]
 #![feature(c_unwind)]
-#![feature(cfg_target_abi)]
 #![cfg_attr(not(target_env = "msvc"), feature(libc))]
 
 cfg_if::cfg_if! {
diff --git a/library/unwind/src/libunwind.rs b/library/unwind/src/libunwind.rs
index 1111111..2222222 100644
--- a/library/unwind/src/libunwind.rs
+++ b/library/unwind/src/libunwind.rs
@@ -99,10 +99,7 @@ pub type _Unwind_Exception_Cleanup_Fn =
 // rustc_codegen_ssa::src::back::symbol_export, rustc_middle::middle::exported_symbols
 // and RFC 2841
 #[cfg_attr(
-    any(
-        all(feature = "llvm-libunwind", any(target_os = "fuchsia", target_os = "linux")),
-        all(target_os = "windows", target_env = "gnu", target_abi = "llvm")
-    ),
+    all(feature = "llvm-libunwind", any(target_os = "fuchsia", target_os = "linux")),
     link(name = "unwind", kind = "static", modifiers = "-bundle")
 )]
 extern "C-unwind" {

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Mon, 17 Oct 2022 11:50:00 +0200
Subject: [PATCH 4/5] Use GCC-style unwinding on MinGW targets other than i686

See: https://github.com/msys2/MINGW-packages/pull/13278

Upstream-Status: Pending

diff --git a/library/std/src/personality/gcc.rs b/library/std/src/personality/gcc.rs
index 1111111..2222222 100644
--- a/library/std/src/personality/gcc.rs
+++ b/library/std/src/personality/gcc.rs
@@ -184,7 +184,7 @@ cfg_if::cfg_if! {
         }
     } else {
         // Default personality routine, which is used directly on most targets
-        // and indirectly on Windows x86_64 via SEH.
+        // and indirectly on Windows x86_64/armv7/aarch64 via SEH.
         unsafe extern "C" fn rust_eh_personality_impl(
             version: c_int,
             actions: uw::_Unwind_Action,
@@ -226,9 +226,9 @@ cfg_if::cfg_if! {
         }
 
         cfg_if::cfg_if! {
-            if #[cfg(all(windows, any(target_arch = "aarch64", target_arch = "x86_64"), target_env = "gnu"))] {
-                // On x86_64 MinGW targets, the unwinding mechanism is SEH however the unwind
-                // handler data (aka LSDA) uses GCC-compatible encoding.
+            if #[cfg(all(windows, target_env = "gnu", not(target_arch = "x86")))] {
+                // On MinGW targets other than i686, the unwinding mechanism is SEH however
+                // the unwind handler data (aka LSDA) uses GCC-compatible encoding.
                 #[lang = "eh_personality"]
                 #[allow(nonstandard_style)]
                 unsafe extern "C" fn rust_eh_personality(
diff --git a/library/unwind/src/libunwind.rs b/library/unwind/src/libunwind.rs
index 1111111..2222222 100644
--- a/library/unwind/src/libunwind.rs
+++ b/library/unwind/src/libunwind.rs
@@ -278,7 +278,7 @@ if #[cfg(not(all(target_os = "ios", target_arch = "arm")))] {
 } // cfg_if!
 
 cfg_if::cfg_if! {
-if #[cfg(all(windows, any(target_arch = "aarch64", target_arch = "x86_64"), target_env = "gnu"))] {
+if #[cfg(all(windows, target_env = "gnu", not(target_arch = "x86")))] {
     // We declare these as opaque types. This is fine since you just need to
     // pass them to _GCC_specific_handler and forget about them.
     pub enum EXCEPTION_RECORD {}

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Sat, 13 May 2023 11:46:16 +0200
Subject: [PATCH 5/5] Fix build errors on llvm-mingw (targeting ARMv7)

Details:
error[E0412]: cannot find type `WSADATA` in this scope
   --> library/std/src/sys/windows/c/windows_sys.rs:715:63
    |
715 |     pub fn WSAStartup(wversionrequested: u16, lpwsadata: *mut WSADATA) -> i32;
    |                                                               ^^^^^^^ not found in this scope

error[E0412]: cannot find type `CONTEXT` in this scope
    --> library/std/src/sys/windows/c/windows_sys.rs:3034:29
     |
3034 |     pub ContextRecord: *mut CONTEXT,
     |                             ^^^^^^^ not found in this scope
     |

error[E0412]: cannot find type `WSADATA` in module `c`
  --> library/std/src/sys/windows/net.rs:38:26
   |
38 |         let mut data: c::WSADATA = mem::zeroed();
   |                          ^^^^^^^ not found in `c`

error[E0412]: cannot find type `FLOATING_SAVE_AREA` in this scope
    --> library/std/src/sys/windows/c/windows_sys.rs:1096:20
     |
1096 |     pub FloatSave: FLOATING_SAVE_AREA,
     |                    ^^^^^^^^^^^^^^^^^^ not found in this scope

Upstream-Status: Pending

diff --git a/library/std/src/sys/windows/c/windows_sys.rs b/library/std/src/sys/windows/c/windows_sys.rs
index 1111111..2222222 100644
--- a/library/std/src/sys/windows/c/windows_sys.rs
+++ b/library/std/src/sys/windows/c/windows_sys.rs
@@ -1084,7 +1084,7 @@ fn clone(&self) -> Self {
     }
 }
 #[repr(C)]
-#[cfg(target_arch = "x86")]
+#[cfg(any(target_arch = "arm", target_arch = "x86"))]
 pub struct CONTEXT {
     pub ContextFlags: u32,
     pub Dr0: u32,
@@ -1112,9 +1112,9 @@ pub struct CONTEXT {
     pub SegSs: u32,
     pub ExtendedRegisters: [u8; 512],
 }
-#[cfg(target_arch = "x86")]
+#[cfg(any(target_arch = "arm", target_arch = "x86"))]
 impl ::core::marker::Copy for CONTEXT {}
-#[cfg(target_arch = "x86")]
+#[cfg(any(target_arch = "arm", target_arch = "x86"))]
 impl ::core::clone::Clone for CONTEXT {
     fn clone(&self) -> Self {
         *self
@@ -3311,7 +3311,7 @@ fn clone(&self) -> Self {
     }
 }
 #[repr(C)]
-#[cfg(target_arch = "x86")]
+#[cfg(any(target_arch = "arm", target_arch = "x86"))]
 pub struct FLOATING_SAVE_AREA {
     pub ControlWord: u32,
     pub StatusWord: u32,
@@ -3323,9 +3323,9 @@ pub struct FLOATING_SAVE_AREA {
     pub RegisterArea: [u8; 80],
     pub Spare0: u32,
 }
-#[cfg(target_arch = "x86")]
+#[cfg(any(target_arch = "arm", target_arch = "x86"))]
 impl ::core::marker::Copy for FLOATING_SAVE_AREA {}
-#[cfg(target_arch = "x86")]
+#[cfg(any(target_arch = "arm", target_arch = "x86"))]
 impl ::core::clone::Clone for FLOATING_SAVE_AREA {
     fn clone(&self) -> Self {
         *self
@@ -4058,7 +4058,7 @@ fn clone(&self) -> Self {
     }
 }
 #[repr(C)]
-#[cfg(target_arch = "x86")]
+#[cfg(any(target_arch = "arm", target_arch = "x86"))]
 pub struct WSADATA {
     pub wVersion: u16,
     pub wHighVersion: u16,
@@ -4068,9 +4068,9 @@ pub struct WSADATA {
     pub iMaxUdpDg: u16,
     pub lpVendorInfo: PSTR,
 }
-#[cfg(target_arch = "x86")]
+#[cfg(any(target_arch = "arm", target_arch = "x86"))]
 impl ::core::marker::Copy for WSADATA {}
-#[cfg(target_arch = "x86")]
+#[cfg(any(target_arch = "arm", target_arch = "x86"))]
 impl ::core::clone::Clone for WSADATA {
     fn clone(&self) -> Self {
         *self
