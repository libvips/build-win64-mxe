This file is part of MXE. See LICENSE.md for licensing information.

Contains ad hoc patches for cross building.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Tue, 15 Sep 2020 11:50:00 +0200
Subject: [PATCH 1/5] Add llvm-mingw ARM/ARM64 targets


diff --git a/compiler/rustc_target/src/spec/aarch64_pc_windows_gnu.rs b/compiler/rustc_target/src/spec/aarch64_pc_windows_gnu.rs
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/compiler/rustc_target/src/spec/aarch64_pc_windows_gnu.rs
@@ -0,0 +1,20 @@
+use crate::spec::{LinkerFlavor, LldFlavor, Target, TargetOptions};
+
+pub fn target() -> Target {
+    let mut base = super::windows_gnu_base::opts();
+    base.pre_link_args
+        .insert(LinkerFlavor::Lld(LldFlavor::Ld), vec!["-m".to_string(), "arm64pe".to_string()]);
+
+    Target {
+        llvm_target: "aarch64-pc-windows-gnu".to_string(),
+        pointer_width: 64,
+        data_layout: "e-m:w-p:64:64-i32:32-i64:64-i128:128-n32:64-S128".to_string(),
+        arch: "aarch64".to_string(),
+        options: TargetOptions {
+            features: "+neon,+fp-armv8".to_string(),
+            max_atomic_width: Some(64),
+            has_thread_local: true,
+            ..base
+        },
+    }
+}
diff --git a/compiler/rustc_target/src/spec/mod.rs b/compiler/rustc_target/src/spec/mod.rs
index 1111111..2222222 100644
--- a/compiler/rustc_target/src/spec/mod.rs
+++ b/compiler/rustc_target/src/spec/mod.rs
@@ -927,6 +927,8 @@ supported_targets! {
 
     ("x86_64-unknown-illumos", x86_64_unknown_illumos),
 
+    ("aarch64-pc-windows-gnu", aarch64_pc_windows_gnu),
+    ("armv7-pc-windows-gnu", armv7_pc_windows_gnu),
     ("x86_64-pc-windows-gnu", x86_64_pc_windows_gnu),
     ("i686-pc-windows-gnu", i686_pc_windows_gnu),
     ("i686-uwp-windows-gnu", i686_uwp_windows_gnu),
diff --git a/compiler/rustc_target/src/spec/armv7_pc_windows_gnu.rs b/compiler/rustc_target/src/spec/armv7_pc_windows_gnu.rs
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/compiler/rustc_target/src/spec/armv7_pc_windows_gnu.rs
@@ -0,0 +1,21 @@
+use crate::spec::{FramePointer, LinkerFlavor, LldFlavor, Target, TargetOptions};
+
+pub fn target() -> Target {
+    let mut base = super::windows_gnu_base::opts();
+    base.pre_link_args
+        .insert(LinkerFlavor::Lld(LldFlavor::Ld), vec!["-m".to_string(), "thumb2pe".to_string()]);
+
+    Target {
+        llvm_target: "armv7-pc-windows-gnu".to_string(),
+        pointer_width: 32,
+        data_layout: "e-m:w-p:32:32-Fi8-i64:64-v128:64:128-a:0:32-n32-S64".to_string(),
+        arch: "arm".to_string(),
+        options: TargetOptions {
+            features: "+v7,+thumb-mode,+thumb2,+vfp3,+neon".to_string(),
+            max_atomic_width: Some(64),
+            // Required for backtraces
+            frame_pointer: FramePointer::Always,
+            ..base
+        },
+    }
+}

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Tue, 15 Sep 2020 15:20:00 +0200
Subject: [PATCH 2/5] Make Windows GNU targets compatible with llvm-mingw

By ensuring that we use the standard system libraries when linking
(i.e. remove -nodefaultlibs) and by avoiding to link against GCC
specific libraries (i.e. libgcc, libgcc_eh and libgcc_s).

We don't need to link against libunwind.dll.a or libunwind.a, since
the linker will automatically include libunwind, depending on what's
available, and depending on the -static flag.

Note: this patch will probably break compatibility with GCC.

diff --git a/compiler/rustc_target/src/spec/windows_gnu_base.rs b/compiler/rustc_target/src/spec/windows_gnu_base.rs
index 1111111..2222222 100644
--- a/compiler/rustc_target/src/spec/windows_gnu_base.rs
+++ b/compiler/rustc_target/src/spec/windows_gnu_base.rs
@@ -1,5 +1,5 @@
 use crate::spec::crt_objects::{self, CrtObjectsFallback};
-use crate::spec::{LinkArgs, LinkerFlavor, LldFlavor, TargetOptions};
+use crate::spec::{LinkArgs, LinkerFlavor, TargetOptions};
 
 pub fn opts() -> TargetOptions {
     let mut pre_link_args = LinkArgs::new();
@@ -16,48 +16,9 @@ pub fn opts() -> TargetOptions {
         ],
     );
 
-    let mut late_link_args = LinkArgs::new();
-    let mut late_link_args_dynamic = LinkArgs::new();
-    let mut late_link_args_static = LinkArgs::new();
-    // Order of `late_link_args*` was found through trial and error to work with various
-    // mingw-w64 versions (not tested on the CI). It's expected to change from time to time.
-    let mingw_libs = vec![
-        "-lmsvcrt".to_string(),
-        "-lmingwex".to_string(),
-        "-lmingw32".to_string(),
-        "-lgcc".to_string(), // alas, mingw* libraries above depend on libgcc
-        // mingw's msvcrt is a weird hybrid import library and static library.
-        // And it seems that the linker fails to use import symbols from msvcrt
-        // that are required from functions in msvcrt in certain cases. For example
-        // `_fmode` that is used by an implementation of `__p__fmode` in x86_64.
-        // The library is purposely listed twice to fix that.
-        //
-        // See https://github.com/rust-lang/rust/pull/47483 for some more details.
-        "-lmsvcrt".to_string(),
-        "-luser32".to_string(),
-        "-lkernel32".to_string(),
-    ];
-    late_link_args.insert(LinkerFlavor::Gcc, mingw_libs.clone());
-    late_link_args.insert(LinkerFlavor::Lld(LldFlavor::Ld), mingw_libs);
-    let dynamic_unwind_libs = vec![
-        // If any of our crates are dynamically linked then we need to use
-        // the shared libgcc_s-dw2-1.dll. This is required to support
-        // unwinding across DLL boundaries.
-        "-lgcc_s".to_string(),
-    ];
-    late_link_args_dynamic.insert(LinkerFlavor::Gcc, dynamic_unwind_libs.clone());
-    late_link_args_dynamic.insert(LinkerFlavor::Lld(LldFlavor::Ld), dynamic_unwind_libs);
-    let static_unwind_libs = vec![
-        // If all of our crates are statically linked then we can get away
-        // with statically linking the libgcc unwinding code. This allows
-        // binaries to be redistributed without the libgcc_s-dw2-1.dll
-        // dependency, but unfortunately break unwinding across DLL
-        // boundaries when unwinding across FFI boundaries.
-        "-lgcc_eh".to_string(),
-        "-l:libpthread.a".to_string(),
-    ];
-    late_link_args_static.insert(LinkerFlavor::Gcc, static_unwind_libs.clone());
-    late_link_args_static.insert(LinkerFlavor::Lld(LldFlavor::Ld), static_unwind_libs);
+    let late_link_args = LinkArgs::new();
+    let late_link_args_dynamic = LinkArgs::new();
+    let late_link_args_static = LinkArgs::new();
 
     TargetOptions {
         os: "windows".to_string(),
@@ -87,6 +48,7 @@ pub fn opts() -> TargetOptions {
         emit_debug_gdb_scripts: false,
         requires_uwtable: true,
         eh_frame_header: false,
+        no_default_libraries: false,
 
         ..Default::default()
     }

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Mon, 26 Jul 2021 13:00:00 +0200
Subject: [PATCH 3/5] Enable -ffunction-sections


diff --git a/compiler/rustc_target/src/spec/windows_gnu_base.rs b/compiler/rustc_target/src/spec/windows_gnu_base.rs
index 1111111..2222222 100644
--- a/compiler/rustc_target/src/spec/windows_gnu_base.rs
+++ b/compiler/rustc_target/src/spec/windows_gnu_base.rs
@@ -24,8 +24,6 @@ pub fn opts() -> TargetOptions {
         os: "windows".to_string(),
         env: "gnu".to_string(),
         vendor: "pc".to_string(),
-        // FIXME(#13846) this should be enabled for windows
-        function_sections: false,
         linker: Some("gcc".to_string()),
         dynamic_linking: true,
         executables: true,

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Fri, 18 Sep 2020 21:00:00 +0200
Subject: [PATCH 4/5] Do not distribute Windows-specific files while
 cross-compiling

These files (gcc.exe, ld.exe, dlltool.exe, etc.) are not available on
Unix systems with MinGW and probably exists only on MSYS environments.

Note: this patch has only been tested on Linux.

diff --git a/src/bootstrap/dist.rs b/src/bootstrap/dist.rs
index 1111111..2222222 100644
--- a/src/bootstrap/dist.rs
+++ b/src/bootstrap/dist.rs
@@ -288,7 +288,7 @@ impl Step for Mingw {
     /// without any extra installed software (e.g., we bundle gcc, libraries, etc).
     fn run(self, builder: &Builder<'_>) -> Option<GeneratedTarball> {
         let host = self.host;
-        if !host.contains("pc-windows-gnu") {
+        if !host.contains("pc-windows-gnu") || builder.config.build != host {
             return None;
         }

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Tue, 22 Sep 2020 10:00:00 +0200
Subject: [PATCH 5/5] Ensure that panic_unwind/unwind can be successfully built on
 llvm-mingw

Fixes undefined symbol errors while linking these crates on llvm-mingw
(targeting ARMv7).

lld-link: error: undefined symbol: __gnu_unwind_frame
>>> referenced by libpanic_unwind-<HASH>.rlib(<O_FILE>):(rust_eh_personality)
>>> referenced by libpanic_unwind-<HASH>.rlib(<O_FILE>):(rust_eh_personality)

lld-link: error: undefined symbol: _Unwind_VRS_Get
>>> referenced by libunwind-<HASH>.rlib(<O_FILE>):(unwind::libunwind::_Unwind_GetGR::<HASH>)
>>> referenced by libunwind-<HASH>.rlib(<O_FILE>):(unwind::libunwind::_Unwind_GetIP::<HASH>)
>>> referenced by libunwind-<HASH>.rlib(<O_FILE>):(unwind::libunwind::_Unwind_SetIP::<HASH>)
>>> referenced 1 more times

lld-link: error: undefined symbol: _Unwind_VRS_Set
>>> referenced by libunwind-<HASH>.rlib(<O_FILE>):(unwind::libunwind::_Unwind_SetGR::<HASH>)
>>> referenced by libunwind-<HASH>.rlib(<O_FILE>):(unwind::libunwind::_Unwind_SetIP::<HASH>)

diff --git a/library/panic_unwind/src/gcc.rs b/library/panic_unwind/src/gcc.rs
index 1111111..2222222 100644
--- a/library/panic_unwind/src/gcc.rs
+++ b/library/panic_unwind/src/gcc.rs
@@ -128,7 +128,7 @@ const UNWIND_DATA_REG: (i32, i32) = (10, 11); // x10, x11
 // https://github.com/gcc-mirror/gcc/blob/trunk/libgcc/unwind-c.c
 
 cfg_if::cfg_if! {
-    if #[cfg(all(target_arch = "arm", not(target_os = "ios"), not(target_os = "netbsd")))] {
+    if #[cfg(all(target_arch = "arm", not(target_os = "ios"), not(target_os = "netbsd"), not(target_os = "windows")))] {
         // ARM EHABI personality routine.
         // https://infocenter.arm.com/help/topic/com.arm.doc.ihi0038b/IHI0038B_ehabi.pdf
         //
diff --git a/library/unwind/src/libunwind.rs b/library/unwind/src/libunwind.rs
index 1111111..2222222 100644
--- a/library/unwind/src/libunwind.rs
+++ b/library/unwind/src/libunwind.rs
@@ -102,7 +102,7 @@ extern "C" {
 }
 
 cfg_if::cfg_if! {
-if #[cfg(any(target_os = "ios", target_os = "netbsd", not(target_arch = "arm")))] {
+if #[cfg(any(target_os = "ios", target_os = "netbsd", target_os = "windows", not(target_arch = "arm")))] {
     // Not ARM EHABI
     #[repr(C)]
     #[derive(Copy, Clone, PartialEq)]
@@ -116,7 +116,7 @@ if #[cfg(any(target_os = "ios", target_os = "netbsd", not(target_arch = "arm")))
     pub use _Unwind_Action::*;
 
     #[cfg_attr(
-        all(feature = "llvm-libunwind", any(target_os = "fuchsia", target_os = "linux")),
+        all(feature = "llvm-libunwind", any(target_os = "fuchsia", target_os = "linux", target_os = "windows")),
         link(name = "unwind", kind = "static", modifiers = "-bundle")
     )]
     extern "C" {
