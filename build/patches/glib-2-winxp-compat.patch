From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 12:33:38 +0100
Subject: [PATCH 1/14] Revert "Use SHGetKnownFolderPath() on Windows"

This reverts commit d270d5b61551de80d36e4f98afd1490fa7c05258.

diff --git a/glib/gutils.c b/glib/gutils.c
index 1111111..2222222 100644
--- a/glib/gutils.c
+++ b/glib/gutils.c
@@ -526,20 +526,23 @@ static  gchar  **g_user_special_dirs = NULL;
 #ifdef G_OS_WIN32
 
 static gchar *
-get_special_folder (REFKNOWNFOLDERID known_folder_guid_ptr)
+get_special_folder (int csidl)
 {
-  wchar_t *wcp = NULL;
-  gchar *result = NULL;
+  wchar_t path[MAX_PATH+1];
   HRESULT hr;
+  LPITEMIDLIST pidl = NULL;
+  BOOL b;
+  gchar *retval = NULL;
 
-  hr = SHGetKnownFolderPath (known_folder_guid_ptr, 0, NULL, &wcp);
-
-  if (SUCCEEDED (hr))
-    result = g_utf16_to_utf8 (wcp, -1, NULL, NULL, NULL);
-
-  CoTaskMemFree (wcp);
-
-  return result;
+  hr = SHGetSpecialFolderLocation (NULL, csidl, &pidl);
+  if (hr == S_OK)
+    {
+      b = SHGetPathFromIDListW (pidl, path);
+      if (b)
+	retval = g_utf16_to_utf8 (path, -1, NULL, NULL, NULL);
+      CoTaskMemFree (pidl);
+    }
+  return retval;
 }
 
 static char *
@@ -792,7 +795,7 @@ g_build_home_dir (void)
     }
 
   if (home_dir == NULL)
-    home_dir = get_special_folder (&FOLDERID_Profile);
+    home_dir = get_special_folder (CSIDL_PROFILE);
 
   if (home_dir == NULL)
     home_dir = get_windows_directory_root ();
@@ -1760,7 +1763,7 @@ g_build_user_data_dir (void)
     data_dir = g_strdup (data_dir_env);
 #ifdef G_OS_WIN32
   else
-    data_dir = get_special_folder (&FOLDERID_LocalAppData);
+    data_dir = get_special_folder (CSIDL_LOCAL_APPDATA);
 #endif
   if (!data_dir || !data_dir[0])
     {
@@ -1786,7 +1789,7 @@ g_build_user_data_dir (void)
  * On Windows it follows XDG Base Directory Specification if `XDG_DATA_HOME`
  * is defined. If `XDG_DATA_HOME` is undefined, the folder to use for local (as
  * opposed to roaming) application data is used instead. See the
- * [documentation for `FOLDERID_LocalAppData`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
+ * [documentation for `CSIDL_LOCAL_APPDATA`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_local_appdata).
  * Note that in this case on Windows it will be the same
  * as what g_get_user_config_dir() returns.
  *
@@ -1824,7 +1827,7 @@ g_build_user_config_dir (void)
     config_dir = g_strdup (config_dir_env);
 #ifdef G_OS_WIN32
   else
-    config_dir = get_special_folder (&FOLDERID_LocalAppData);
+    config_dir = get_special_folder (CSIDL_LOCAL_APPDATA);
 #endif
   if (!config_dir || !config_dir[0])
     {
@@ -1850,7 +1853,7 @@ g_build_user_config_dir (void)
  * On Windows it follows XDG Base Directory Specification if `XDG_CONFIG_HOME` is defined.
  * If `XDG_CONFIG_HOME` is undefined, the folder to use for local (as opposed
  * to roaming) application data is used instead. See the
- * [documentation for `FOLDERID_LocalAppData`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
+ * [documentation for `CSIDL_LOCAL_APPDATA`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_local_appdata).
  * Note that in this case on Windows it will be  the same
  * as what g_get_user_data_dir() returns.
  *
@@ -1887,7 +1890,7 @@ g_build_user_cache_dir (void)
     cache_dir = g_strdup (cache_dir_env);
 #ifdef G_OS_WIN32
   else
-    cache_dir = get_special_folder (&FOLDERID_InternetCache);
+    cache_dir = get_special_folder (CSIDL_INTERNET_CACHE);
 #endif
   if (!cache_dir || !cache_dir[0])
     {
@@ -1914,7 +1917,7 @@ g_build_user_cache_dir (void)
  * If `XDG_CACHE_HOME` is undefined, the directory that serves as a common
  * repository for temporary Internet files is used instead. A typical path is
  * `C:\Documents and Settings\username\Local Settings\Temporary Internet Files`.
- * See the [documentation for `FOLDERID_InternetCache`](https://docs.microsoft.com/en-us/windows/win32/shell/knownfolderid).
+ * See the [documentation for `CSIDL_INTERNET_CACHE`](https://msdn.microsoft.com/en-us/library/windows/desktop/bb762494%28v=vs.85%29.aspx#csidl_internet_cache).
  *
  * The return value is cached and modifying it at runtime is not supported, as
  * it’s not thread-safe to modify environment variables at runtime.
@@ -2094,22 +2097,69 @@ load_user_special_dirs (void)
 static void
 load_user_special_dirs (void)
 {
-  g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = get_special_folder (&FOLDERID_Desktop);
-  g_user_special_dirs[G_USER_DIRECTORY_DOCUMENTS] = get_special_folder (&FOLDERID_Documents);
+  typedef HRESULT (WINAPI *t_SHGetKnownFolderPath) (const GUID *rfid,
+						    DWORD dwFlags,
+						    HANDLE hToken,
+						    PWSTR *ppszPath);
+  t_SHGetKnownFolderPath p_SHGetKnownFolderPath;
+
+  static const GUID FOLDERID_Downloads =
+    { 0x374de290, 0x123f, 0x4565, { 0x91, 0x64, 0x39, 0xc4, 0x92, 0x5e, 0x46, 0x7b } };
+  static const GUID FOLDERID_Public =
+    { 0xDFDF76A2, 0xC82A, 0x4D63, { 0x90, 0x6A, 0x56, 0x44, 0xAC, 0x45, 0x73, 0x85 } };
+
+  wchar_t *wcp;
 
-  g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (&FOLDERID_Downloads);
-  if (g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] == NULL)
-    g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (&FOLDERID_Desktop);
+  p_SHGetKnownFolderPath = (t_SHGetKnownFolderPath) GetProcAddress (GetModuleHandleW (L"shell32.dll"),
+								    "SHGetKnownFolderPath");
 
-  g_user_special_dirs[G_USER_DIRECTORY_MUSIC] = get_special_folder (&FOLDERID_Music);
-  g_user_special_dirs[G_USER_DIRECTORY_PICTURES] = get_special_folder (&FOLDERID_Pictures);
+  g_user_special_dirs[G_USER_DIRECTORY_DESKTOP] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
+  g_user_special_dirs[G_USER_DIRECTORY_DOCUMENTS] = get_special_folder (CSIDL_PERSONAL);
+
+  if (p_SHGetKnownFolderPath == NULL)
+    {
+      g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
+    }
+  else
+    {
+      wcp = NULL;
+      (*p_SHGetKnownFolderPath) (&FOLDERID_Downloads, 0, NULL, &wcp);
+      if (wcp)
+        {
+          g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = g_utf16_to_utf8 (wcp, -1, NULL, NULL, NULL);
+          if (g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] == NULL)
+              g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
+          CoTaskMemFree (wcp);
+        }
+      else
+          g_user_special_dirs[G_USER_DIRECTORY_DOWNLOAD] = get_special_folder (CSIDL_DESKTOPDIRECTORY);
+    }
 
-  g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (&FOLDERID_Public);
-  if (g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] == NULL)
-    g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (&FOLDERID_PublicDocuments);
+  g_user_special_dirs[G_USER_DIRECTORY_MUSIC] = get_special_folder (CSIDL_MYMUSIC);
+  g_user_special_dirs[G_USER_DIRECTORY_PICTURES] = get_special_folder (CSIDL_MYPICTURES);
 
-  g_user_special_dirs[G_USER_DIRECTORY_TEMPLATES] = get_special_folder (&FOLDERID_Templates);
-  g_user_special_dirs[G_USER_DIRECTORY_VIDEOS] = get_special_folder (&FOLDERID_Videos);
+  if (p_SHGetKnownFolderPath == NULL)
+    {
+      /* XXX */
+      g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (CSIDL_COMMON_DOCUMENTS);
+    }
+  else
+    {
+      wcp = NULL;
+      (*p_SHGetKnownFolderPath) (&FOLDERID_Public, 0, NULL, &wcp);
+      if (wcp)
+        {
+          g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = g_utf16_to_utf8 (wcp, -1, NULL, NULL, NULL);
+          if (g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] == NULL)
+              g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (CSIDL_COMMON_DOCUMENTS);
+          CoTaskMemFree (wcp);
+        }
+      else
+          g_user_special_dirs[G_USER_DIRECTORY_PUBLIC_SHARE] = get_special_folder (CSIDL_COMMON_DOCUMENTS);
+    }
+  
+  g_user_special_dirs[G_USER_DIRECTORY_TEMPLATES] = get_special_folder (CSIDL_TEMPLATES);
+  g_user_special_dirs[G_USER_DIRECTORY_VIDEOS] = get_special_folder (CSIDL_MYVIDEO);
 }
 
 #else /* default is unix */
@@ -2461,12 +2511,12 @@ g_win32_get_system_data_dirs_for_module_real (void (*address_of_function)(void))
   data_dirs = g_array_new (TRUE, TRUE, sizeof (char *));
 
   /* Documents and Settings\All Users\Application Data */
-  p = get_special_folder (&FOLDERID_ProgramData);
+  p = get_special_folder (CSIDL_COMMON_APPDATA);
   if (p)
     g_array_append_val (data_dirs, p);
   
   /* Documents and Settings\All Users\Documents */
-  p = get_special_folder (&FOLDERID_PublicDocuments);
+  p = get_special_folder (CSIDL_COMMON_DOCUMENTS);
   if (p)
     g_array_append_val (data_dirs, p);
 	
@@ -2613,8 +2663,8 @@ g_build_system_data_dirs (void)
  * the first elements in the list are the Application Data
  * and Documents folders for All Users. (These can be determined only
  * on Windows 2000 or later and are not present in the list on other
- * Windows versions.) See documentation for FOLDERID_ProgramData and
- * FOLDERID_PublicDocuments.
+ * Windows versions.) See documentation for CSIDL_COMMON_APPDATA and
+ * CSIDL_COMMON_DOCUMENTS.
  *
  * Then follows the "share" subfolder in the installation folder for
  * the package containing the DLL that calls this function, if it can
@@ -2669,7 +2719,7 @@ g_build_system_config_dirs (void)
     }
   else
     {
-      gchar *special_conf_dirs = get_special_folder (&FOLDERID_ProgramData);
+      gchar *special_conf_dirs = get_special_folder (CSIDL_COMMON_APPDATA);
 
       if (special_conf_dirs)
         conf_dir_vector = g_strsplit (special_conf_dirs, G_SEARCHPATH_SEPARATOR_S, 0);
@@ -2707,7 +2757,7 @@ g_build_system_config_dirs (void)
  * This folder is used for application data
  * that is not user specific. For example, an application can store
  * a spell-check dictionary, a database of clip art, or a log file in the
- * FOLDERID_ProgramData folder. This information will not roam and is available
+ * CSIDL_COMMON_APPDATA folder. This information will not roam and is available
  * to anyone using the computer.
  *
  * The return value is cached and modifying it at runtime is not supported, as

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 12:52:03 +0100
Subject: [PATCH 2/14] Revert "gio: Remove broken support for XP"

This reverts commit 4e485d76ac7867905efa47f9dcc12e3341641e23.

diff --git a/docs/reference/gio/gio-sections-common.txt b/docs/reference/gio/gio-sections-common.txt
index 1111111..2222222 100644
--- a/docs/reference/gio/gio-sections-common.txt
+++ b/docs/reference/gio/gio-sections-common.txt
@@ -4603,6 +4603,7 @@ CMSG_LEN
 CMSG_SPACE
 GLIB_ALIGN_TO_SIZEOF
 T_SRV
+ws2funcs
 </SECTION>
 
 <SECTION>
diff --git a/gio/ginetaddress.c b/gio/ginetaddress.c
index 1111111..2222222 100644
--- a/gio/ginetaddress.c
+++ b/gio/ginetaddress.c
@@ -31,6 +31,13 @@
 #include "glibintl.h"
 #include "gnetworkingprivate.h"
 
+#ifdef G_OS_WIN32
+/* Ensure Windows XP runtime compatibility, while using
+ * inet_pton() and inet_ntop() if available
+ */
+#include "gwin32networking.h"
+#endif
+
 struct _GInetAddressPrivate
 {
   GSocketFamily family;
diff --git a/gio/glocalfile.c b/gio/glocalfile.c
index 1111111..2222222 100644
--- a/gio/glocalfile.c
+++ b/gio/glocalfile.c
@@ -832,6 +832,36 @@ get_mount_info (GFileInfo             *fs_info,
 
 #ifdef G_OS_WIN32
 
+static gboolean
+is_xp_or_later (void)
+{
+  static int result = -1;
+
+  if (result == -1)
+    {
+#ifndef _MSC_VER    
+      OSVERSIONINFOEX ver_info = {0};
+      DWORDLONG cond_mask = 0;
+      int op = VER_GREATER_EQUAL;
+
+      ver_info.dwOSVersionInfoSize = sizeof ver_info;
+      ver_info.dwMajorVersion = 5;
+      ver_info.dwMinorVersion = 1;
+
+      VER_SET_CONDITION (cond_mask, VER_MAJORVERSION, op);
+      VER_SET_CONDITION (cond_mask, VER_MINORVERSION, op);
+
+      result = VerifyVersionInfo (&ver_info,
+				  VER_MAJORVERSION | VER_MINORVERSION, 
+				  cond_mask) != 0;
+#else
+      result = ((DWORD)(LOBYTE (LOWORD (GetVersion ())))) >= 5;  
+#endif
+    }
+
+  return result;
+}
+
 static wchar_t *
 get_volume_for_path (const char *path)
 {
@@ -890,10 +920,18 @@ get_filesystem_readonly (GFileInfo  *info,
 
   if (rootdir)
     {
-      DWORD flags;
-      if (GetVolumeInformationW (rootdir, NULL, 0, NULL, NULL, &flags, NULL, 0))
-        g_file_info_set_attribute_boolean (info, G_FILE_ATTRIBUTE_FILESYSTEM_READONLY,
-                                           (flags & FILE_READ_ONLY_VOLUME) != 0);
+      if (is_xp_or_later ())
+        {
+          DWORD flags;
+          if (GetVolumeInformationW (rootdir, NULL, 0, NULL, NULL, &flags, NULL, 0))
+	    g_file_info_set_attribute_boolean (info, G_FILE_ATTRIBUTE_FILESYSTEM_READONLY,
+					       (flags & FILE_READ_ONLY_VOLUME) != 0);
+        }
+      else
+        {
+          if (GetDriveTypeW (rootdir) == DRIVE_CDROM)
+	    g_file_info_set_attribute_boolean (info, G_FILE_ATTRIBUTE_FILESYSTEM_READONLY, TRUE);
+        }
     }
 
   g_free (rootdir);
diff --git a/gio/gnetworking.c b/gio/gnetworking.c
index 1111111..2222222 100644
--- a/gio/gnetworking.c
+++ b/gio/gnetworking.c
@@ -22,6 +22,13 @@
 
 #include "gnetworking.h"
 
+#ifdef G_OS_WIN32
+/* For Windows XP run-time compatibility */
+#include "gwin32networking.h"
+
+GWin32WinsockFuncs ws2funcs = {0};
+#endif
+
 /**
  * SECTION:gnetworking
  * @title: gnetworking.h
@@ -66,10 +73,40 @@ g_networking_init (void)
   if (g_once_init_enter (&inited))
     {
       WSADATA wsadata;
+      HMODULE ws2dll, iphlpapidll;
 
       if (WSAStartup (MAKEWORD (2, 0), &wsadata) != 0)
         g_error ("Windows Sockets could not be initialized");
 
+      /* We want to use these functions if they are available, but
+       * still need to make sure the code still runs on Windows XP
+       */
+      ws2dll = LoadLibraryW (L"ws2_32.dll");
+      iphlpapidll = LoadLibraryW (L"iphlpapi.dll");
+
+      if (ws2dll != NULL)
+        {
+          ws2funcs.pInetNtop =
+            (PFN_InetNtop) GetProcAddress (ws2dll, "inet_ntop");
+          ws2funcs.pInetPton =
+            (PFN_InetPton) GetProcAddress (ws2dll, "inet_pton");
+          FreeLibrary (ws2dll);
+        }
+      else
+        {
+          ws2funcs.pInetNtop = NULL;
+          ws2funcs.pInetPton = NULL;
+        }
+
+      if (iphlpapidll != NULL)
+        {
+          ws2funcs.pIfNameToIndex =
+            (PFN_IfNameToIndex) GetProcAddress (iphlpapidll, "if_nametoindex");
+          FreeLibrary (iphlpapidll);
+        }
+      else
+        ws2funcs.pIfNameToIndex = NULL;
+      
       g_once_init_leave (&inited, 1);
     }
 #endif
diff --git a/gio/gnetworking.h.in b/gio/gnetworking.h.in
index 1111111..2222222 100644
--- a/gio/gnetworking.h.in
+++ b/gio/gnetworking.h.in
@@ -22,11 +22,15 @@
 #include <glib.h>
 
 #ifdef G_OS_WIN32
+
+#ifndef _WIN32_WINNT
+#define _WIN32_WINNT 0x0501
+#endif
 #include <winsock2.h>
 #include <ws2tcpip.h>
 #include <windns.h>
 #include <mswsock.h>
-#include <wspiapi.h>
+@WSPIAPI_INCLUDE@
 #include <iphlpapi.h>
 #undef interface
 
diff --git a/gio/gsocket.c b/gio/gsocket.c
index 1111111..2222222 100644
--- a/gio/gsocket.c
+++ b/gio/gsocket.c
@@ -78,6 +78,8 @@
 
 #ifdef G_OS_WIN32
 #include "giowin32-afunix.h"
+/* For Windows XP runtime compatibility, but use the system's if_nametoindex() if available */
+#include "gwin32networking.h"
 #endif
 
 /**
diff --git a/gio/gwin32networking.h b/gio/gwin32networking.h
new file mode 100644
index 0000000..1111111
--- /dev/null
+++ b/gio/gwin32networking.h
@@ -0,0 +1,42 @@
+/* GIO - GLib Input, Output and Streaming Library
+ *
+ * Copyright (C) 2015 Chun-wei Fan
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General
+ * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef __G_WIN32_NETWORKING_H__
+#define __G_WIN32_NETWORKING_H__
+
+G_BEGIN_DECLS
+
+/* Check if more ANSI-compliant Winsock2 functions are provided */
+/* For run-time compatibility with Windows XP, remove when XP support dropped */
+
+typedef INT (WSAAPI *PFN_InetPton) (INT, PCTSTR, PVOID);
+typedef PCTSTR (WSAAPI *PFN_InetNtop) (INT, PVOID, PTSTR, size_t);
+typedef NET_IFINDEX (WINAPI *PFN_IfNameToIndex) (PCSTR);
+
+typedef struct _GWin32WinsockFuncs
+{
+  PFN_InetPton pInetPton;
+  PFN_InetNtop pInetNtop;
+  PFN_IfNameToIndex pIfNameToIndex;
+} GWin32WinsockFuncs;
+
+extern GWin32WinsockFuncs ws2funcs;
+
+G_END_DECLS /* __G_WIN32_NETWORKING_H__ */
+
+#endif
diff --git a/gio/meson.build b/gio/meson.build
index 1111111..2222222 100644
--- a/gio/meson.build
+++ b/gio/meson.build
@@ -11,9 +11,15 @@ gio_c_args += glib_hidden_visibility_args
 
 gnetworking_h_conf = configuration_data()
 
+gnetworking_h_wspiapi_include = ''
 gnetworking_h_nameser_compat_include = ''
 
-if host_system not in ['windows', 'android']
+if host_system == 'windows'
+  # <wspiapi.h> in the Windows SDK and in mingw-w64 has wrappers for
+  # inline workarounds for getaddrinfo, getnameinfo and freeaddrinfo if
+  # they aren't present at run-time (on Windows 2000).
+  gnetworking_h_wspiapi_include = '#include <wspiapi.h>'
+elif not host_system.contains('android')
   # Don't check for C_IN on Android since it does not define it in public
   # headers, we define it ourselves wherever necessary
   if not cc.compiles('''#include <sys/types.h>
@@ -155,6 +161,7 @@ if host_system == 'android'
   endif
 endif
 
+gnetworking_h_conf.set('WSPIAPI_INCLUDE', gnetworking_h_wspiapi_include)
 gnetworking_h_conf.set('NAMESER_COMPAT_INCLUDE', gnetworking_h_nameser_compat_include)
 
 gnetworking_h = configure_file(input : 'gnetworking.h.in',

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 11:11:12 +0100
Subject: [PATCH 3/14] Revert "GWin32RegistryKey: add MUI capabilities to
 get_value()"

This reverts commit a22a15dc5a1b383f0be74f6a4da8510412c61dba.

diff --git a/gio/gwin32appinfo.c b/gio/gwin32appinfo.c
index 1111111..2222222 100644
--- a/gio/gwin32appinfo.c
+++ b/gio/gwin32appinfo.c
@@ -672,7 +672,6 @@ read_handler_icon (GWin32RegistryKey  *key,
     return;
 
   if (g_win32_registry_key_get_value (icon_key,
-                                      NULL,
                                       TRUE,
                                       "",
                                       &default_type,
@@ -1002,7 +1001,6 @@ get_verbs (GWin32RegistryKey  *program_id_key,
       has_subcommands = FALSE;
       if ((is_uwp == NULL || !(*is_uwp)) && /* Assume UWP apps don't have subcommands */
           g_win32_registry_key_get_value_w (subkey,
-                                            NULL,
                                             TRUE,
                                             L"Subcommands",
                                             &subc_type,
@@ -1039,7 +1037,6 @@ get_verbs (GWin32RegistryKey  *program_id_key,
 
       if (is_uwp != NULL && *is_uwp &&
           !g_win32_registry_key_get_value_w (subkey,
-                                             NULL,
                                              TRUE,
                                              L"ActivatableClassId",
                                              &subc_type,
@@ -1091,7 +1088,6 @@ get_verbs (GWin32RegistryKey  *program_id_key,
   default_verb = NULL;
 
   if (g_win32_registry_key_get_value_w (key,
-                                        NULL,
                                         TRUE,
                                         L"",
                                         &val_type,
@@ -1373,7 +1369,6 @@ decide_which_id_to_use (const gunichar2    *program_id,
   if (uwp_key != NULL)
     {
       got_value = g_win32_registry_key_get_value_w (uwp_key,
-                                                    NULL,
                                                     TRUE,
                                                     L"AppUserModelID",
                                                     &val_type,
@@ -1403,7 +1398,6 @@ decide_which_id_to_use (const gunichar2    *program_id,
   if (uwp_aumid == NULL)
     {
       got_value = g_win32_registry_key_get_value_w (key,
-                                                    NULL,
                                                     TRUE,
                                                     L"",
                                                     &val_type,
@@ -1519,7 +1513,6 @@ process_verbs_commands (GList             *verbs,
 
       command_value = NULL;
       got_value = g_win32_registry_key_get_value_w (key,
-                                                    NULL,
                                                     TRUE,
                                                     L"",
                                                     &val_type,
@@ -1550,7 +1543,6 @@ process_verbs_commands (GList             *verbs,
           gsize verb_displayname_len;
 
           got_value = g_win32_registry_key_get_value_w (verb_key,
-                                                        g_win32_registry_get_os_dirs_w (),
                                                         TRUE,
                                                         L"MUIVerb",
                                                         &val_type,
@@ -1568,7 +1560,6 @@ process_verbs_commands (GList             *verbs,
           if (verb_displayname_u8 == NULL)
             {
               got_value = g_win32_registry_key_get_value_w (verb_key,
-                                                            NULL,
                                                             TRUE,
                                                             L"",
                                                             &val_type,
@@ -1634,7 +1625,6 @@ process_uwp_verbs (GList                    *verbs,
 
       acid = NULL;
       got_value = g_win32_registry_key_get_value_w (key,
-                                                    g_win32_registry_get_os_dirs_w (),
                                                     TRUE,
                                                     L"ActivatableClassId",
                                                     &val_type,
@@ -2049,7 +2039,6 @@ collect_capable_apps_from_clients (GPtrArray *capable_apps,
         continue;
 
       if (g_win32_registry_key_get_value_w (system_client_type,
-                                            NULL,
                                             TRUE,
                                             L"",
                                             &default_type,
@@ -2327,7 +2316,6 @@ read_capable_app (const gunichar2 *app_key_path,
 
   fallback_friendly_name = NULL;
   success = g_win32_registry_key_get_value_w (appkey,
-                                              NULL,
                                               TRUE,
                                               L"",
                                               &vtype,
@@ -2352,7 +2340,6 @@ read_capable_app (const gunichar2 *app_key_path,
 
   friendly_name = NULL;
   success = g_win32_registry_key_get_value_w (capabilities,
-                                              g_win32_registry_get_os_dirs_w (),
                                               TRUE,
                                               L"LocalizedString",
                                               &vtype,
@@ -2378,7 +2365,6 @@ read_capable_app (const gunichar2 *app_key_path,
 
   description = NULL;
   success = g_win32_registry_key_get_value_w (capabilities,
-                                              g_win32_registry_get_os_dirs_w (),
                                               TRUE,
                                               L"ApplicationDescription",
                                               &vtype,
@@ -2405,7 +2391,6 @@ read_capable_app (const gunichar2 *app_key_path,
   if (default_icon_key != NULL)
     {
       success = g_win32_registry_key_get_value_w (default_icon_key,
-                                                  NULL,
                                                   TRUE,
                                                   L"",
                                                   &vtype,
@@ -2423,7 +2408,6 @@ read_capable_app (const gunichar2 *app_key_path,
   if (icon_source == NULL)
     {
       success = g_win32_registry_key_get_value_w (capabilities,
-                                                  NULL,
                                                   TRUE,
                                                   L"ApplicationIcon",
                                                   &vtype,
@@ -2446,7 +2430,6 @@ read_capable_app (const gunichar2 *app_key_path,
 
   narrow_application_name = NULL;
   success = g_win32_registry_key_get_value_w (capabilities,
-                                              g_win32_registry_get_os_dirs_w (),
                                               TRUE,
                                               L"ApplicationName",
                                               &vtype,
@@ -2619,7 +2602,6 @@ read_urls (GWin32RegistryKey *url_associations)
                                                                 url_schema, USER_CHOICE,
                                                                 NULL)) != NULL &&
           g_win32_registry_key_get_value_w (user_choice,
-                                            NULL,
                                             TRUE,
                                             L"Progid",
                                             &val_type,
@@ -2684,7 +2666,6 @@ read_incapable_app (GWin32RegistryKey *incapable_app,
 
   friendly_app_name = NULL;
   success = g_win32_registry_key_get_value_w (incapable_app,
-                                              g_win32_registry_get_os_dirs_w (),
                                               TRUE,
                                               L"FriendlyAppName",
                                               &vtype,
@@ -2696,7 +2677,6 @@ read_incapable_app (GWin32RegistryKey *incapable_app,
     g_clear_pointer (&friendly_app_name, g_free);
 
   no_open_with = g_win32_registry_key_get_value_w (incapable_app,
-                                                   NULL,
                                                    TRUE,
                                                    L"NoOpenWith",
                                                    &vtype,
@@ -2715,7 +2695,6 @@ read_incapable_app (GWin32RegistryKey *incapable_app,
     {
       success =
           g_win32_registry_key_get_value_w (default_icon_key,
-                                            NULL,
                                             TRUE,
                                             L"",
                                             &vtype,
@@ -2882,7 +2861,6 @@ read_exts (GWin32RegistryKey *file_exts)
                                                            USER_CHOICE, NULL);
       if (user_choice &&
           g_win32_registry_key_get_value_w (user_choice,
-                                            NULL,
                                             TRUE,
                                             L"Progid",
                                             &value_type,
@@ -3030,7 +3008,6 @@ read_classes (GWin32RegistryKey *classes_root)
             continue;
 
           success = g_win32_registry_key_get_value_w (class_key,
-                                                      NULL,
                                                       TRUE,
                                                       L"URL Protocol",
                                                       &vtype,
@@ -3640,7 +3617,6 @@ grab_registry_string (GWin32RegistryKey  *handler_appkey,
 
   value = NULL;
   if (g_win32_registry_key_get_value_w (handler_appkey,
-                                        NULL,
                                         TRUE,
                                         value_name,
                                         &vtype,
@@ -4664,7 +4640,6 @@ get_appath_for_exe (const gchar *exe_basename)
     return NULL;
 
   got_value = g_win32_registry_key_get_value (apppath_key,
-                                              NULL,
                                               TRUE,
                                               "Path",
                                               &val_type,
diff --git a/gio/gwin32registrykey.c b/gio/gwin32registrykey.c
index 1111111..2222222 100644
--- a/gio/gwin32registrykey.c
+++ b/gio/gwin32registrykey.c
@@ -1858,119 +1858,9 @@ g_win32_registry_key_get_path_w (GWin32RegistryKey *key)
   return key->priv->absolute_path_w;
 }
 
-/**
- * g_win32_registry_get_os_dirs_w:
- *
- * Returns a list of directories for DLL lookups.
- * Can be used with g_win32_registry_key_get_value_w().
- *
- * Returns: (array zero-terminated=1) (transfer none): a %NULL-terminated array of UTF-16 strings.
- *
- * Since: 2.66
- */
-const gunichar2 * const *
-g_win32_registry_get_os_dirs_w (void)
-{
-  static gunichar2 **mui_os_dirs = NULL;
-
-  if (g_once_init_enter (&mui_os_dirs))
-    {
-      gunichar2 **new_mui_os_dirs;
-      gunichar2 *system32 = NULL;
-      gunichar2 *syswow64 = NULL;
-      UINT buffer_size;
-      gsize array_index = 0;
-
-      buffer_size = GetSystemWow64DirectoryW (NULL, 0);
-
-      if (buffer_size > 0)
-        {
-          UINT copied;
-          syswow64 = g_malloc (buffer_size * sizeof (gunichar2));
-          copied = GetSystemWow64DirectoryW (syswow64, buffer_size);
-          if (copied <= 0)
-            g_clear_pointer (&syswow64, g_free);
-        }
-
-      buffer_size = GetSystemDirectoryW (NULL, 0);
-
-      if (buffer_size > 0)
-        {
-          UINT copied;
-          system32 = g_malloc (buffer_size * sizeof (gunichar2));
-          copied = GetSystemDirectoryW (system32, buffer_size);
-          if (copied <= 0)
-            g_clear_pointer (&system32, g_free);
-        }
-
-      new_mui_os_dirs = g_new0 (gunichar2 *, 3);
-
-      if (system32 != NULL)
-        new_mui_os_dirs[array_index++] = system32;
-
-      if (syswow64 != NULL)
-        new_mui_os_dirs[array_index++] = syswow64;
-
-      new_mui_os_dirs[array_index++] = NULL;
-
-      g_once_init_leave (&mui_os_dirs, new_mui_os_dirs);
-    }
-
-  return (const gunichar2 * const *) mui_os_dirs;
-}
-
-/**
- * g_win32_registry_get_os_dirs:
- *
- * Returns a list of directories for DLL lookups.
- * Can be used with g_win32_registry_key_get_value().
- *
- * Returns: (array zero-terminated=1) (transfer none): a %NULL-terminated array of UTF-8 strings.
- *
- * Since: 2.66
- */
-const gchar * const *
-g_win32_registry_get_os_dirs (void)
-{
-  static gchar **mui_os_dirs = NULL;
-
-  if (g_once_init_enter (&mui_os_dirs))
-    {
-      gchar **new_mui_os_dirs;
-      gsize array_index;
-      gsize new_array_index;
-      const gunichar2 * const *mui_os_dirs_utf16 = g_win32_registry_get_os_dirs_w ();
-
-      for (array_index = 0; mui_os_dirs_utf16[array_index] != NULL; array_index++)
-        ;
-
-      new_mui_os_dirs = g_new0 (gchar *, array_index + 1);
-
-      for (array_index = 0, new_array_index = 0;
-           mui_os_dirs_utf16[array_index] != NULL;
-           array_index++)
-        {
-          new_mui_os_dirs[new_array_index] = g_utf16_to_utf8 (mui_os_dirs_utf16[array_index],
-                                                              -1, NULL, NULL, NULL);
-          if (new_mui_os_dirs[new_array_index] != NULL)
-            new_array_index += 1;
-          else
-            g_critical ("Failed to convert to a system directory #%zu to UTF-8", array_index);
-        }
-
-      g_once_init_leave (&mui_os_dirs, new_mui_os_dirs);
-    }
-
-  return (const gchar * const *) mui_os_dirs;
-}
-
 /**
  * g_win32_registry_key_get_value:
  * @key: (in) (transfer none): a #GWin32RegistryKey
- * @mui_dll_dirs: (in) (transfer none) (array zero-terminated=1) (optional): a %NULL-terminated
- *     array of directory names where the OS
- *     should look for a DLL indicated in a MUI string, if the
- *     DLL path in the string is not absolute
  * @auto_expand: (in) %TRUE to automatically expand G_WIN32_REGISTRY_VALUE_EXPAND_STR
  *     to G_WIN32_REGISTRY_VALUE_STR.
  * @value_name: (in) (transfer none): name of the value to get (in UTF-8).
@@ -1984,32 +1874,12 @@ g_win32_registry_get_os_dirs (void)
  * Get data from a value of a key. String data is guaranteed to be
  * appropriately terminated and will be in UTF-8.
  *
- * When not %NULL, @mui_dll_dirs indicates that `RegLoadMUIStringW()` API
- * should be used instead of the usual `RegQueryValueExW()`. This implies
- * that the value being queried is of type `REG_SZ` or `REG_EXPAND_SZ` (if it is not, the function
- * falls back to `RegQueryValueExW()`), and that this string must undergo special processing
- * (see [`SHLoadIndirectString()` documentation](https://docs.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-shloadindirectstring) for an explanation on what
- * kinds of strings are processed) to get the result.
- *
- * If no specific MUI DLL directories need to be used, pass
- * the return value of g_win32_registry_get_os_dirs() as @mui_dll_dirs
- * (as an bonus, the value from g_win32_registry_get_os_dirs()
- * does not add any extra UTF8->UTF16 conversion overhead).
- *
- * @auto_expand works with @mui_dll_dirs, but only affects the processed
- * string, making it somewhat useless. The unprocessed string is always expanded
- * internally, if its type is `REG_EXPAND_SZ` - there is no need to enable
- * @auto_expand for this to work.
- *
- * The API for this function changed in GLib 2.66 to add the @mui_dll_dirs argument.
- *
  * Returns: %TRUE on success, %FALSE on failure.
  *
- * Since: 2.66
+ * Since: 2.46
  **/
 gboolean
 g_win32_registry_key_get_value (GWin32RegistryKey        *key,
-                                const gchar * const      *mui_dll_dirs,
                                 gboolean                  auto_expand,
                                 const gchar              *value_name,
                                 GWin32RegistryValueType  *value_type,
@@ -2024,9 +1894,6 @@ g_win32_registry_key_get_value (GWin32RegistryKey        *key,
   gchar *value_data_u8;
   gsize value_data_u8_len;
   gboolean result;
-  gsize mui_dll_dirs_count;
-  gunichar2 **mui_dll_dirs_utf16;
-  const gchar * const *mui_os_dirs;
 
   g_return_val_if_fail (G_IS_WIN32_REGISTRY_KEY (key), FALSE);
   g_return_val_if_fail (value_name != NULL, FALSE);
@@ -2042,48 +1909,7 @@ g_win32_registry_key_get_value (GWin32RegistryKey        *key,
   if (value_name_w == NULL)
     return FALSE;
 
-  mui_dll_dirs_utf16 = NULL;
-  mui_os_dirs = g_win32_registry_get_os_dirs ();
-
-  if (mui_dll_dirs != NULL &&
-      mui_dll_dirs != mui_os_dirs)
-    {
-      gsize i;
-
-      mui_dll_dirs_count = g_strv_length ((gchar **) mui_dll_dirs);
-      mui_dll_dirs_utf16 = g_new0 (gunichar2 *, mui_dll_dirs_count + 1);
-
-      for (i = 0; mui_dll_dirs[i] != NULL; i++)
-        {
-          mui_dll_dirs_utf16[i] = g_utf8_to_utf16 (mui_dll_dirs[i], -1, NULL, NULL, error);
-
-          if (mui_dll_dirs_utf16[i] == NULL)
-            break;
-        }
-
-      if (mui_dll_dirs[i] != NULL)
-        {
-          g_prefix_error (error,
-                          "A mui_dll_dirs string #%zu `%s' failed to convert: ",
-                          i, mui_dll_dirs[i]);
-
-          for (i = 0; i < mui_dll_dirs_count; i++)
-            g_free (mui_dll_dirs_utf16[i]);
-
-          g_free (mui_dll_dirs_utf16);
-          g_free (value_name_w);
-
-          return FALSE;
-        }
-    }
-  else if (mui_dll_dirs != NULL &&
-           mui_dll_dirs == mui_os_dirs)
-    {
-      mui_dll_dirs_utf16 = (gunichar2 **) g_win32_registry_get_os_dirs_w ();
-    }
-
   result = g_win32_registry_key_get_value_w (key,
-                                             (const gunichar2 * const *) mui_dll_dirs_utf16,
                                              auto_expand,
                                              value_name_w,
                                              &value_type_g,
@@ -2092,14 +1918,6 @@ g_win32_registry_key_get_value (GWin32RegistryKey        *key,
                                              error);
 
   g_free (value_name_w);
-  if (mui_dll_dirs_utf16 != NULL &&
-      mui_dll_dirs != mui_os_dirs)
-    {
-      gsize array_index;
-      for (array_index = 0; mui_dll_dirs_utf16[array_index] != NULL; array_index++)
-        g_free (mui_dll_dirs_utf16[array_index]);
-      g_free (mui_dll_dirs_utf16);
-    }
 
   if (!result)
     return FALSE;
@@ -2146,98 +1964,9 @@ g_win32_registry_key_get_value (GWin32RegistryKey        *key,
   return TRUE;
 }
 
-/* A wrapper that calls either RegQueryValueExW() or
- * RegLoadMUIStringW() depending on the value of the
- * last argument.
- * Apart from the extra argument, the function behaves
- * just like RegQueryValueExW(), with a few caveats.
- */
-static LSTATUS
-MuiRegQueryValueExW (HKEY                     hKey,
-                     LPCWSTR                  lpValueName,
-                     LPDWORD                  lpReserved,
-                     LPDWORD                  lpType,
-                     LPBYTE                   lpData,
-                     LPDWORD                  lpcbData,
-                     const gunichar2 * const *mui_dll_dirs)
-{
-  gsize dir_index;
-  LSTATUS result = ERROR_PATH_NOT_FOUND;
-  DWORD bufsize;
-  DWORD data_size;
-  PVOID old_value;
-
-  if (mui_dll_dirs == NULL)
-    return RegQueryValueExW (hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
-
-  bufsize = 0;
-
-  if (lpcbData != NULL)
-    bufsize = *lpcbData;
-
-  if (mui_dll_dirs[0] != NULL)
-    {
-      /* Optimization: check that the value actually exists,
-       * before we start trying different mui dll dirs
-       */
-      result = RegQueryValueExW (hKey, lpValueName, NULL, NULL, NULL, 0);
-
-      if (result == ERROR_FILE_NOT_FOUND)
-        return result;
-    }
-
-  Wow64DisableWow64FsRedirection (&old_value);
-
-  /* Try with NULL dir first */
-  result = RegLoadMUIStringW (hKey,
-                              lpValueName,
-                              (wchar_t *) lpData,
-                              bufsize,
-                              &data_size,
-                              0,
-                              NULL);
-
-  /* Not a MUI value, load normally */
-  if (result == ERROR_INVALID_DATA)
-    {
-      Wow64RevertWow64FsRedirection (old_value);
-
-      return RegQueryValueExW (hKey, lpValueName, lpReserved, lpType, lpData, lpcbData);
-    }
-
-  for (dir_index = 0;
-       result == ERROR_FILE_NOT_FOUND &&
-       mui_dll_dirs[dir_index] != NULL;
-       dir_index++)
-    result = RegLoadMUIStringW (hKey,
-                                lpValueName,
-                                (wchar_t *) lpData,
-                                bufsize,
-                                &data_size,
-                                0,
-                                mui_dll_dirs[dir_index]);
-
-  Wow64RevertWow64FsRedirection (old_value);
-
-  if (lpcbData != NULL &&
-      result == ERROR_MORE_DATA)
-    *lpcbData = data_size;
-
-  if (lpType != NULL &&
-      result != ERROR_INVALID_DATA &&
-      result != ERROR_FILE_NOT_FOUND)
-    *lpType = REG_SZ;
-
-  return result;
-}
-
 /**
  * g_win32_registry_key_get_value_w:
  * @key: (in) (transfer none): a #GWin32RegistryKey
- * @mui_dll_dirs: (in) (transfer none) (array zero-terminated=1) (optional): a %NULL-terminated
- *     array of directory names where the OS
- *     should look for a DLL indicated in a MUI string, if the
- *     DLL path in the string is not absolute
  * @auto_expand: (in) %TRUE to automatically expand G_WIN32_REGISTRY_VALUE_EXPAND_STR
  *     to G_WIN32_REGISTRY_VALUE_STR.
  * @value_name: (in) (transfer none): name of the value to get (in UTF-16).
@@ -2248,6 +1977,8 @@ MuiRegQueryValueExW (HKEY                     hKey,
  *   by @value_data.
  * @error: (nullable): a pointer to %NULL #GError, or %NULL
  *
+ * Get data from a value of a key.
+ *
  * Get data from a value of a key. String data is guaranteed to be
  * appropriately terminated and will be in UTF-16.
  *
@@ -2257,30 +1988,12 @@ MuiRegQueryValueExW (HKEY                     hKey,
  * termination cannot be checked and fixed unless the data is retrieved
  * too.
  *
- * When not %NULL, @mui_dll_dirs indicates that `RegLoadMUIStringW()` API
- * should be used instead of the usual `RegQueryValueExW()`. This implies
- * that the value being queried is of type `REG_SZ` or `REG_EXPAND_SZ` (if it is not, the function
- * falls back to `RegQueryValueExW()`), and that this string must undergo special processing
- * (see [`SHLoadIndirectString()` documentation](https://docs.microsoft.com/en-us/windows/win32/api/shlwapi/nf-shlwapi-shloadindirectstring) for an explanation on what
- * kinds of strings are processed) to get the result.
- *
- * If no specific MUI DLL directories need to be used, pass
- * the return value of g_win32_registry_get_os_dirs_w() as @mui_dll_dirs.
- *
- * @auto_expand works with @mui_dll_dirs, but only affects the processed
- * string, making it somewhat useless. The unprocessed string is always expanded
- * internally, if its type is `REG_EXPAND_SZ` - there is no need to enable
- * @auto_expand for this to work.
- *
- * The API for this function changed in GLib 2.66 to add the @mui_dll_dirs argument.
- *
  * Returns: %TRUE on success, %FALSE on failure.
  *
- * Since: 2.66
+ * Since: 2.46
  **/
 gboolean
 g_win32_registry_key_get_value_w (GWin32RegistryKey        *key,
-                                  const gunichar2 * const  *mui_dll_dirs,
                                   gboolean                  auto_expand,
                                   const gunichar2          *value_name,
                                   GWin32RegistryValueType  *value_type,
@@ -2307,13 +2020,12 @@ g_win32_registry_key_get_value_w (GWin32RegistryKey        *key,
                         value_data_size != NULL, FALSE);
 
   req_value_data_size = 0;
-  status = MuiRegQueryValueExW (key->priv->handle,
-                                value_name,
-                                NULL,
-                                &value_type_w,
-                                NULL,
-                                &req_value_data_size,
-                                mui_dll_dirs);
+  status = RegQueryValueExW (key->priv->handle,
+                             value_name,
+                             NULL,
+                             &value_type_w,
+                             NULL,
+                             &req_value_data_size);
 
   if (status != ERROR_MORE_DATA && status != ERROR_SUCCESS)
     {
@@ -2340,13 +2052,12 @@ g_win32_registry_key_get_value_w (GWin32RegistryKey        *key,
 
   req_value_data = g_malloc (req_value_data_size + sizeof (gunichar2) * 2);
   req_value_data_size2 = req_value_data_size;
-  status = MuiRegQueryValueExW (key->priv->handle,
-                                value_name,
-                                NULL,
-                                &value_type_w2,
-                                (gpointer) req_value_data,
-                                &req_value_data_size2,
-                                mui_dll_dirs);
+  status = RegQueryValueExW (key->priv->handle,
+                             value_name,
+                             NULL,
+                             &value_type_w2,
+                             (gpointer) req_value_data,
+                             &req_value_data_size2);
 
   if (status != ERROR_SUCCESS)
     {
diff --git a/gio/gwin32registrykey.h b/gio/gwin32registrykey.h
index 1111111..2222222 100644
--- a/gio/gwin32registrykey.h
+++ b/gio/gwin32registrykey.h
@@ -239,9 +239,8 @@ gboolean         g_win32_registry_value_iter_get_data_w      (GWin32RegistryValu
                                                               gsize                           *value_data_size,
                                                               GError                         **error);
 
-GLIB_AVAILABLE_IN_2_66
+GLIB_AVAILABLE_IN_2_46
 gboolean         g_win32_registry_key_get_value              (GWin32RegistryKey               *key,
-                                                              const gchar * const             *mui_dll_dirs,
                                                               gboolean                         auto_expand,
                                                               const gchar                     *value_name,
                                                               GWin32RegistryValueType         *value_type,
@@ -249,9 +248,8 @@ gboolean         g_win32_registry_key_get_value              (GWin32RegistryKey
                                                               gsize                           *value_data_size,
                                                               GError                         **error);
 
-GLIB_AVAILABLE_IN_2_66
+GLIB_AVAILABLE_IN_2_46
 gboolean         g_win32_registry_key_get_value_w            (GWin32RegistryKey               *key,
-                                                              const gunichar2 * const         *mui_dll_dirs,
                                                               gboolean                         auto_expand,
                                                               const gunichar2                 *value_name,
                                                               GWin32RegistryValueType         *value_type,
@@ -278,12 +276,6 @@ gboolean         g_win32_registry_key_has_changed            (GWin32RegistryKey
 GLIB_AVAILABLE_IN_2_46
 void             g_win32_registry_key_erase_change_indicator (GWin32RegistryKey               *key);
 
-GLIB_AVAILABLE_IN_2_66
-const gunichar2 * const *g_win32_registry_get_os_dirs_w (void);
-
-GLIB_AVAILABLE_IN_2_66
-const gchar * const     *g_win32_registry_get_os_dirs   (void);
-
 G_END_DECLS
 
 #endif /* G_PLATFORM_WIN32 */
diff --git a/glib.supp b/glib.supp
index 1111111..2222222 100644
--- a/glib.supp
+++ b/glib.supp
@@ -946,16 +946,6 @@
 	fun:g_dbus_error_quark
 }
 
-# g_win32_registry_get_os_dirs_w*() caches an array of strings that is allocated only once.
-{
-	g_win32_registry_get_os_dirs
-	Memcheck:Leak
-	match-leak-kinds:reachable,definite
-	fun:malloc
-	...
-	fun:g_win32_registry_get_os_dirs*
-}
-
 # Thread-private data allocated once per thread
 {
 	g_private_set_alloc0

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 13:00:36 +0100
Subject: [PATCH 4/14] Revert "gio: Add g_win32_package_parser_enum_packages()"

This reverts commit e9b09911f6288add60e5691471b543407f79ea48.

diff --git a/gio/gwin32packageparser.c b/gio/gwin32packageparser.c
deleted file mode 100755
index 1111111..0000000
--- a/gio/gwin32packageparser.c
+++ /dev/null
@@ -1,818 +0,0 @@
-/* GIO - GLib Input, Output and Streaming Library
- *
- * Copyright (C) 2020 Руслан Ижбулатов <lrn1986@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General
- * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
- *
- */
-
-/* Queries the system (Windows 8 or newer) for the list
- * of UWP packages, parses their manifests and invokes
- * a user-provided callback with the needed application
- * info.
- */
-
-#include "config.h"
-
-#define COBJMACROS
-#define INITGUID
-#include <windows.h>
-#include <winstring.h>
-#include <roapi.h>
-#include <stdio.h>
-#include <shlwapi.h>
-
-#include "gwin32api-storage.h"
-#include "gwin32api-misc.h"
-#include "gwin32api-iterator.h"
-#include "gwin32api-package.h"
-
-#include <xmllite.h>
-
-#include <glib.h>
-
-#include "gwin32file-sync-stream.h"
-#include "gwin32packageparser.h"
-
-#ifdef G_WINAPI_ONLY_APP
-#define LoadedRoActivateInstance RoActivateInstance
-#define LoadedWindowsCreateStringReference WindowsCreateStringReference
-#define LoadedWindowsDeleteString WindowsDeleteString
-#define sax_WindowsGetStringRawBuffer WindowsGetStringRawBuffer
-#define LoadedWindowsGetStringRawBuffer WindowsGetStringRawBuffer
-#define sax_CreateXmlReader CreateXmlReader
-#else
-typedef HRESULT (WINAPI *RoActivateInstance_func)(HSTRING activatableClassId, IInspectable **instance);
-typedef HRESULT (WINAPI *WindowsCreateStringReference_func)(PCWSTR sourceString, UINT32 length, HSTRING_HEADER *hstringHeader, HSTRING *string);
-typedef HRESULT (WINAPI *WindowsDeleteString_func)(HSTRING string);
-typedef PCWSTR (WINAPI *WindowsGetStringRawBuffer_func)(HSTRING string, UINT32 *length);
-typedef HRESULT (STDAPICALLTYPE *CreateXmlReader_func)(REFIID riid, void **ppvObject, IMalloc *pMalloc);
-#define sax_WindowsGetStringRawBuffer sax->WindowsGetStringRawBuffer
-#define sax_CreateXmlReader sax->CreateXmlReader
-#endif
-
-static gsize
-g_utf16_len (const gunichar2 *str)
-{
-  gsize result;
-
-  for (result = 0; str[0] != 0; str++, result++)
-    ;
-
-  return result;
-}
-
-static gunichar2 *
-g_wcsdup (const gunichar2 *str, gssize str_len)
-{
-  gsize str_len_unsigned;
-  gsize str_size;
-
-  g_return_val_if_fail (str != NULL, NULL);
-
-  if (str_len < 0)
-    str_len_unsigned = g_utf16_len (str);
-  else
-    str_len_unsigned = (gsize) str_len;
-
-  g_assert (str_len_unsigned <= G_MAXSIZE / sizeof (gunichar2) - 1);
-  str_size = (str_len_unsigned + 1) * sizeof (gunichar2);
-
-  return g_memdup2 (str, str_size);
-}
-
-static BOOL
-WIN32_FROM_HRESULT (HRESULT hresult,
-                    DWORD  *win32_error_code)
-{
-  if ((hresult & (HRESULT) 0xFFFF0000) == MAKE_HRESULT (SEVERITY_ERROR, FACILITY_WIN32, 0) ||
-      hresult == S_OK)
-    {
-      *win32_error_code = HRESULT_CODE (hresult);
-      return TRUE;
-    }
-
-  return FALSE;
-}
-
-static GIOErrorEnum
-gio_error_from_hresult (HRESULT hresult)
-{
-  DWORD error;
-
-  if (WIN32_FROM_HRESULT (hresult, &error))
-    return g_io_error_from_errno (error);
-
-  return G_IO_ERROR_FAILED;
-}
-
-static void
-free_extgroup (GWin32PackageExtGroup *g)
-{
-  g_ptr_array_unref (g->verbs);
-  g_ptr_array_unref (g->extensions);
-  g_free (g);
-}
-
-struct _xml_sax_state
-{
-#ifndef G_WINAPI_ONLY_APP
-  WindowsGetStringRawBuffer_func WindowsGetStringRawBuffer;
-  CreateXmlReader_func CreateXmlReader;
-#endif
-
-  GWin32PackageParserCallback callback;
-  gpointer user_data;
-
-  const wchar_t *manifest_filename;
-  gsize          package_index;
-  const wchar_t *wcs_full_name;
-  const wchar_t *wcs_name;
-  HSTRING        package_family;
-
-  gboolean       applist;
-  gboolean       exit_early;
-
-  UINT64         in_package;
-  UINT64         in_applications;
-  UINT64         in_application;
-  UINT64         in_extensions;
-  UINT64         in_extension_protocol;
-  UINT64         in_extension_fta;
-  UINT64         in_fta_group;
-  UINT64         in_sfp;
-  UINT64         in_filetype;
-  UINT64         in_sv;
-  GPtrArray     *supported_extensions;
-  GPtrArray     *supported_protocols;
-  GPtrArray     *supported_verbs;
-  GPtrArray     *supported_extgroups;
-  wchar_t       *application_usermodelid;
-};
-
-static gboolean parse_manifest_file          (struct _xml_sax_state  *sax);
-static gboolean xml_parser_iteration         (struct _xml_sax_state  *sax,
-                                              IXmlReader             *xml_reader);
-static gboolean xml_parser_get_current_state (struct _xml_sax_state  *sax,
-                                              IXmlReader             *xml_reader,
-                                              const wchar_t         **local_name,
-                                              const wchar_t         **prefix,
-                                              const wchar_t         **value);
-
-gboolean
-g_win32_package_parser_enum_packages (GWin32PackageParserCallback   callback,
-                                      gpointer                      user_data,
-                                      GError                      **error)
-{
-  gboolean result = TRUE;
-  HRESULT hr;
-  HSTRING packagemanager_name = NULL;
-  HSTRING_HEADER packageanager_name_header;
-  const wchar_t *packman_id = L"Windows.Management.Deployment.PackageManager";
-  IInspectable *ii_pm = NULL;
-  IPackageManager *pm = NULL;
-  IIterable *packages_iterable = NULL;
-  IIterator *packages_iterator = NULL;
-  CHAR has_current;
-  gsize package_index;
-  const wchar_t *bslash_appmanifest = L"\\AppxManifest.xml";
-  struct _xml_sax_state sax_stack;
-  struct _xml_sax_state *sax = &sax_stack;
-
-#ifndef G_WINAPI_ONLY_APP
-  HMODULE xmllite = NULL;
-  HMODULE combase = NULL;
-  HMODULE winrt = NULL;
-  RoActivateInstance_func LoadedRoActivateInstance;
-  WindowsCreateStringReference_func LoadedWindowsCreateStringReference;
-  WindowsDeleteString_func LoadedWindowsDeleteString;
-  WindowsGetStringRawBuffer_func LoadedWindowsGetStringRawBuffer;
-  CreateXmlReader_func LoadedCreateXmlReader;
-
-  winrt = LoadLibraryW (L"api-ms-win-core-winrt-l1-1-0.dll");
-  if (winrt == NULL)
-    {
-      result = FALSE;
-      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (GetLastError ()),
-                           "Failed to load api-ms-win-core-winrt-l1-1-0.dll");
-      goto cleanup;
-    }
-
-  combase = LoadLibraryW (L"combase.dll");
-  if (combase == NULL)
-    {
-      result = FALSE;
-      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (GetLastError ()),
-                           "Failed to load combase.dll");
-      goto cleanup;
-    }
-
-  xmllite = LoadLibraryW (L"xmllite.dll");
-  if (xmllite == NULL)
-    {
-      result = FALSE;
-      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (GetLastError ()),
-                           "Failed to load xmllite.dll");
-      goto cleanup;
-    }
-
-  LoadedCreateXmlReader = (CreateXmlReader_func) GetProcAddress (xmllite, "CreateXmlReader");
-  if (LoadedCreateXmlReader == NULL)
-    {
-      result = FALSE;
-      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (GetLastError ()),
-                           "CreateXmlReader entry point is not found in xmllite.dll");
-      goto cleanup;
-    }
-
-  LoadedRoActivateInstance = (RoActivateInstance_func) GetProcAddress (winrt, "RoActivateInstance");
-  if (LoadedRoActivateInstance == NULL)
-    {
-      result = FALSE;
-      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (GetLastError ()),
-                           "RoActivateInstance entry point is not found in api-ms-win-core-winrt-l1-1-0.dll");
-      goto cleanup;
-    }
-
-  LoadedWindowsCreateStringReference = (WindowsCreateStringReference_func) GetProcAddress (combase, "WindowsCreateStringReference");
-  if (LoadedWindowsCreateStringReference == NULL)
-    {
-      result = FALSE;
-      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (GetLastError ()),
-                           "WindowsCreateStringReference entry point is not found in combase.dll");
-      goto cleanup;
-    }
-
-  LoadedWindowsDeleteString = (WindowsDeleteString_func) GetProcAddress (combase, "WindowsDeleteString");
-  if (LoadedWindowsDeleteString == NULL)
-    {
-      result = FALSE;
-      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (GetLastError ()),
-                           "WindowsDeleteString entry point is not found in combase.dll");
-      goto cleanup;
-    }
-
-  LoadedWindowsGetStringRawBuffer = (WindowsGetStringRawBuffer_func) GetProcAddress (combase, "WindowsGetStringRawBuffer");
-  if (LoadedWindowsGetStringRawBuffer == NULL)
-    {
-      result = FALSE;
-      g_set_error_literal (error, G_IO_ERROR, g_io_error_from_errno (GetLastError ()),
-                           "WindowsGetStringRawBuffer entry point is not found in combase.dll");
-      goto cleanup;
-    }
-#endif
-
-  /* This essentially locks current GLib thread into apartment COM model. */
-  hr = CoInitializeEx (NULL, COINIT_APARTMENTTHREADED);
-  /* Can return S_FALSE if COM is already initialized,
-   * which is not an error, and we still need to uninitialize after that.
-   */
-  if (hr != S_OK && hr != S_FALSE)
-    {
-      result = FALSE;
-      g_set_error (error, G_IO_ERROR, G_IO_ERROR_NOT_INITIALIZED,
-                   "CoInitializeEx(COINIT_APARTMENTTHREADED) failed with code 0x%lx", hr);
-      goto cleanup;
-    }
-
-#define canned_com_error_handler(function_name_literal, where_to_go) \
-  do \
-  { \
-    if (FAILED (hr)) \
-      { \
-        result = FALSE; \
-        g_set_error (error, G_IO_ERROR, gio_error_from_hresult (hr), \
-                     function_name_literal " failed with code 0x%lx", hr); \
-        goto where_to_go; \
-      } \
-  } while (0)
-
-  hr = LoadedWindowsCreateStringReference (packman_id, wcslen (packman_id), &packageanager_name_header, &packagemanager_name);
-  canned_com_error_handler ("WindowsCreateStringReference()", cleanup);
-
-  hr = LoadedRoActivateInstance (packagemanager_name, &ii_pm);
-  canned_com_error_handler ("RoActivateInstance()", cleanup);
-
-  hr = IInspectable_QueryInterface (ii_pm, &IID_IPackageManager, (void**) &pm);
-  canned_com_error_handler ("IInspectable_QueryInterface()", cleanup);
-
-  hr = IPackageManager_FindPackagesByUserSecurityId (pm, 0, &packages_iterable);
-  canned_com_error_handler ("IPackageManager_FindPackagesByUserSecurityId()", cleanup);
-
-  hr = IIterable_First (packages_iterable, &packages_iterator);
-  canned_com_error_handler ("IIterable_First()", cleanup);
-
-  hr = IIterator_get_HasCurrent (packages_iterator, &has_current);
-  canned_com_error_handler ("IIterator_get_HasCurrent()", cleanup);
-
-  for (package_index = 0; SUCCEEDED (hr) && has_current; package_index++)
-    {
-      IUnknown *item = NULL;
-      IPackage *ipackage = NULL;
-      IPackageId *ipackageid = NULL;
-      IUnknown *package_install_location = NULL;
-      IStorageItem *storage_item = NULL;
-      HSTRING path = NULL;
-      HSTRING name = NULL;
-      HSTRING full_name = NULL;
-      HSTRING package_family = NULL;
-      size_t manifest_filename_size;
-      const wchar_t *wcs_path;
-      const wchar_t *wcs_full_name;
-      const wchar_t *wcs_name;
-      wchar_t *manifest_filename = NULL;
-
-#define canned_com_error_handler_pkg(function_name_literal, where_to_go) \
-      do \
-      { \
-        if (FAILED (hr)) \
-          { \
-            result = FALSE; \
-            g_set_error (error, G_IO_ERROR, gio_error_from_hresult (hr), \
-                         function_name_literal " for package #%zu failed with code 0x%lx", package_index, hr); \
-            goto where_to_go; \
-          } \
-      } while (0)
-
-      hr = IIterator_get_Current (packages_iterator, &item);
-      canned_com_error_handler_pkg ("IIterator_get_Current()", package_cleanup);
-
-      hr = IUnknown_QueryInterface (item, &IID_IPackage, (void **) &ipackage);
-      canned_com_error_handler_pkg ("IUnknown_QueryInterface(IID_IPackage)", package_cleanup);
-
-      hr = IPackage_get_Id (ipackage, &ipackageid);
-      canned_com_error_handler_pkg ("IPackage_get_Id()", package_cleanup);
-
-      hr = IPackageId_get_FullName (ipackageid, &full_name);
-      canned_com_error_handler_pkg ("IPackageId_get_FullName()", package_cleanup);
-
-      hr = IPackageId_get_Name (ipackageid, &name);
-      canned_com_error_handler_pkg ("IPackageId_get_Name()", package_cleanup);
-
-      wcs_full_name = LoadedWindowsGetStringRawBuffer (full_name, NULL);
-      wcs_name = LoadedWindowsGetStringRawBuffer (name, NULL);
-
-#define canned_com_error_handler_pkg_named(function_name_literal, where_to_go) \
-      do \
-      { \
-        if (FAILED (hr)) \
-          { \
-            result = FALSE; \
-            g_set_error (error, G_IO_ERROR, gio_error_from_hresult (hr), \
-                         function_name_literal " for package #%zu (`%S') failed with code 0x%lx", package_index, wcs_full_name, hr); \
-            goto where_to_go; \
-          } \
-      } while (0)
-
-      hr = IPackage_get_InstalledLocation (ipackage, &package_install_location);
-      canned_com_error_handler_pkg_named ("IPackage_get_InstalledLocation()", package_cleanup);
-
-      hr = IUnknown_QueryInterface (package_install_location, &IID_IStorageItem, (void **) &storage_item);
-      canned_com_error_handler_pkg_named ("IUnknown_QueryInterface(IID_IStorageItem)", package_cleanup);
-
-      hr = IPackageId_get_FamilyName (ipackageid, &package_family);
-      canned_com_error_handler_pkg_named ("IPackageId_get_FamilyName()", package_cleanup);
-
-      hr = IStorageItem_get_Path (storage_item, &path);
-      canned_com_error_handler_pkg_named ("IStorageItem_get_Path()", package_cleanup);
-
-      wcs_path = LoadedWindowsGetStringRawBuffer (path, NULL);
-      manifest_filename_size = wcslen (wcs_path) + wcslen (bslash_appmanifest);
-      manifest_filename = g_new (wchar_t, manifest_filename_size + 1);
-      memcpy (manifest_filename, wcs_path, wcslen (wcs_path) * sizeof (wchar_t));
-      memcpy (&manifest_filename[wcslen (wcs_path)], bslash_appmanifest, (wcslen (bslash_appmanifest) + 1) * sizeof (wchar_t));
-
-      memset (sax, 0, sizeof (*sax));
-      sax->callback = callback;
-      sax->user_data = user_data;
-      sax->manifest_filename = manifest_filename;
-      sax->package_index = package_index;
-      sax->wcs_full_name = wcs_full_name;
-      sax->wcs_name = wcs_name;
-      sax->package_family = package_family;
-      sax->applist = TRUE;
-      sax->exit_early = FALSE;
-#ifndef G_WINAPI_ONLY_APP
-      sax->CreateXmlReader = LoadedCreateXmlReader;
-      sax->WindowsGetStringRawBuffer = LoadedWindowsGetStringRawBuffer;
-#endif
-      /* Result isn't checked. If we fail to parse the manifest,
-       * just try the next package, no need to bail out.
-       */
-      parse_manifest_file (sax);
-
-      hr = IIterator_MoveNext (packages_iterator, &has_current);
-      canned_com_error_handler_pkg_named ("IIterator_MoveNext()", package_cleanup);
-
-#undef canned_com_error_handler_pkg_named
-#undef canned_com_error_handler_pkg
-#undef canned_com_error_handler
-
-      package_cleanup:
-      g_clear_pointer (&manifest_filename, g_free);
-
-      if (path)
-        LoadedWindowsDeleteString (path);
-      if (storage_item)
-        (void) IStorageItem_Release (storage_item);
-      if (package_install_location)
-        (void) IUnknown_Release (package_install_location);
-      if (ipackage)
-        (void) IPackage_Release (ipackage);
-      if (item)
-        (void) IUnknown_Release (item);
-
-      if (package_family)
-        LoadedWindowsDeleteString (package_family);
-      if (name)
-        LoadedWindowsDeleteString (name);
-      if (full_name)
-        LoadedWindowsDeleteString (full_name);
-
-      if (ipackageid)
-        (void) IPackageId_Release (ipackageid);
-      if (sax->exit_early)
-        break;
-    }
-
-  cleanup:
-  if (packages_iterator)
-    (void) IIterator_Release (packages_iterator);
-  if (packages_iterable)
-    (void) IIterable_Release (packages_iterable);
-  if (pm)
-    (void) IPackageManager_Release (pm);
-  if (ii_pm)
-    (void) IInspectable_Release (ii_pm);
-
-  CoUninitialize ();
-
-#ifndef G_WINAPI_ONLY_APP
-  if (xmllite)
-    (void) FreeLibrary (xmllite);
-  if (combase)
-    (void) FreeLibrary (combase);
-  if (winrt)
-    (void) FreeLibrary (winrt);
-#endif
-
-  return result;
-}
-
-static gboolean
-parse_manifest_file (struct _xml_sax_state *sax)
-{
-  HRESULT hr;
-  HANDLE file_handle = INVALID_HANDLE_VALUE;
-  IStream *file_stream = NULL;
-  gboolean result;
-  IXmlReader *xml_reader;
-
-  file_handle = CreateFileW (sax->manifest_filename, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
-  if (file_handle == INVALID_HANDLE_VALUE)
-    {
-      g_warning ("Failed to open application manifest `%S' for package #%zu (`%S'): error code 0x%lx",
-                 sax->manifest_filename, sax->package_index, sax->wcs_full_name, GetLastError ());
-      return FALSE;
-    }
-
-  file_stream = g_win32_file_sync_stream_new (file_handle, TRUE, STGM_READ | STGM_SHARE_DENY_WRITE, &hr);
-  if (file_stream == NULL)
-    {
-      g_warning ("Failed to create an IStream for application manifest `%S' for package #%zu (`%S'): HRESULT 0x%lx",
-                 sax->manifest_filename, sax->package_index, sax->wcs_full_name, hr);
-      CloseHandle (file_handle);
-      return FALSE;
-    }
-
-  /* file_stream owns it now */
-  file_handle = NULL;
-
-  hr = sax_CreateXmlReader (&IID_IXmlReader, (void **) &xml_reader, NULL);
-  /* Slightly incorrect - xml reader is not created for any particular file,
-   * in theory we could re-use the same xml reader instance for all files.
-   */
-  if (FAILED (hr))
-    {
-      g_warning ("CreateXmlReader() for application manifest `%S' for package #%zu (`%S') failed with HRESULT 0x%lx",
-                 sax->manifest_filename, sax->package_index, sax->wcs_full_name, hr);
-      (void) IStream_Release (file_stream);
-      return FALSE;
-    }
-
-  hr = IXmlReader_SetInput (xml_reader, (IUnknown *) file_stream);
-  if (FAILED (hr))
-    {
-      g_warning ("IXmlReader_SetInput() for application manifest `%S' for package #%zu (`%S') failed with HRESULT 0x%lx",
-                 sax->manifest_filename, sax->package_index, sax->wcs_full_name, hr);
-      (void) IXmlReader_Release (xml_reader);
-      (void) IStream_Release (file_stream);
-      return FALSE;
-    }
-
-  sax->supported_extensions = g_ptr_array_new_full (0, (GDestroyNotify) g_free);
-  sax->supported_protocols = g_ptr_array_new_full (0, (GDestroyNotify) g_free);
-  sax->supported_verbs = g_ptr_array_new_full (0, (GDestroyNotify) g_free);
-  sax->supported_extgroups = g_ptr_array_new_full (0, (GDestroyNotify) free_extgroup);
-
-  result = TRUE;
-
-  while (!sax->exit_early && result && !IXmlReader_IsEOF (xml_reader))
-    result = xml_parser_iteration (sax, xml_reader);
-
-  g_clear_pointer (&sax->application_usermodelid, g_free);
-  g_clear_pointer (&sax->supported_extensions, g_ptr_array_unref);
-  g_clear_pointer (&sax->supported_verbs, g_ptr_array_unref);
-  g_clear_pointer (&sax->supported_extgroups, g_ptr_array_unref);
-  g_clear_pointer (&sax->supported_protocols, g_ptr_array_unref);
-
-  (void) IXmlReader_Release (xml_reader);
-  (void) IStream_Release (file_stream);
-
-  return result;
-}
-
-static gboolean
-xml_parser_get_current_state (struct _xml_sax_state  *sax,
-                              IXmlReader             *xml_reader,
-                              const wchar_t         **local_name,
-                              const wchar_t         **prefix,
-                              const wchar_t         **value)
-{
-  HRESULT hr;
-  UINT xml_line_number;
-  UINT xml_line_position;
-
-  hr = IXmlReader_GetLineNumber (xml_reader, &xml_line_number);
-  if (FAILED (hr))
-    {
-      g_warning ("IXmlReader_GetLineNumber() for application manifest `%S' for package #%zu (`%S') failed with HRESULT 0x%lx",
-                 sax->manifest_filename, sax->package_index, sax->wcs_full_name, hr);
-      return FALSE;
-    }
-
-  hr = IXmlReader_GetLinePosition (xml_reader, &xml_line_position);
-  if (FAILED (hr))
-    {
-      g_warning ("IXmlReader_GetLinePosition() for application manifest `%S' for package #%zu (`%S') failed with HRESULT 0x%lx",
-                 sax->manifest_filename, sax->package_index, sax->wcs_full_name, hr);
-      return FALSE;
-    }
-
-  hr = IXmlReader_GetLocalName (xml_reader, local_name, NULL);
-  if (FAILED (hr))
-    {
-      g_warning ("IXmlReader_GetLocalName() for application manifest `%S':%u (column %u) for package #%zu (`%S') failed with HRESULT 0x%lx",
-                 sax->manifest_filename, xml_line_number, xml_line_position, sax->package_index, sax->wcs_full_name, hr);
-      return FALSE;
-    }
-
-  hr = IXmlReader_GetPrefix (xml_reader, prefix, NULL);
-  if (FAILED (hr))
-    {
-      g_warning ("IXmlReader_GetPrefix() for application manifest `%S':%u (column %u) for package #%zu (`%S') failed with HRESULT 0x%lx",
-                 sax->manifest_filename, xml_line_number, xml_line_position, sax->package_index, sax->wcs_full_name, hr);
-      return FALSE;
-    }
-
-  hr = IXmlReader_GetValue (xml_reader, value, NULL);
-  if (FAILED (hr))
-    {
-      g_warning ("IXmlReader_GetValue() for application manifest `%S':%u (column %u) for package #%zu (`%S') failed with HRESULT 0x%lx",
-                 sax->manifest_filename, xml_line_number, xml_line_position, sax->package_index, sax->wcs_full_name, hr);
-      return FALSE;
-    }
-
-  return TRUE;
-}
-
-static gboolean
-xml_parser_iteration (struct _xml_sax_state  *sax,
-                      IXmlReader             *xml_reader)
-{
-  HRESULT hr;
-  XmlNodeType xml_node_type;
-  const wchar_t *local_name;
-  const wchar_t *prefix;
-  const wchar_t *value;
-  BOOL is_visual_elements = FALSE;
-  BOOL is_extension = FALSE;
-  BOOL is_protocol = FALSE;
-  BOOL is_empty;
-  BOOL is_application = FALSE;
-  BOOL is_verb = FALSE;
-
-  hr = IXmlReader_Read (xml_reader, &xml_node_type);
-  if (FAILED (hr))
-    {
-      g_warning ("IXmlReader_Read() for application manifest `%S' for package #%zu (`%S') failed with HRESULT 0x%lx",
-                 sax->manifest_filename, sax->package_index, sax->wcs_full_name, hr);
-      return FALSE;
-    }
-
-  if (!xml_parser_get_current_state (sax, xml_reader, &local_name, &prefix, &value))
-    return FALSE;
-
-  switch (xml_node_type)
-    {
-    case XmlNodeType_Element:
-      is_empty = IXmlReader_IsEmptyElement (xml_reader);
-      g_assert (local_name != NULL);
-
-      if (!is_empty &&
-          _wcsicmp (local_name, L"Package") == 0 &&
-          prefix[0] == 0)
-        sax->in_package += 1;
-      else if (!is_empty &&
-               sax->in_package == 1 &&
-               _wcsicmp (local_name, L"Applications") == 0 &&
-               prefix[0] == 0)
-        sax->in_applications += 1;
-      else if (!is_empty &&
-               sax->in_applications == 1 &&
-               _wcsicmp (local_name, L"Application") == 0 &&
-               prefix[0] == 0)
-        {
-          sax->in_application += 1;
-          is_application = TRUE;
-          sax->applist = TRUE;
-          g_clear_pointer (&sax->application_usermodelid, g_free);
-        }
-      else if (sax->in_application == 1 &&
-               _wcsicmp (local_name, L"VisualElements") == 0 &&
-               (_wcsicmp (prefix, L"uap") == 0 || _wcsicmp (prefix, L"uap3") == 0))
-        is_visual_elements = TRUE;
-      else if (!is_empty &&
-               sax->in_application == 1 &&
-               _wcsicmp (local_name, L"Extensions") == 0 &&
-               prefix[0] == 0)
-        sax->in_extensions += 1;
-      else if (!is_empty &&
-               sax->in_application == 1 &&
-               _wcsicmp (local_name, L"Extension") == 0 &&
-               _wcsicmp (prefix, L"uap") == 0)
-        is_extension = TRUE;
-      else if (sax->in_extension_protocol == 1 &&
-               _wcsicmp (local_name, L"Protocol") == 0 &&
-               _wcsicmp (prefix, L"uap") == 0)
-        is_protocol = TRUE;
-      else if (!is_empty &&
-               sax->in_extension_fta == 1 &&
-               _wcsicmp (local_name, L"FileTypeAssociation") == 0 &&
-               _wcsicmp (prefix, L"uap") == 0)
-        sax->in_fta_group += 1;
-      else if (!is_empty &&
-               sax->in_fta_group == 1 &&
-               _wcsicmp (local_name, L"SupportedFileTypes") == 0 &&
-               _wcsicmp (prefix, L"uap") == 0)
-        sax->in_sfp += 1;
-      else if (!is_empty &&
-               sax->in_fta_group == 1 &&
-               _wcsicmp (local_name, L"SupportedVerbs") == 0 &&
-               _wcsicmp (prefix, L"uap2") == 0)
-        sax->in_sv += 1;
-      else if (!is_empty &&
-               sax->in_sfp == 1 &&
-               _wcsicmp (local_name, L"FileType") == 0 &&
-               _wcsicmp (prefix, L"uap") == 0)
-        sax->in_filetype += 1;
-      else if (!is_empty &&
-               sax->in_sv == 1 &&
-               _wcsicmp (local_name, L"Verb") == 0 &&
-               _wcsicmp (prefix, L"uap3") == 0)
-        is_verb = TRUE;
-
-      hr = IXmlReader_MoveToFirstAttribute (xml_reader);
-      while (hr == S_OK)
-        {
-          if (!xml_parser_get_current_state (sax, xml_reader, &local_name, &prefix, &value))
-            return FALSE;
-
-          g_assert (local_name != NULL);
-          g_assert (value != NULL);
-          g_assert (prefix != NULL);
-
-          if (is_application &&
-              sax->application_usermodelid == NULL &&
-              _wcsicmp (local_name, L"Id") == 0)
-            {
-              size_t id_len = 0;
-              size_t value_len = wcslen (value);
-              const wchar_t *wcs_package_family;
-              size_t wcs_package_family_len;
-
-              wcs_package_family = sax_WindowsGetStringRawBuffer (sax->package_family, NULL);
-              wcs_package_family_len = wcslen (wcs_package_family);
-              id_len += wcs_package_family_len + 1 + value_len;
-              sax->application_usermodelid = g_new (wchar_t, id_len + 1);
-              /* AppUserModelId = <family>!<id> */
-              memcpy (&sax->application_usermodelid[0], wcs_package_family, wcs_package_family_len * sizeof (wchar_t));
-              memcpy (&sax->application_usermodelid[wcs_package_family_len], L"!", sizeof (wchar_t));
-              memcpy (&sax->application_usermodelid[wcs_package_family_len + 1], value, (value_len + 1) * sizeof (wchar_t));
-            }
-          else if (is_visual_elements &&
-                   _wcsicmp (local_name, L"AppListEntry") == 0 &&
-                   _wcsicmp (value, L"none") == 0)
-            sax->applist = FALSE;
-          else if (is_extension &&
-                   _wcsicmp (local_name, L"Category") == 0 &&
-                   _wcsicmp (value, L"windows.protocol") == 0)
-            sax->in_extension_protocol += 1;
-          else if (is_extension &&
-                   _wcsicmp (local_name, L"Category") == 0 &&
-                   _wcsicmp (value, L"windows.fileTypeAssociation") == 0)
-            sax->in_extension_fta += 1;
-          else if (is_protocol &&
-                   _wcsicmp (local_name, L"Name") == 0)
-            g_ptr_array_add (sax->supported_protocols, g_wcsdup (value, -1));
-          else if (is_verb &&
-                   _wcsicmp (local_name, L"Id") == 0)
-            g_ptr_array_add (sax->supported_verbs, g_wcsdup (value, -1));
-
-          hr = IXmlReader_MoveToNextAttribute (xml_reader);
-        }
-      break;
-    case XmlNodeType_Text:
-      g_assert (value != NULL);
-
-      if (sax->in_filetype && value[0] != 0)
-        g_ptr_array_add (sax->supported_extensions, g_wcsdup (value, -1));
-      break;
-    case XmlNodeType_EndElement:
-      g_assert (local_name != NULL);
-
-      if (_wcsicmp (local_name, L"Package") == 0 &&
-          prefix[0] == 0)
-        sax->in_package -= 1;
-      else if (sax->in_package == 1 &&
-               _wcsicmp (local_name, L"Applications") == 0 &&
-               prefix[0] == 0)
-        sax->in_applications -= 1;
-      else if (sax->in_application == 1 &&
-               _wcsicmp (local_name, L"Extensions") == 0 &&
-               prefix[0] == 0)
-        sax->in_extensions -= 1;
-      else if (sax->in_extension_protocol == 1 &&
-               _wcsicmp (local_name, L"Extension") == 0 &&
-               _wcsicmp (prefix, L"uap") == 0)
-        sax->in_extension_protocol -= 1;
-      else if (sax->in_extension_fta == 1 &&
-               _wcsicmp (local_name, L"Extension") == 0 &&
-               _wcsicmp (prefix, L"uap") == 0)
-        sax->in_extension_fta -= 1;
-      else if (sax->in_fta_group == 1 &&
-               _wcsicmp (local_name, L"SupportedFileTypes") == 0 &&
-               _wcsicmp (prefix, L"uap") == 0)
-        sax->in_sfp -= 1;
-      else if (sax->in_sfp == 1 &&
-               _wcsicmp (local_name, L"FileType") == 0 &&
-               _wcsicmp (prefix, L"uap") == 0)
-        sax->in_filetype -= 1;
-      else if (sax->in_fta_group == 1 &&
-               _wcsicmp (local_name, L"SupportedVerbs") == 0 &&
-               _wcsicmp (prefix, L"uap2") == 0)
-        sax->in_sv -= 1;
-      else if (sax->in_applications == 1 &&
-               _wcsicmp (local_name, L"Application") == 0 &&
-               prefix[0] == 0)
-        {
-          if (sax->application_usermodelid != NULL)
-            sax->exit_early = !sax->callback (sax->user_data, sax->wcs_full_name, sax->wcs_name,
-                                              sax->application_usermodelid, sax->applist,
-                                              sax->supported_extgroups, sax->supported_protocols);
-          g_clear_pointer (&sax->supported_extgroups, g_ptr_array_unref);
-          g_clear_pointer (&sax->supported_protocols, g_ptr_array_unref);
-          sax->supported_protocols = g_ptr_array_new_full (0, (GDestroyNotify) g_free);
-          sax->supported_extgroups = g_ptr_array_new_full (0, (GDestroyNotify) free_extgroup);
-          sax->in_application -= 1;
-        }
-      else if (sax->in_extension_fta == 1 &&
-               _wcsicmp (local_name, L"FileTypeAssociation") == 0 &&
-               _wcsicmp (prefix, L"uap") == 0)
-        {
-          GWin32PackageExtGroup *new_group = g_new0 (GWin32PackageExtGroup, 1);
-          new_group->extensions = g_steal_pointer (&sax->supported_extensions);
-          sax->supported_extensions = g_ptr_array_new_full (0, (GDestroyNotify) g_free);
-          new_group->verbs = g_steal_pointer (&sax->supported_verbs);
-          sax->supported_verbs  = g_ptr_array_new_full (0, (GDestroyNotify) g_free);
-          g_ptr_array_add (sax->supported_extgroups, new_group);
-          sax->in_fta_group -= 1;
-        }
-      break;
-    default:
-      break;
-    }
-
-  return TRUE;
-}
diff --git a/gio/gwin32packageparser.h b/gio/gwin32packageparser.h
deleted file mode 100755
index 1111111..0000000
--- a/gio/gwin32packageparser.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/* GIO - GLib Input, Output and Streaming Library
- *
- * Copyright (C) 2020 Руслан Ижбулатов <lrn1986@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General
- * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
- *
- */
-#ifndef __G_WIN32_PACKAGE_PARSER_H__
-#define __G_WIN32_PACKAGE_PARSER_H__
-
-#include <gio/gio.h>
-
-#ifdef G_PLATFORM_WIN32
-
-typedef struct _GWin32PackageExtGroup GWin32PackageExtGroup;
-
-struct _GWin32PackageExtGroup
-{
-  GPtrArray *verbs;
-  GPtrArray *extensions;
-};
-
-typedef gboolean (*GWin32PackageParserCallback)(gpointer         user_data,
-                                                const gunichar2 *full_package_name,
-                                                const gunichar2 *package_name,
-                                                const gunichar2 *app_user_model_id,
-                                                gboolean         show_in_applist,
-                                                GPtrArray       *supported_extgroups,
-                                                GPtrArray       *supported_protocols);
-
-gboolean g_win32_package_parser_enum_packages (GWin32PackageParserCallback   callback,
-                                               gpointer                      user_data,
-                                               GError                      **error);
-
-#endif /* G_PLATFORM_WIN32 */
-
-#endif /* __G_WIN32_PACKAGE_PARSER_H__ */
\ No newline at end of file

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 14:09:17 +0100
Subject: [PATCH 5/14] Revert "GWin32AppInfo: read UWP handler metadata
 (indirect strings)"

This reverts commit a2f823113c734bc20e04432f0fe98e0d204e4cb6.

diff --git a/gio/gwin32appinfo.c b/gio/gwin32appinfo.c
index 1111111..2222222 100644
--- a/gio/gwin32appinfo.c
+++ b/gio/gwin32appinfo.c
@@ -42,8 +42,6 @@
 #include "gwin32api-application-activation-manager.h"
 
 #include <windows.h>
-/* For SHLoadIndirectString() */
-#include <shlwapi.h>
 
 #include <glib/gstdioprivate.h>
 #include "giowin32-priv.h"
@@ -606,11 +604,6 @@ static GHashTable *fake_apps = NULL;
  */
 static GHashTable *handlers = NULL;
 
-/* Temporary (only exists while the registry is being scanned) table
- * that maps GWin32RegistryKey objects (keeps a ref) to owned AUMId wchar strings.
- */
-static GHashTable *uwp_handler_table = NULL;
-
 /* Watch this whole subtree */
 static GWin32RegistryKey *url_associations_key;
 
@@ -679,12 +672,6 @@ read_handler_icon (GWin32RegistryKey  *key,
                                       NULL,
                                       NULL))
     {
-      /* TODO: For UWP handlers this string is usually in @{...} form,
-       * see grab_registry_string() below. Right now this
-       * string is read as-is and the icon would silently fail to load.
-       * Also, right now handler icon is not used anywhere
-       * (only app icon is used).
-       */
       if (default_type == G_WIN32_REGISTRY_VALUE_STR &&
           default_value[0] != '\0')
         *icon_out = g_themed_icon_new (default_value);
@@ -1378,16 +1365,9 @@ decide_which_id_to_use (const gunichar2    *program_id,
       if (got_value && val_type != G_WIN32_REGISTRY_VALUE_STR)
         g_clear_pointer (&uwp_aumid, g_free);
 
-      /* Other values in the Application key contain useful information
-       * (description, name, icon), but it's inconvenient to read
-       * it here (we don't have an app object *yet*). Store the key
-       * in a table instead, and look at it later.
-       */
       if (uwp_aumid == NULL)
         g_debug ("ProgramID %S looks like a UWP application, but isn't",
                  program_id);
-      else
-        g_hash_table_insert (uwp_handler_table, g_object_ref (uwp_key), g_wcsdup (uwp_aumid, -1));
 
       g_object_unref (uwp_key);
     }
@@ -3536,150 +3516,6 @@ uwp_package_cb (gpointer         user_data,
   return TRUE;
 }
 
-/* Calls SHLoadIndirectString() in a loop to resolve
- * a string in @{...} format (also supports other indirect
- * strings, but we aren't using it for those).
- * Consumes the input, but may return it unmodified
- * (not an indirect string). May return %NULL (the string
- * is indirect, but the OS failed to load it).
- */
-static gunichar2 *
-resolve_string (gunichar2 *at_string)
-{
-  HRESULT hr;
-  gunichar2 *result = NULL;
-  gsize result_size;
-  /* This value is arbitrary */
-  const gsize reasonable_size_limit = 8192;
-
-  if (at_string == NULL || at_string[0] != L'@')
-    return at_string;
-
-  /* In case of a no-op @at_string will be copied into the output,
-   * buffer so allocate at least that much.
-   */
-  result_size = wcslen (at_string) + 1;
-
-  while (TRUE)
-    {
-      result = g_renew (gunichar2, result, result_size);
-      /* Since there's no built-in way to detect too small buffer size,
-       * we do so by putting a sentinel at the end of the buffer.
-       * If it's 0 (result is always 0-terminated, even if the buffer
-       * is too small), then try larger buffer.
-       */
-      result[result_size - 1] = 0xff;
-      /* This string accepts size in characters, not bytes. */
-      hr = SHLoadIndirectString (at_string, result, result_size, NULL);
-      if (!SUCCEEDED (hr))
-        {
-          g_free (result);
-          g_free (at_string);
-          return NULL;
-        }
-      else if (result[result_size - 1] != 0 ||
-               result_size >= reasonable_size_limit)
-        {
-          /* Now that the length is known, allocate the exact amount */
-          gunichar2 *copy = g_wcsdup (result, -1);
-          g_free (result);
-          g_free (at_string);
-          return copy;
-        }
-
-      result_size *= 2;
-    }
-
-  g_assert_not_reached ();
-
-  return at_string;
-}
-
-static void
-grab_registry_string (GWin32RegistryKey  *handler_appkey,
-                      const gunichar2    *value_name,
-                      gunichar2         **destination,
-                      gchar             **destination_u8)
-{
-  gunichar2 *value;
-  gsize value_size;
-  GWin32RegistryValueType vtype;
-  const gunichar2 *ms_resource_prefix = L"ms-resource:";
-  gsize ms_resource_prefix_len = wcslen (ms_resource_prefix);
-
-  /* Right now this function is not used without destination,
-   * enforce this. destination_u8 is optional.
-   */
-  g_assert (destination != NULL);
-
-  if (*destination != NULL)
-    return;
-
-  value = NULL;
-  if (g_win32_registry_key_get_value_w (handler_appkey,
-                                        TRUE,
-                                        value_name,
-                                        &vtype,
-                                        (void **) &value,
-                                        &value_size,
-                                        NULL) &&
-      vtype != G_WIN32_REGISTRY_VALUE_STR)
-    g_clear_pointer (&value, g_free);
-
-  /* There's no way for us to resolve "ms-resource:..." strings */
-  if (value != NULL &&
-      value_size >= ms_resource_prefix_len &&
-      memcmp (value,
-              ms_resource_prefix,
-              ms_resource_prefix_len * sizeof (gunichar2)) == 0)
-    g_clear_pointer (&value, g_free);
-
-  if (value == NULL)
-    return;
-
-  *destination = resolve_string (g_steal_pointer (&value));
-
-  if (*destination == NULL)
-    return;
-
-  if (destination_u8)
-    *destination_u8 = g_utf16_to_utf8 (*destination, -1, NULL, NULL, NULL);
-}
-
-static void
-read_uwp_handler_info (void)
-{
-  GHashTableIter iter;
-  GWin32RegistryKey *handler_appkey;
-  gunichar2 *aumid;
-
-  g_hash_table_iter_init (&iter, uwp_handler_table);
-
-  while (g_hash_table_iter_next (&iter, (gpointer *) &handler_appkey, (gpointer *) &aumid))
-    {
-      gchar *aumid_u8_folded;
-      GWin32AppInfoApplication *app;
-
-      if (!g_utf16_to_utf8_and_fold (aumid,
-                                     -1,
-                                     NULL,
-                                     &aumid_u8_folded))
-        continue;
-
-      app = g_hash_table_lookup (apps_by_id, aumid_u8_folded);
-      g_clear_pointer (&aumid_u8_folded, g_free);
-
-      if (app == NULL)
-        continue;
-
-      grab_registry_string (handler_appkey, L"ApplicationDescription", &app->description, &app->description_u8);
-      grab_registry_string (handler_appkey, L"ApplicationName", &app->localized_pretty_name, &app->localized_pretty_name_u8);
-      /* TODO: ApplicationIcon value (usually also @{...}) resolves into
-       * an image (PNG only?) with implicit multiple variants (scale, size, etc).
-       */
-    }
-}
-
 static void
 update_registry_data (void)
 {
@@ -3737,8 +3573,6 @@ update_registry_data (void)
       g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
   handlers =
       g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
-  uwp_handler_table =
-      g_hash_table_new_full (g_direct_hash, g_direct_equal, g_object_unref, g_free);
   alloc_end = GetTickCount ();
 
   for (i = 0; i < priority_capable_apps_keys->len; i++)
@@ -3770,8 +3604,6 @@ update_registry_data (void)
       g_clear_error (&error);
     }
 
-  read_uwp_handler_info ();
-
   uwp_end = GetTickCount ();
   link_handlers_to_unregistered_apps ();
   link_handlers_to_fake_apps ();
@@ -3804,7 +3636,6 @@ update_registry_data (void)
   g_ptr_array_free (capable_apps_keys, TRUE);
   g_ptr_array_free (user_capable_apps_keys, TRUE);
   g_ptr_array_free (priority_capable_apps_keys, TRUE);
-  g_hash_table_unref (uwp_handler_table);
 
   return;
 }

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 13:45:26 +0100
Subject: [PATCH 6/14] Revert "GWin32AppInfo: Support launching UWP
 applications"

This reverts commit f28b75e9ffe2fb764185e547d78abffa0f653cb0.

diff --git a/gio/gwin32appinfo.c b/gio/gwin32appinfo.c
index 1111111..2222222 100644
--- a/gio/gwin32appinfo.c
+++ b/gio/gwin32appinfo.c
@@ -22,8 +22,6 @@
 
 #include "config.h"
 
-#define COBJMACROS
-
 #include <string.h>
 
 #include "gcontenttype.h"
@@ -34,12 +32,6 @@
 #include <glib/gstdio.h>
 #include "glibintl.h"
 #include <gio/gwin32registrykey.h>
-#include <shlobj.h>
-/* Contains the definitions from shlobj.h that are
- * guarded as Windows8-or-newer and are unavailable
- * to GLib, being only Windows7-or-newer.
- */
-#include "gwin32api-application-activation-manager.h"
 
 #include <windows.h>
 
@@ -4490,52 +4482,9 @@ get_appath_for_exe (const gchar *exe_basename)
 }
 
 
-static gboolean
-g_win32_app_info_launch_uwp_internal (GWin32AppInfo           *info,
-                                      gboolean                 for_files,
-                                      IShellItemArray         *items,
-                                      GWin32AppInfoShellVerb  *shverb,
-                                      GError                 **error)
-{
-  DWORD pid;
-  IApplicationActivationManager* paam = NULL;
-  gboolean result = TRUE;
-  HRESULT hr;
-
-  hr = CoCreateInstance (&CLSID_ApplicationActivationManager, NULL, CLSCTX_INPROC_SERVER, &IID_IApplicationActivationManager, (void **) &paam);
-  if (FAILED (hr))
-    {
-      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                   "Failed to create ApplicationActivationManager: 0x%lx", hr);
-      return FALSE;
-    }
-
-  if (items == NULL)
-    hr = IApplicationActivationManager_ActivateApplication (paam, (const wchar_t *) info->app->canonical_name, NULL, AO_NONE, &pid);
-  else if (for_files)
-    hr = IApplicationActivationManager_ActivateForFile (paam, (const wchar_t *) info->app->canonical_name, items, shverb->verb_name, &pid);
-  else
-    hr = IApplicationActivationManager_ActivateForProtocol (paam, (const wchar_t *) info->app->canonical_name, items, &pid);
-
-  if (FAILED (hr))
-    {
-      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                   "The app %s failed to launch: 0x%lx",
-                   g_win32_appinfo_application_get_some_name (info->app), hr);
-      result = FALSE;
-    }
-
-  IApplicationActivationManager_Release (paam);
-
-  return result;
-}
-
-
 static gboolean
 g_win32_app_info_launch_internal (GWin32AppInfo      *info,
-                                  GList              *objs, /* non-UWP only */
-                                  gboolean            for_files, /* UWP only */
-                                  IShellItemArray    *items, /* UWP only */
+                                  GList              *objs,
                                   GAppLaunchContext  *launch_context,
                                   GSpawnFlags         spawn_flags,
                                   GError            **error)
@@ -4551,10 +4500,15 @@ g_win32_app_info_launch_internal (GWin32AppInfo      *info,
   g_return_val_if_fail (info->app != NULL, FALSE);
 
   argv = NULL;
+
+  if (launch_context)
+    envp = g_app_launch_context_get_environment (launch_context);
+  else
+    envp = g_get_environ ();
+
   shverb = NULL;
 
-  if (!info->app->is_uwp &&
-      info->handler != NULL &&
+  if (info->handler != NULL &&
       info->handler->verbs->len > 0)
     shverb = _verb_idx (info->handler->verbs, 0);
   else if (info->app->verbs->len > 0)
@@ -4562,7 +4516,7 @@ g_win32_app_info_launch_internal (GWin32AppInfo      *info,
 
   if (shverb == NULL)
     {
-      if (info->app->is_uwp || info->handler == NULL)
+      if (info->handler == NULL)
         g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
                      P_("The app ‘%s’ in the application object has no verbs"),
                      g_win32_appinfo_application_get_some_name (info->app));
@@ -4575,18 +4529,6 @@ g_win32_app_info_launch_internal (GWin32AppInfo      *info,
       return FALSE;
     }
 
-  if (info->app->is_uwp)
-    return g_win32_app_info_launch_uwp_internal (info,
-                                                 for_files,
-                                                 items,
-                                                 shverb,
-                                                 error);
-
-  if (launch_context)
-    envp = g_app_launch_context_get_environment (launch_context);
-  else
-    envp = g_get_environ ();
-
   g_assert (shverb->command_utf8 != NULL);
   command = shverb->command_utf8;
   apppath = get_appath_for_exe (shverb->executable_basename);
@@ -4740,95 +4682,6 @@ g_win32_app_info_supports_files (GAppInfo *appinfo)
 }
 
 
-static IShellItemArray *
-make_item_array (gboolean   for_files,
-                 GList     *files_or_uris,
-                 GError   **error)
-{
-  ITEMIDLIST **item_ids;
-  IShellItemArray *items;
-  GList *p;
-  gsize count;
-  gsize i;
-  HRESULT hr;
-
-  count = g_list_length (files_or_uris);
-
-  items = NULL;
-  item_ids = g_new (ITEMIDLIST*, count);
-
-  for (i = 0, p = files_or_uris; p != NULL; p = p->next, i++)
-    {
-      wchar_t *file_or_uri_utf16;
-
-      if (!for_files)
-        file_or_uri_utf16 = g_utf8_to_utf16 ((gchar *) p->data, -1, NULL, NULL, error);
-      else
-        file_or_uri_utf16 = g_utf8_to_utf16 (g_file_peek_path (G_FILE (p->data)), -1, NULL, NULL, error);
-
-      if (file_or_uri_utf16 == NULL)
-        break;
-
-      if (for_files)
-        {
-          wchar_t *c;
-          gsize len;
-          gsize len_tail;
-
-          len = wcslen (file_or_uri_utf16);
-          /* Filenames *MUST* use single backslashes, else the call
-           * will fail. First convert all slashes to backslashes,
-           * then remove duplicates.
-           */
-          for (c = file_or_uri_utf16; for_files && *c != 0; c++)
-            {
-              if (*c == L'/')
-                *c = L'\\';
-            }
-          for (len_tail = 0, c = &file_or_uri_utf16[len - 1];
-               for_files && c > file_or_uri_utf16;
-               c--, len_tail++)
-            {
-              if (c[0] != L'\\' || c[-1] != L'\\')
-                continue;
-
-              memmove (&c[-1], &c[0], len_tail * sizeof (wchar_t));
-            }
-        }
-
-      hr = SHParseDisplayName (file_or_uri_utf16, NULL, &item_ids[i], 0, NULL);
-      g_free (file_or_uri_utf16);
-
-      if (FAILED (hr))
-        {
-          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                       "File or URI `%S' cannot be parsed by SHParseDisplayName: 0x%lx", file_or_uri_utf16, hr);
-          break;
-        }
-    }
-
-  if (i == count)
-    {
-      hr = SHCreateShellItemArrayFromIDLists (count, (const ITEMIDLIST **) item_ids, &items);
-      if (FAILED (hr))
-        {
-          g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                       "SHCreateShellItemArrayFromIDLists() failed: 0x%lx", hr);
-          items = NULL;
-        }
-    }
-
-  count = i;
-
-  for (i = 0; i < count; i++)
-    CoTaskMemFree (item_ids[i]);
-
-  g_free (item_ids);
-
-  return items;
-}
-
-
 static gboolean
 g_win32_app_info_launch_uris (GAppInfo           *appinfo,
                               GList              *uris,
@@ -4838,26 +4691,6 @@ g_win32_app_info_launch_uris (GAppInfo           *appinfo,
   gboolean res = FALSE;
   gboolean do_files;
   GList *objs;
-  GWin32AppInfo *info = G_WIN32_APP_INFO (appinfo);
-
-  if (info->app != NULL && info->app->is_uwp)
-    {
-      IShellItemArray *items = NULL;
-
-      if (uris)
-        {
-          items = make_item_array (FALSE, uris, error);
-          if (items == NULL)
-            return res;
-        }
-
-      res = g_win32_app_info_launch_internal (info, NULL, FALSE, items, launch_context, 0, error);
-
-      if (items != NULL)
-        IShellItemArray_Release (items);
-
-      return res;
-    }
 
   do_files = g_win32_app_info_supports_files (appinfo);
 
@@ -4886,10 +4719,8 @@ g_win32_app_info_launch_uris (GAppInfo           *appinfo,
 
   objs = g_list_reverse (objs);
 
-  res = g_win32_app_info_launch_internal (info,
+  res = g_win32_app_info_launch_internal (G_WIN32_APP_INFO (appinfo),
                                           objs,
-                                          FALSE,
-                                          NULL,
                                           launch_context,
                                           G_SPAWN_SEARCH_PATH,
                                           error);
@@ -4917,26 +4748,6 @@ g_win32_app_info_launch (GAppInfo           *appinfo,
   gboolean res = FALSE;
   gboolean do_uris;
   GList *objs;
-  GWin32AppInfo *info = G_WIN32_APP_INFO (appinfo);
-
-  if (info->app != NULL && info->app->is_uwp)
-    {
-      IShellItemArray *items = NULL;
-
-      if (files)
-        {
-          items = make_item_array (TRUE, files, error);
-          if (items == NULL)
-            return res;
-        }
-
-      res = g_win32_app_info_launch_internal (info, NULL, TRUE, items, launch_context, 0, error);
-
-      if (items != NULL)
-        IShellItemArray_Release (items);
-
-      return res;
-    }
 
   do_uris = g_win32_app_info_supports_uris (appinfo);
 
@@ -4956,10 +4767,8 @@ g_win32_app_info_launch (GAppInfo           *appinfo,
 
   objs = g_list_reverse (objs);
 
-  res = g_win32_app_info_launch_internal (info,
+  res = g_win32_app_info_launch_internal (G_WIN32_APP_INFO (appinfo),
                                           objs,
-                                          TRUE,
-                                          NULL,
                                           launch_context,
                                           G_SPAWN_SEARCH_PATH,
                                           error);

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 13:45:46 +0100
Subject: [PATCH 7/14] Revert "GWin32AppInfo: more checks for UWP apps"

This reverts commit 0ea2f34723b1ba285252452b19cb2f9535ce1541.

diff --git a/gio/gwin32appinfo.c b/gio/gwin32appinfo.c
index 1111111..2222222 100644
--- a/gio/gwin32appinfo.c
+++ b/gio/gwin32appinfo.c
@@ -4074,7 +4074,7 @@ g_win32_app_info_get_executable (GAppInfo *appinfo)
   if (info->app == NULL)
     return NULL;
 
-  if (info->app->verbs->len > 0 && !info->app->is_uwp)
+  if (info->app->verbs->len > 0)
     return _verb_idx (info->app->verbs, 0)->executable;
 
   return NULL;
@@ -4088,7 +4088,7 @@ g_win32_app_info_get_commandline (GAppInfo *appinfo)
   if (info->app == NULL)
     return NULL;
 
-  if (info->app->verbs->len > 0 && !info->app->is_uwp)
+  if (info->app->verbs->len > 0)
     return _verb_idx (info->app->verbs, 0)->command_utf8;
 
   return NULL;

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 13:18:22 +0100
Subject: [PATCH 8/14] Revert "GWin32AppInfo: Support getting information
 about UWP apps"

This reverts commit 720b51032ca28a32d86b90846ccee1f91e045b4e.

diff --git a/gio/gwin32appinfo.c b/gio/gwin32appinfo.c
index 1111111..2222222 100644
--- a/gio/gwin32appinfo.c
+++ b/gio/gwin32appinfo.c
@@ -181,10 +181,7 @@ struct _GWin32AppInfoHandler {
   /* Usually a class name in HKCR */
   gunichar2 *handler_id;
 
-  /* Registry object obtained by opening @handler_id.
-   * Can be used to watch this handler.
-   * May be %NULL (for fake handlers that we made up).
-   */
+  /* Registry object obtained by opening @handler_id. Can be used to watch this handler. */
   GWin32RegistryKey *key;
 
   /* @handler_id, in UTF-8, folded */
@@ -270,7 +267,6 @@ struct _GWin32AppInfoApplication {
    * key path for the application.
    * For applications tracked by executable name this is the
    * basename of the executable.
-   * For UWP apps this is the AppUserModelID.
    * For fake applications this is the full filename of the
    * executable (as far as it can be inferred from a command line,
    * meaning that it can also be a basename, if that's
@@ -337,8 +333,13 @@ struct _GWin32AppInfoApplication {
    * browser) */
   gboolean default_app;
 
-  /* Set to TRUE for UWP applications */
-  gboolean is_uwp;
+  /* At the moment we do not support getting UWP application info
+   * from the OS. That is, if a file extension is associated with
+   * a UWP app, we can launch it, but we can't read a list of
+   * UWP apps and see which extensions are associated with each one
+   * of them.
+   * That is why there's no uwp_aumid field here.
+   */
 };
 
 #define G_TYPE_WIN32_APPINFO_URL_SCHEMA           (g_win32_appinfo_url_schema_get_type ())
@@ -636,9 +637,6 @@ static GWin32RegistryKey *classes_root_key;
  */
 #include "giowin32-private.c"
 
-/* for g_win32_package_parser_enum_packages() */
-#include "gwin32packageparser.h"
-
 static void
 read_handler_icon (GWin32RegistryKey  *key,
                    GIcon             **icon_out)
@@ -792,20 +790,6 @@ static void                        handler_add_verb       (gpointer           ha
                                                            gboolean           verb_is_preferred,
                                                            gboolean           invent_new_verb_name);
 
-static void                        process_uwp_verbs      (GList                    *verbs,
-                                                           const reg_verb           *preferred_verb,
-                                                           const gunichar2          *path_to_progid,
-                                                           const gunichar2          *progid,
-                                                           gboolean                  autoprefer_first_verb,
-                                                           GWin32AppInfoHandler     *handler_rec,
-                                                           GWin32AppInfoApplication *app);
-
-static void                        uwp_handler_add_verb   (GWin32AppInfoHandler     *handler_rec,
-                                                           GWin32AppInfoApplication *app,
-                                                           const gunichar2          *verb,
-                                                           const gchar              *verb_displayname,
-                                                           gboolean                  verb_is_preferred);
-
 /* output_size is in *bytes*, not gunichar2s! */
 static gboolean
 build_registry_path (gunichar2 *output, gsize output_size, ...)
@@ -896,12 +880,6 @@ _g_win32_registry_key_build_and_new_w (GError **error, ...)
  * @verbshell_prefix is the subkey of @program_id_key
  * that contains the verbs. It is "Shell" initially,
  * but grows with recursive invocations (for subcommands).
- * @is_uwp points to a boolean, which
- * indicates whether the function is being called for a UWP app.
- * It might be switched from %TRUE to %FALSE on return,
- * if the application turns out to not to be UWP on closer inspection.
- * If the application is already known not to be UWP before the
- * call, this pointer can be %NULL instead.
  * Returns TRUE on success, FALSE on failure.
  */
 static gboolean
@@ -909,8 +887,7 @@ get_verbs (GWin32RegistryKey  *program_id_key,
            const reg_verb    **preferred_verb,
            GList             **verbs,
            const gunichar2    *verbname_prefix,
-           const gunichar2    *verbshell_prefix,
-           gboolean           *is_uwp)
+           const gunichar2    *verbshell_prefix)
 {
   GWin32RegistrySubkeyIter iter;
   GWin32RegistryKey *key;
@@ -978,8 +955,7 @@ get_verbs (GWin32RegistryKey  *program_id_key,
        * Essentially, we're flattening the command tree into a list.
        */
       has_subcommands = FALSE;
-      if ((is_uwp == NULL || !(*is_uwp)) && /* Assume UWP apps don't have subcommands */
-          g_win32_registry_key_get_value_w (subkey,
+      if (g_win32_registry_key_get_value_w (subkey,
                                             TRUE,
                                             L"Subcommands",
                                             &subc_type,
@@ -1002,37 +978,16 @@ get_verbs (GWin32RegistryKey  *program_id_key,
           memcpy (&new_nameprefix[verbname_prefix_len], name, (name_len) * sizeof (gunichar2));
           new_nameprefix[verbname_prefix_len + name_len] = L'\\';
           new_nameprefix[verbname_prefix_len + name_len + 1] = 0;
-          has_subcommands = get_verbs (program_id_key, &tmp, verbs, new_nameprefix, new_shellprefix, &dummy);
+          has_subcommands = get_verbs (program_id_key, &tmp, verbs, new_nameprefix, new_shellprefix);
           g_free (new_shellprefix);
           g_free (new_nameprefix);
         }
 
+      g_clear_object (&subkey);
+
       /* Presence of subcommands means that this key itself is not a command-key */
       if (has_subcommands)
-        {
-          g_clear_object (&subkey);
-          continue;
-        }
-
-      if (is_uwp != NULL && *is_uwp &&
-          !g_win32_registry_key_get_value_w (subkey,
-                                             TRUE,
-                                             L"ActivatableClassId",
-                                             &subc_type,
-                                             NULL,
-                                             NULL,
-                                             NULL))
-        {
-          /* We expected a UWP app, but it lacks ActivatableClassId
-           * on a verb, which means that it does not behave like
-           * a UWP app should (msedge being an example - it's UWP,
-           * but has its own launchable exe file and a simple ID),
-           * so we have to treat it like a normal app.
-           */
-           *is_uwp = FALSE;
-        }
-
-      g_clear_object (&subkey);
+        continue;
 
       /* We don't look at the command sub-key and its value (the actual command line) here.
        * We save the registry path instead, and use it later in process_verbs_commands().
@@ -1119,7 +1074,6 @@ get_url_association (const gunichar2          *program_id,
   gchar *handler_id_u8;
   gchar *handler_id_u8_folded;
   gunichar2 *uwp_aumid;
-  gboolean is_uwp;
   GWin32RegistryKey *handler_key;
 
   if ((handler_id = decide_which_id_to_use (program_id,
@@ -1129,22 +1083,22 @@ get_url_association (const gunichar2          *program_id,
                                             &uwp_aumid)) == NULL)
     return;
 
-  is_uwp = uwp_aumid != NULL;
-
-  if (!get_verbs (handler_key, &preferred_verb, &verbs, L"", L"Shell", &is_uwp))
+  if (uwp_aumid != NULL)
+    {
+      verbs = NULL;
+      preferred_verb = NULL;
+    }
+  else if (!get_verbs (handler_key, &preferred_verb, &verbs, L"", L"Shell"))
     {
       g_clear_pointer (&handler_id, g_free);
       g_clear_pointer (&handler_id_u8, g_free);
       g_clear_pointer (&handler_id_u8_folded, g_free);
       g_clear_object (&handler_key);
-      g_clear_pointer (&uwp_aumid, g_free);
+      /* and uwp_aumid is already NULL */
 
       return;
     }
 
-  if (!is_uwp && uwp_aumid != NULL)
-    g_clear_pointer (&uwp_aumid, g_free);
-
   schema_rec = get_schema_object (schema,
                                   schema_u8,
                                   schema_u8_folded);
@@ -1168,6 +1122,7 @@ get_url_association (const gunichar2          *program_id,
                          g_strdup (schema_rec->schema_u8_folded),
                          g_object_ref (handler_rec));
 
+  /* UWP apps get their verbs elsewhere */
   if (uwp_aumid == NULL)
     process_verbs_commands (g_steal_pointer (&verbs),
                             preferred_verb,
@@ -1177,15 +1132,6 @@ get_url_association (const gunichar2          *program_id,
                             handler_add_verb,
                             handler_rec,
                             app);
-  else
-    process_uwp_verbs (g_steal_pointer (&verbs),
-                       preferred_verb,
-                       HKCR,
-                       handler_id,
-                       TRUE,
-                       handler_rec,
-                       app);
-
 
   g_clear_pointer (&handler_id_u8, g_free);
   g_clear_pointer (&handler_id_u8_folded, g_free);
@@ -1212,7 +1158,6 @@ get_file_ext (const gunichar2            *program_id,
   gchar *handler_id_u8;
   gchar *handler_id_u8_folded;
   gunichar2 *uwp_aumid;
-  gboolean is_uwp;
   GWin32RegistryKey *handler_key;
   GWin32AppInfoFileExtension *file_extn;
   gchar *file_extension_u8;
@@ -1239,9 +1184,12 @@ get_file_ext (const gunichar2            *program_id,
       return;
     }
 
-  is_uwp = uwp_aumid != NULL;
-
-  if (!get_verbs (handler_key, &preferred_verb, &verbs, L"", L"Shell", &is_uwp))
+  if (uwp_aumid != NULL)
+    {
+      verbs = NULL;
+      preferred_verb = NULL;
+    }
+  else if (!get_verbs (handler_key, &preferred_verb, &verbs, L"", L"Shell"))
     {
       g_clear_pointer (&handler_id, g_free);
       g_clear_pointer (&handler_id_u8, g_free);
@@ -1249,14 +1197,11 @@ get_file_ext (const gunichar2            *program_id,
       g_clear_object (&handler_key);
       g_clear_pointer (&file_extension_u8, g_free);
       g_clear_pointer (&file_extension_u8_folded, g_free);
-      g_clear_pointer (&uwp_aumid, g_free);
+      /* and uwp_aumid is already NULL */
 
       return;
     }
 
-  if (!is_uwp && uwp_aumid != NULL)
-    g_clear_pointer (&uwp_aumid, g_free);
-
   file_extn = get_ext_object (file_extension, file_extension_u8, file_extension_u8_folded);
 
   handler_rec = get_handler_object (handler_id_u8_folded,
@@ -1280,6 +1225,7 @@ get_file_ext (const gunichar2            *program_id,
   g_clear_pointer (&file_extension_u8_folded, g_free);
   g_clear_object (&handler_key);
 
+  /* UWP apps get their verbs elsewhere */
   if (uwp_aumid == NULL)
     process_verbs_commands (g_steal_pointer (&verbs),
                             preferred_verb,
@@ -1289,14 +1235,6 @@ get_file_ext (const gunichar2            *program_id,
                             handler_add_verb,
                             handler_rec,
                             app);
-  else
-    process_uwp_verbs (g_steal_pointer (&verbs),
-                       preferred_verb,
-                       HKCR,
-                       handler_id,
-                       TRUE,
-                       handler_rec,
-                       app);
 
   g_clear_pointer (&handler_id, g_free);
   g_clear_pointer (&handler_id_u8, g_free);
@@ -1563,75 +1501,6 @@ process_verbs_commands (GList             *verbs,
   g_list_free_full (verbs, reg_verb_free);
 }
 
-static void
-process_uwp_verbs (GList                    *verbs,
-                   const reg_verb           *preferred_verb,
-                   const gunichar2          *path_to_progid,
-                   const gunichar2          *progid,
-                   gboolean                  autoprefer_first_verb,
-                   GWin32AppInfoHandler     *handler_rec,
-                   GWin32AppInfoApplication *app)
-{
-  GList *i;
-
-  g_assert (verbs != NULL);
-
-  for (i = verbs; i; i = i->next)
-    {
-      const reg_verb *verb = (const reg_verb *) i->data;
-      GWin32RegistryKey *key;
-      gboolean got_value;
-      GWin32RegistryValueType val_type;
-      gunichar2 *acid;
-      gsize acid_len;
-
-      key = _g_win32_registry_key_build_and_new_w (NULL, path_to_progid, progid,
-                                                   L"\\", verb->shellpath, NULL);
-
-      if (key == NULL)
-        {
-          g_debug ("%S%S\\%S does not exist",
-                   path_to_progid, progid, verb->shellpath);
-          continue;
-        }
-
-      acid = NULL;
-      got_value = g_win32_registry_key_get_value_w (key,
-                                                    TRUE,
-                                                    L"ActivatableClassId",
-                                                    &val_type,
-                                                    (void **) &acid,
-                                                    &acid_len,
-                                                    NULL);
-
-      if (got_value &&
-          val_type == G_WIN32_REGISTRY_VALUE_STR &&
-          acid_len > sizeof (gunichar2))
-        {
-          /* TODO: default value of a shell subkey, if not empty,
-           * migh contain something like @{Some.Identifier_1234.456.678.789_some_words?ms-resource://Arbitrary.Path/Pointing/Somewhere}
-           * and it might be possible to turn it into a nice displayname.
-           */
-          uwp_handler_add_verb (handler_rec,
-                                app,
-                                verb->name,
-                                NULL,
-                                (preferred_verb && _wcsicmp (verb->name, preferred_verb->name) == 0) ||
-                                (!preferred_verb && autoprefer_first_verb && i == verbs));
-        }
-      else
-        {
-          g_debug ("%S%S\\%S does not have an ActivatableClassId string value",
-                   path_to_progid, progid, verb->shellpath);
-        }
-
-      g_clear_pointer (&acid, g_free);
-      g_clear_object (&key);
-    }
-
-  g_list_free_full (verbs, reg_verb_free);
-}
-
 /* Looks up a schema object identified by
  * @schema_u8_folded in the urls hash table.
  * If such object doesn't exist,
@@ -1679,14 +1548,12 @@ get_handler_object (const gchar       *handler_id_u8_folded,
     return handler_rec;
 
   handler_rec = g_object_new (G_TYPE_WIN32_APPINFO_HANDLER, NULL);
-  if (handler_key)
-    handler_rec->key = g_object_ref (handler_key);
+  handler_rec->key = g_object_ref (handler_key);
   handler_rec->handler_id = g_wcsdup (handler_id, -1);
   handler_rec->handler_id_folded = g_strdup (handler_id_u8_folded);
   if (uwp_aumid)
     handler_rec->uwp_aumid = g_wcsdup (uwp_aumid, -1);
-  if (handler_key)
-    read_handler_icon (handler_key, &handler_rec->icon);
+  read_handler_icon (handler_key, &handler_rec->icon);
   g_hash_table_insert (handlers, g_strdup (handler_id_u8_folded), handler_rec);
 
   return handler_rec;
@@ -1856,75 +1723,6 @@ app_add_verb (gpointer           handler_data1,
     g_ptr_array_insert (app_rec->verbs, 0, shverb);
 }
 
-static void
-uwp_app_add_verb (GWin32AppInfoApplication *app_rec,
-                  const gunichar2          *verb,
-                  const gchar              *verb_displayname)
-{
-  GWin32AppInfoShellVerb *shverb;
-
-  _verb_lookup (app_rec->verbs, verb, &shverb);
-
-  if (shverb != NULL)
-    return;
-
-  shverb = g_object_new (G_TYPE_WIN32_APPINFO_SHELL_VERB, NULL);
-  shverb->verb_name = g_wcsdup (verb, -1);
-  shverb->app = g_object_ref (app_rec);
-  shverb->verb_displayname = g_strdup (verb_displayname);
-
-  shverb->is_uwp = TRUE;
-
-  /* Strictly speaking, this is unnecessary, but
-   * let's make it clear that UWP verbs have no
-   * commands and executables.
-   */
-  shverb->command = NULL;
-  shverb->command_utf8 = NULL;
-  shverb->executable = NULL;
-  shverb->executable_basename = NULL;
-  shverb->executable_folded = NULL;
-  shverb->dll_function = NULL;
-
-  g_ptr_array_add (app_rec->verbs, shverb);
-}
-
-static void
-uwp_handler_add_verb (GWin32AppInfoHandler     *handler_rec,
-                      GWin32AppInfoApplication *app,
-                      const gunichar2          *verb,
-                      const gchar              *verb_displayname,
-                      gboolean                  verb_is_preferred)
-{
-  GWin32AppInfoShellVerb *shverb;
-
-  _verb_lookup (handler_rec->verbs, verb, &shverb);
-
-  if (shverb != NULL)
-    return;
-
-  shverb = g_object_new (G_TYPE_WIN32_APPINFO_SHELL_VERB, NULL);
-  shverb->verb_name = g_wcsdup (verb, -1);
-  shverb->verb_displayname = g_strdup (verb_displayname);
-
-  shverb->is_uwp = TRUE;
-
-  if (app)
-    shverb->app = g_object_ref (app);
-
-  shverb->command = NULL;
-  shverb->command_utf8 = NULL;
-  shverb->executable = NULL;
-  shverb->executable_basename = NULL;
-  shverb->executable_folded = NULL;
-  shverb->dll_function = NULL;
-
-  if (!verb_is_preferred)
-    g_ptr_array_add (handler_rec->verbs, shverb);
-  else
-    g_ptr_array_insert (handler_rec->verbs, 0, shverb);
-}
-
 /* Looks up a file extension object identified by
  * @ext_u8_folded in the extensions hash table.
  * If such object doesn't exist,
@@ -2187,8 +1985,7 @@ get_app_object (GHashTable      *app_hashmap,
                 const gchar     *canonical_name_u8,
                 const gchar     *canonical_name_folded,
                 gboolean         user_specific,
-                gboolean         default_app,
-                gboolean         is_uwp)
+                gboolean         default_app)
 {
   GWin32AppInfoApplication *app;
 
@@ -2204,7 +2001,6 @@ get_app_object (GHashTable      *app_hashmap,
   app->no_open_with = FALSE;
   app->user_specific = user_specific;
   app->default_app = default_app;
-  app->is_uwp = is_uwp;
   g_hash_table_insert (app_hashmap,
                        g_strdup (canonical_name_folded),
                        app);
@@ -2255,9 +2051,7 @@ read_capable_app (const gunichar2 *app_key_path,
                                  &app_key_path_u8_folded) ||
       (appkey = g_win32_registry_key_new_w (app_key_path, NULL)) == NULL ||
       (capabilities = g_win32_registry_key_get_child_w (appkey, L"Capabilities", NULL)) == NULL ||
-      !(get_verbs (appkey, &preferred_verb, &verbs, L"", L"Shell", NULL) ||
-        (verbs_in_root_key = FALSE) ||
-        get_verbs (capabilities, &preferred_verb, &verbs, L"", L"Shell", NULL)))
+      !get_verbs (capabilities, &preferred_verb, &verbs, L"", L"Shell"))
     {
       g_clear_pointer (&canonical_name_u8, g_free);
       g_clear_pointer (&canonical_name_folded, g_free);
@@ -2274,8 +2068,7 @@ read_capable_app (const gunichar2 *app_key_path,
                         canonical_name_u8,
                         canonical_name_folded,
                         user_specific,
-                        default_app,
-                        FALSE);
+                        default_app);
 
   process_verbs_commands (g_steal_pointer (&verbs),
                           preferred_verb,
@@ -2616,7 +2409,7 @@ read_incapable_app (GWin32RegistryKey *incapable_app,
   GIcon *icon = NULL;
   GWin32RegistryKey *supported_key;
 
-  if (!get_verbs (incapable_app, &preferred_verb, &verbs, L"", L"Shell", NULL))
+  if (!get_verbs (incapable_app, &preferred_verb, &verbs, L"", L"Shell"))
     return;
 
   app = get_app_object (apps_by_exe,
@@ -2624,7 +2417,6 @@ read_incapable_app (GWin32RegistryKey *incapable_app,
                         app_exe_basename_u8,
                         app_exe_basename_u8_folded,
                         FALSE,
-                        FALSE,
                         FALSE);
 
   process_verbs_commands (g_steal_pointer (&verbs),
@@ -3057,9 +2849,6 @@ link_handlers_to_unregistered_apps (void)
               GWin32AppInfoShellVerb *app_verb;
               gsize ai;
 
-              if (app->is_uwp)
-                continue;
-
               for (ai = 0; ai < app->verbs->len; ai++)
                 {
                   GWin32PrivateStat app_verb_exec_info;
@@ -3110,9 +2899,6 @@ link_handlers_to_unregistered_apps (void)
                                          (gpointer *) &appexe_fld_basename,
                                          (gpointer *) &app))
             {
-              if (app->is_uwp)
-                continue;
-
               /* Use basename because apps_by_exe only has basenames */
               if (g_strcmp0 (handler_exe_basename, appexe_fld_basename) != 0)
                 continue;
@@ -3181,7 +2967,6 @@ link_handlers_to_fake_apps (void)
                                     handler_verb->executable,
                                     handler_verb->executable_folded,
                                     FALSE,
-                                    FALSE,
                                     FALSE);
               g_clear_pointer (&exename_utf16, g_free);
               handler_verb->app = g_object_ref (app);
@@ -3232,7 +3017,6 @@ link_handlers_to_fake_apps (void)
                                     handler_verb->command_utf8,
                                     command_utf8_folded,
                                     FALSE,
-                                    FALSE,
                                     FALSE);
               g_clear_pointer (&command_utf8_folded, g_free);
               handler_verb->app = g_object_ref (app);
@@ -3253,260 +3037,6 @@ link_handlers_to_fake_apps (void)
     }
 }
 
-static GWin32AppInfoHandler *
-find_uwp_handler_for_ext (GWin32AppInfoFileExtension *file_extn,
-                          const gunichar2            *app_user_model_id)
-{
-  GHashTableIter handler_iter;
-  gchar *handler_id_fld;
-  GWin32AppInfoHandler *handler;
-
-  g_hash_table_iter_init (&handler_iter, file_extn->handlers);
-  while (g_hash_table_iter_next (&handler_iter,
-                                 (gpointer *) &handler_id_fld,
-                                 (gpointer *) &handler))
-    {
-      if (handler->uwp_aumid == NULL)
-        continue;
-
-      if (_wcsicmp (handler->uwp_aumid, app_user_model_id) == 0)
-        return handler;
-    }
-
-  return NULL;
-}
-
-static GWin32AppInfoHandler *
-find_uwp_handler_for_schema (GWin32AppInfoURLSchema *schema,
-                             const gunichar2        *app_user_model_id)
-{
-  GHashTableIter handler_iter;
-  gchar *handler_id_fld;
-  GWin32AppInfoHandler *handler;
-
-  g_hash_table_iter_init (&handler_iter, schema->handlers);
-  while (g_hash_table_iter_next (&handler_iter,
-                                 (gpointer *) &handler_id_fld,
-                                 (gpointer *) &handler))
-    {
-      if (handler->uwp_aumid == NULL)
-        continue;
-
-      if (_wcsicmp (handler->uwp_aumid, app_user_model_id) == 0)
-        return handler;
-    }
-
-  return NULL;
-}
-
-static gboolean
-uwp_package_cb (gpointer         user_data,
-                const gunichar2 *full_package_name,
-                const gunichar2 *package_name,
-                const gunichar2 *app_user_model_id,
-                gboolean         show_in_applist,
-                GPtrArray       *supported_extgroups,
-                GPtrArray       *supported_protocols)
-{
-  guint i, i_verb, i_ext;
-  gint extensions_considered;
-  GWin32AppInfoApplication *app;
-  gchar *app_user_model_id_u8;
-  gchar *app_user_model_id_u8_folded;
-  GHashTableIter iter;
-  GWin32AppInfoHandler *ext;
-  GWin32AppInfoHandler *url;
-
-  if (!g_utf16_to_utf8_and_fold (app_user_model_id,
-                                 -1,
-                                 &app_user_model_id_u8,
-                                 &app_user_model_id_u8_folded))
-    return TRUE;
-
-  app = get_app_object (apps_by_id,
-                        app_user_model_id,
-                        app_user_model_id_u8,
-                        app_user_model_id_u8_folded,
-                        TRUE,
-                        FALSE,
-                        TRUE);
-
-  extensions_considered = 0;
-
-  for (i = 0; i < supported_extgroups->len; i++)
-    {
-      GWin32PackageExtGroup *grp = (GWin32PackageExtGroup *) g_ptr_array_index (supported_extgroups, i);
-
-      extensions_considered += grp->extensions->len;
-
-      for (i_ext = 0; i_ext < grp->extensions->len; i_ext++)
-        {
-          wchar_t *ext = (wchar_t *) g_ptr_array_index (grp->extensions, i_ext);
-          gchar *ext_u8;
-          gchar *ext_u8_folded;
-          GWin32AppInfoFileExtension *file_extn;
-          GWin32AppInfoHandler *handler_rec;
-
-          if (!g_utf16_to_utf8_and_fold (ext,
-                                         -1,
-                                         &ext_u8,
-                                         &ext_u8_folded))
-            continue;
-
-          file_extn = get_ext_object (ext, ext_u8, ext_u8_folded);
-          g_free (ext_u8);
-          handler_rec = find_uwp_handler_for_ext (file_extn, app_user_model_id);
-
-          if (handler_rec == NULL)
-            {
-              /* Use AppUserModelId as the ID of the new fake handler */
-              handler_rec = get_handler_object (app_user_model_id_u8_folded,
-                                                NULL,
-                                                app_user_model_id,
-                                                app_user_model_id);
-              g_hash_table_insert (file_extn->handlers,
-                                   g_strdup (app_user_model_id_u8_folded),
-                                   g_object_ref (handler_rec));
-            }
-
-          if (file_extn->chosen_handler == NULL)
-            g_set_object (&file_extn->chosen_handler, handler_rec);
-
-          /* This is somewhat wasteful, but for 100% correct handling
-           * we need to remember which extensions (handlers) support
-           * which verbs, and each handler gets its own copy of the
-           * verb object, since our design is handler-centric,
-           * not verb-centric. The app also gets a list of verbs,
-           * but without handlers it would have no idea which
-           * verbs can be used with which extensions.
-           */
-          for (i_verb = 0; i_verb < grp->verbs->len; i_verb++)
-            {
-              wchar_t *verb = NULL;
-
-              verb = (wchar_t *) g_ptr_array_index (grp->verbs, i_verb);
-              /* *_add_verb() functions are no-ops when a verb already exists,
-               * so we're free to call them as many times as we want.
-               */
-              uwp_handler_add_verb (handler_rec,
-                                    app,
-                                    verb,
-                                    NULL,
-                                    FALSE);
-            }
-
-          g_hash_table_insert (app->supported_exts,
-                               g_steal_pointer (&ext_u8_folded),
-                               g_object_ref (handler_rec));
-        }
-    }
-
-  g_hash_table_iter_init (&iter, app->supported_exts);
-
-  /* Pile up all handler verbs into the app too,
-   * for cases when we don't have a ref to a handler.
-   */
-  while (g_hash_table_iter_next (&iter, NULL, (gpointer *) &ext))
-    {
-      guint i_hverb;
-
-      if (!ext)
-        continue;
-
-      for (i_hverb = 0; i_hverb < ext->verbs->len; i_hverb++)
-        {
-          GWin32AppInfoShellVerb *handler_verb;
-
-          handler_verb = _verb_idx (ext->verbs, i_hverb);
-          uwp_app_add_verb (app, handler_verb->verb_name, handler_verb->verb_displayname);
-          if (handler_verb->app == NULL && handler_verb->is_uwp)
-            handler_verb->app = g_object_ref (app);
-        }
-    }
-
-  if (app->verbs->len == 0 && extensions_considered > 0)
-    g_warning ("Unexpectedly, UWP app `%S' (AUMId `%s') supports %d extensions but has no verbs",
-               full_package_name, app_user_model_id_u8, extensions_considered);
-
-  for (i = 0; i < supported_protocols->len; i++)
-    {
-      wchar_t *proto = (wchar_t *) g_ptr_array_index (supported_protocols, i);
-      gchar *proto_u8;
-      gchar *proto_u8_folded;
-      GWin32AppInfoURLSchema *schema_rec;
-      GWin32AppInfoHandler *handler_rec;
-
-      if (!g_utf16_to_utf8_and_fold (proto,
-                                     -1,
-                                     &proto_u8,
-                                     &proto_u8_folded))
-        continue;
-
-      schema_rec = get_schema_object (proto,
-                                      proto_u8,
-                                      proto_u8_folded);
-
-      g_free (proto_u8);
-
-      handler_rec = find_uwp_handler_for_schema (schema_rec, app_user_model_id);
-
-      if (handler_rec == NULL)
-        {
-          /* Use AppUserModelId as the ID of the new fake handler */
-          handler_rec = get_handler_object (app_user_model_id_u8_folded,
-                                            NULL,
-                                            app_user_model_id,
-                                            app_user_model_id);
-
-          g_hash_table_insert (schema_rec->handlers,
-                               g_strdup (app_user_model_id_u8_folded),
-                               g_object_ref (handler_rec));
-        }
-
-      if (schema_rec->chosen_handler == NULL)
-        g_set_object (&schema_rec->chosen_handler, handler_rec);
-
-      /* Technically, UWP apps don't use verbs for URIs,
-       * but we only store an app field in verbs,
-       * so each UWP URI handler has to have one.
-       * Let's call it "open".
-       */
-      uwp_handler_add_verb (handler_rec,
-                            app,
-                            L"open",
-                            NULL,
-                            TRUE);
-
-      g_hash_table_insert (app->supported_urls,
-                           g_steal_pointer (&proto_u8_folded),
-                           g_object_ref (handler_rec));
-    }
-
-  g_hash_table_iter_init (&iter, app->supported_urls);
-
-  while (g_hash_table_iter_next (&iter, NULL, (gpointer *) &url))
-    {
-      guint i_hverb;
-
-      if (!url)
-        continue;
-
-      for (i_hverb = 0; i_hverb < url->verbs->len; i_hverb++)
-        {
-          GWin32AppInfoShellVerb *handler_verb;
-
-          handler_verb = _verb_idx (url->verbs, i_hverb);
-          uwp_app_add_verb (app, handler_verb->verb_name, handler_verb->verb_displayname);
-          if (handler_verb->app == NULL && handler_verb->is_uwp)
-            handler_verb->app = g_object_ref (app);
-        }
-    }
-
-  g_free (app_user_model_id_u8);
-  g_free (app_user_model_id_u8_folded);
-
-  return TRUE;
-}
 
 static void
 update_registry_data (void)
@@ -3518,8 +3048,7 @@ update_registry_data (void)
   GWin32RegistryKey *url_associations;
   GWin32RegistryKey *file_exts;
   GWin32RegistryKey *classes_root;
-  DWORD collect_start, collect_end, alloc_end, capable_end, url_end, ext_end, exeapp_end, classes_end, uwp_end, postproc_end;
-  GError *error = NULL;
+  DWORD collect_start, collect_end, alloc_end, capable_end, url_end, ext_end, exeapp_end, classes_end, postproc_end;
 
   url_associations =
       g_win32_registry_key_new_w (L"HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\Shell\\Associations\\UrlAssociations",
@@ -3589,14 +3118,6 @@ update_registry_data (void)
   exeapp_end = GetTickCount ();
   read_classes (classes_root);
   classes_end = GetTickCount ();
-
-  if (!g_win32_package_parser_enum_packages (uwp_package_cb, NULL, &error))
-    {
-      g_debug ("Unable to get UWP apps: %s", error->message);
-      g_clear_error (&error);
-    }
-
-  uwp_end = GetTickCount ();
   link_handlers_to_unregistered_apps ();
   link_handlers_to_fake_apps ();
   postproc_end = GetTickCount ();
@@ -3608,7 +3129,6 @@ update_registry_data (void)
            "Reading extension assocs:    %lums\n"
            "Reading exe-only apps:...... %lums\n"
            "Reading classes:             %lums\n"
-           "Reading UWP apps:            %lums\n"
            "Postprocessing:..............%lums\n"
            "TOTAL:                       %lums",
            collect_end - collect_start,
@@ -3618,8 +3138,7 @@ update_registry_data (void)
            ext_end - url_end,
            exeapp_end - ext_end,
            classes_end - exeapp_end,
-           uwp_end - classes_end,
-           postproc_end - uwp_end,
+           postproc_end - classes_end,
            postproc_end - collect_start);
 
   g_clear_object (&classes_root);
diff --git a/gio/meson.build b/gio/meson.build
index 1111111..2222222 100644
--- a/gio/meson.build
+++ b/gio/meson.build
@@ -421,8 +421,6 @@ else
                     cc.find_library('dnsapi'),
                     iphlpapi_dep,
                     winsock2]
-  platform_deps += uwp_gio_deps
-
   win32_sources += files(
     'gmemorymonitorwin32.c',
     'gwin32registrykey.c',
@@ -431,7 +429,6 @@ else
     'gwin32inputstream.c',
     'gwin32outputstream.c',
     'gwin32file-sync-stream.c',
-    'gwin32packageparser.c',
     'gwin32networkmonitor.c',
     'gwin32networkmonitor.h',
     'gwin32notificationbackend.c',
diff --git a/meson.build b/meson.build
index 1111111..2222222 100644
--- a/meson.build
+++ b/meson.build
@@ -517,12 +517,9 @@ if host_system == 'windows'
     glib_conf.set('G_WINAPI_ONLY_APP', true)
     # We require Windows 10+ on WinRT
     glib_conf.set('_WIN32_WINNT', '0x0A00')
-    uwp_gio_deps = [cc.find_library('shcore'),
-                    cc.find_library('runtimeobject')]
   else
     # We require Windows 7+ on Win32
     glib_conf.set('_WIN32_WINNT', '0x0601')
-    uwp_gio_deps = []
   endif
 endif
 

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 12:26:43 +0100
Subject: [PATCH 9/14] Revert "gio: add GWin32FileSyncStream"

This reverts commit 895fc2eff2bc32f9936285c436003b587e9eda0b.

diff --git a/gio/gwin32file-sync-stream.c b/gio/gwin32file-sync-stream.c
deleted file mode 100755
index 1111111..0000000
--- a/gio/gwin32file-sync-stream.c
+++ /dev/null
@@ -1,508 +0,0 @@
-/* gwin32file-sync-stream.c - a simple IStream implementation
- *
- * Copyright 2020 Руслан Ижбулатов
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public License
- * along with this library; if not, see <http://www.gnu.org/licenses/>.
- */
-
-/* A COM object that implements an IStream backed by a file HANDLE.
- * Works just like `SHCreateStreamOnFileEx()`, but does not
- * support locking, and doesn't force us to link to libshlwapi.
- * Only supports synchronous access.
- */
-#include "config.h"
-#define COBJMACROS
-#define INITGUID
-#include <windows.h>
-
-#include "gwin32file-sync-stream.h"
-
-static HRESULT STDMETHODCALLTYPE _file_sync_stream_query_interface (IStream         *self_ptr,
-                                                                    REFIID           ref_interface_guid,
-                                                                    LPVOID          *output_object_ptr);
-static ULONG STDMETHODCALLTYPE   _file_sync_stream_release         (IStream         *self_ptr);
-static ULONG STDMETHODCALLTYPE   _file_sync_stream_add_ref         (IStream         *self_ptr);
-
-static HRESULT STDMETHODCALLTYPE _file_sync_stream_read            (IStream         *self_ptr,
-                                                                    void            *output_data,
-                                                                    ULONG            bytes_to_read,
-                                                                    ULONG           *output_bytes_read);
-
-static HRESULT STDMETHODCALLTYPE _file_sync_stream_write           (IStream         *self_ptr,
-                                                                    const void      *data,
-                                                                    ULONG            bytes_to_write,
-                                                                    ULONG           *output_bytes_written);
-
-
-static HRESULT STDMETHODCALLTYPE _file_sync_stream_clone           (IStream         *self_ptr,
-                                                                    IStream        **output_clone_ptr);
-static HRESULT STDMETHODCALLTYPE _file_sync_stream_commit          (IStream         *self_ptr,
-                                                                    DWORD            commit_flags);
-static HRESULT STDMETHODCALLTYPE _file_sync_stream_copy_to         (IStream         *self_ptr,
-                                                                    IStream         *output_stream,
-                                                                    ULARGE_INTEGER   bytes_to_copy,
-                                                                    ULARGE_INTEGER  *output_bytes_read,
-                                                                    ULARGE_INTEGER  *output_bytes_written);
-static HRESULT STDMETHODCALLTYPE _file_sync_stream_lock_region     (IStream         *self_ptr,
-                                                                    ULARGE_INTEGER   lock_offset,
-                                                                    ULARGE_INTEGER   lock_bytes,
-                                                                    DWORD            lock_type);
-static HRESULT STDMETHODCALLTYPE _file_sync_stream_revert          (IStream         *self_ptr);
-static HRESULT STDMETHODCALLTYPE _file_sync_stream_seek            (IStream         *self_ptr,
-                                                                    LARGE_INTEGER    move_distance,
-                                                                    DWORD            origin,
-                                                                    ULARGE_INTEGER  *output_new_position);
-static HRESULT STDMETHODCALLTYPE _file_sync_stream_set_size        (IStream         *self_ptr,
-                                                                    ULARGE_INTEGER   new_size);
-static HRESULT STDMETHODCALLTYPE _file_sync_stream_stat            (IStream         *self_ptr,
-                                                                    STATSTG         *output_stat,
-                                                                    DWORD            flags);
-static HRESULT STDMETHODCALLTYPE _file_sync_stream_unlock_region   (IStream         *self_ptr,
-                                                                    ULARGE_INTEGER   lock_offset,
-                                                                    ULARGE_INTEGER   lock_bytes,
-                                                                    DWORD            lock_type);
-
-static void _file_sync_stream_free (GWin32FileSyncStream *self);
-
-static HRESULT STDMETHODCALLTYPE
-_file_sync_stream_query_interface (IStream *self_ptr,
-                                   REFIID   ref_interface_guid,
-                                   LPVOID  *output_object_ptr)
-{
-  *output_object_ptr = NULL;
-
-  if (IsEqualGUID (ref_interface_guid, &IID_IUnknown))
-    {
-      IUnknown_AddRef ((IUnknown *) self_ptr);
-      *output_object_ptr = self_ptr;
-      return S_OK;
-    }
-  else if (IsEqualGUID (ref_interface_guid, &IID_IStream))
-    {
-      IStream_AddRef (self_ptr);
-      *output_object_ptr = self_ptr;
-      return S_OK;
-    }
-
-  return E_NOINTERFACE;
-}
-
-static ULONG STDMETHODCALLTYPE
-_file_sync_stream_add_ref (IStream *self_ptr)
-{
-  GWin32FileSyncStream *self = (GWin32FileSyncStream *) self_ptr;
-
-  return ++self->ref_count;
-}
-
-static ULONG STDMETHODCALLTYPE
-_file_sync_stream_release (IStream *self_ptr)
-{
-  GWin32FileSyncStream *self = (GWin32FileSyncStream *) self_ptr;
-
-  int ref_count = --self->ref_count;
-
-  if (ref_count == 0)
-    _file_sync_stream_free (self);
-
-  return ref_count;
-}
-
-static HRESULT STDMETHODCALLTYPE
-_file_sync_stream_read (IStream *self_ptr,
-                        void    *output_data,
-                        ULONG    bytes_to_read,
-                        ULONG   *output_bytes_read)
-{
-  GWin32FileSyncStream *self = (GWin32FileSyncStream *) self_ptr;
-  DWORD bytes_read;
-
-  if (!ReadFile (self->file_handle, output_data, bytes_to_read, &bytes_read, NULL))
-    {
-      DWORD error = GetLastError ();
-      return __HRESULT_FROM_WIN32 (error);
-    }
-
-  if (output_bytes_read)
-    *output_bytes_read = bytes_read;
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-_file_sync_stream_write (IStream    *self_ptr,
-                         const void *data,
-                         ULONG       bytes_to_write,
-                         ULONG      *output_bytes_written)
-{
-  GWin32FileSyncStream *self = (GWin32FileSyncStream *) self_ptr;
-  DWORD bytes_written;
-
-  if (!WriteFile (self->file_handle, data, bytes_to_write, &bytes_written, NULL))
-    {
-      DWORD error = GetLastError ();
-      return __HRESULT_FROM_WIN32 (error);
-    }
-
-  if (output_bytes_written)
-    *output_bytes_written = bytes_written;
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-_file_sync_stream_seek (IStream        *self_ptr,
-                        LARGE_INTEGER   move_distance,
-                        DWORD           origin,
-                        ULARGE_INTEGER *output_new_position)
-{
-  GWin32FileSyncStream *self = (GWin32FileSyncStream *) self_ptr;
-  LARGE_INTEGER new_position;
-  DWORD move_method;
-
-  switch (origin)
-    {
-    case STREAM_SEEK_SET:
-      move_method = FILE_BEGIN;
-      break;
-    case STREAM_SEEK_CUR:
-      move_method = FILE_CURRENT;
-      break;
-    case STREAM_SEEK_END:
-      move_method = FILE_END;
-      break;
-    default:
-      return E_INVALIDARG;
-    }
-
-  if (!SetFilePointerEx (self->file_handle, move_distance, &new_position, move_method))
-    {
-      DWORD error = GetLastError ();
-      return __HRESULT_FROM_WIN32 (error);
-    }
-
-  (*output_new_position).QuadPart = new_position.QuadPart;
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-_file_sync_stream_set_size (IStream        *self_ptr,
-                            ULARGE_INTEGER  new_size)
-{
-  GWin32FileSyncStream *self = (GWin32FileSyncStream *) self_ptr;
-  FILE_END_OF_FILE_INFO info;
-
-  info.EndOfFile.QuadPart = new_size.QuadPart;
-
-  if (SetFileInformationByHandle (self->file_handle, FileEndOfFileInfo, &info, sizeof (info)))
-    {
-      DWORD error = GetLastError ();
-      return __HRESULT_FROM_WIN32 (error);
-    }
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-_file_sync_stream_copy_to (IStream        *self_ptr,
-                           IStream        *output_stream,
-                           ULARGE_INTEGER  bytes_to_copy,
-                           ULARGE_INTEGER *output_bytes_read,
-                           ULARGE_INTEGER *output_bytes_written)
-{
-  ULARGE_INTEGER counter;
-  ULARGE_INTEGER written_counter;
-  ULARGE_INTEGER read_counter;
-
-  counter.QuadPart = bytes_to_copy.QuadPart;
-  written_counter.QuadPart = 0;
-  read_counter.QuadPart = 0;
-
-  while (counter.QuadPart > 0)
-    {
-      HRESULT hr;
-      ULONG bytes_read;
-      ULONG bytes_written;
-      ULONG bytes_index;
-#define _INTERNAL_BUFSIZE 1024
-      BYTE buffer[_INTERNAL_BUFSIZE];
-#undef _INTERNAL_BUFSIZE
-      ULONG buffer_size = sizeof (buffer);
-      ULONG to_read = buffer_size;
-
-      if (counter.QuadPart < buffer_size)
-        to_read = (ULONG) counter.QuadPart;
-
-      /* Because MS SDK has a function IStream_Read() with 3 arguments */
-      hr = self_ptr->lpVtbl->Read (self_ptr, buffer, to_read, &bytes_read);
-      if (!SUCCEEDED (hr))
-        return hr;
-
-      read_counter.QuadPart += bytes_read;
-
-      if (bytes_read == 0)
-        break;
-
-      bytes_index = 0;
-
-      while (bytes_index < bytes_read)
-        {
-          /* Because MS SDK has a function IStream_Write() with 3 arguments */
-          hr = output_stream->lpVtbl->Write (output_stream, &buffer[bytes_index], bytes_read - bytes_index, &bytes_written);
-          if (!SUCCEEDED (hr))
-            return hr;
-
-          if (bytes_written == 0)
-            return __HRESULT_FROM_WIN32 (ERROR_WRITE_FAULT);
-
-          bytes_index += bytes_written;
-          written_counter.QuadPart += bytes_written;
-        }
-    }
-
-  if (output_bytes_read)
-    output_bytes_read->QuadPart = read_counter.QuadPart;
-  if (output_bytes_written)
-    output_bytes_written->QuadPart = written_counter.QuadPart;
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-_file_sync_stream_commit (IStream *self_ptr,
-                          DWORD    commit_flags)
-{
-  GWin32FileSyncStream *self = (GWin32FileSyncStream *) self_ptr;
-
-  if (!FlushFileBuffers (self->file_handle))
-    {
-      DWORD error = GetLastError ();
-      return __HRESULT_FROM_WIN32 (error);
-    }
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-_file_sync_stream_revert (IStream *self_ptr)
-{
-  return E_NOTIMPL;
-}
-
-static HRESULT STDMETHODCALLTYPE
-_file_sync_stream_lock_region (IStream        *self_ptr,
-                               ULARGE_INTEGER  lock_offset,
-                               ULARGE_INTEGER  lock_bytes,
-                               DWORD           lock_type)
-{
-  return STG_E_INVALIDFUNCTION;
-}
-
-static HRESULT STDMETHODCALLTYPE
-_file_sync_stream_unlock_region (IStream        *self_ptr,
-                                 ULARGE_INTEGER  lock_offset,
-                                 ULARGE_INTEGER  lock_bytes,
-                                 DWORD           lock_type)
-{
-  return STG_E_INVALIDFUNCTION;
-}
-
-static HRESULT STDMETHODCALLTYPE
-_file_sync_stream_stat (IStream *self_ptr,
-                        STATSTG *output_stat,
-                        DWORD    flags)
-{
-  GWin32FileSyncStream *self = (GWin32FileSyncStream *) self_ptr;
-  BOOL get_name = FALSE;
-  FILE_BASIC_INFO bi;
-  FILE_STANDARD_INFO si;
-
-  if (output_stat == NULL)
-    return STG_E_INVALIDPOINTER;
-
-  switch (flags)
-    {
-    case STATFLAG_DEFAULT:
-      get_name = TRUE;
-      break;
-    case STATFLAG_NONAME:
-      get_name = FALSE;
-      break;
-    default:
-      return STG_E_INVALIDFLAG;
-    }
-
-  if (!GetFileInformationByHandleEx (self->file_handle, FileBasicInfo, &bi, sizeof (bi)) ||
-      !GetFileInformationByHandleEx (self->file_handle, FileStandardInfo, &si, sizeof (si)))
-    {
-      DWORD error = GetLastError ();
-      return __HRESULT_FROM_WIN32 (error);
-    }
-
-  output_stat->type = STGTY_STREAM;
-  output_stat->mtime.dwLowDateTime = bi.LastWriteTime.LowPart;
-  output_stat->mtime.dwHighDateTime = bi.LastWriteTime.HighPart;
-  output_stat->ctime.dwLowDateTime = bi.CreationTime.LowPart;
-  output_stat->ctime.dwHighDateTime = bi.CreationTime.HighPart;
-  output_stat->atime.dwLowDateTime = bi.LastAccessTime.LowPart;
-  output_stat->atime.dwHighDateTime = bi.LastAccessTime.HighPart;
-  output_stat->grfLocksSupported = 0;
-  memset (&output_stat->clsid, 0, sizeof (CLSID));
-  output_stat->grfStateBits = 0;
-  output_stat->reserved = 0;
-  output_stat->cbSize.QuadPart = si.EndOfFile.QuadPart;
-  output_stat->grfMode = self->stgm_mode;
-
-  if (get_name)
-    {
-      DWORD tries;
-      wchar_t *buffer;
-
-      /* Nothing in the documentation guarantees that the name
-       * won't change between two invocations (one - to get the
-       * buffer size, the other - to fill the buffer).
-       * Re-try up to 5 times in case the required buffer size
-       * doesn't match.
-       */
-      for (tries = 5; tries > 0; tries--)
-        {
-          DWORD buffer_size;
-          DWORD buffer_size2;
-          DWORD error;
-
-          buffer_size = GetFinalPathNameByHandleW (self->file_handle, NULL, 0, 0);
-
-          if (buffer_size == 0)
-            {
-              DWORD error = GetLastError ();
-              return __HRESULT_FROM_WIN32 (error);
-            }
-
-          buffer = CoTaskMemAlloc (buffer_size);
-          buffer[buffer_size - 1] = 0;
-          buffer_size2 = GetFinalPathNameByHandleW (self->file_handle, buffer, buffer_size, 0);
-
-          if (buffer_size2 < buffer_size)
-            break;
-
-          error = GetLastError ();
-          CoTaskMemFree (buffer);
-          if (buffer_size2 == 0)
-            return __HRESULT_FROM_WIN32 (error);
-        }
-
-      if (tries == 0)
-        return __HRESULT_FROM_WIN32 (ERROR_BAD_LENGTH);
-
-      output_stat->pwcsName = buffer;
-    }
-  else
-    output_stat->pwcsName = NULL;
-
-  return S_OK;
-}
-
-static HRESULT STDMETHODCALLTYPE
-_file_sync_stream_clone (IStream  *self_ptr,
-                         IStream **output_clone_ptr)
-{
-  return E_NOTIMPL;
-}
-
-static IStreamVtbl _file_sync_stream_vtbl = {
-  _file_sync_stream_query_interface,
-  _file_sync_stream_add_ref,
-  _file_sync_stream_release,
-  _file_sync_stream_read,
-  _file_sync_stream_write,
-  _file_sync_stream_seek,
-  _file_sync_stream_set_size,
-  _file_sync_stream_copy_to,
-  _file_sync_stream_commit,
-  _file_sync_stream_revert,
-  _file_sync_stream_lock_region,
-  _file_sync_stream_unlock_region,
-  _file_sync_stream_stat,
-  _file_sync_stream_clone,
-};
-
-static void
-_file_sync_stream_free (GWin32FileSyncStream *self)
-{
-  if (self->owns_handle)
-    CloseHandle (self->file_handle);
-
-  g_free (self);
-}
-
-/**
- * g_win32_file_sync_stream_new:
- * @handle: a Win32 HANDLE for a file.
- * @owns_handle: %TRUE if newly-created stream owns the handle
- *               (and closes it when destroyed)
- * @stgm_mode: a combination of [STGM constants](https://docs.microsoft.com/en-us/windows/win32/stg/stgm-constants)
- *             that specify the mode with which the stream
- *             is opened.
- * @output_hresult: (out) (optional): a HRESULT from the internal COM calls.
- *                                    Will be `S_OK` on success.
- *
- * Creates an IStream object backed by a HANDLE.
- *
- * @stgm_mode should match the mode of the @handle, otherwise the stream might
- * attempt to perform operations that the @handle does not allow. The implementation
- * itself ignores these flags completely, they are only used to report
- * the mode of the stream to third parties.
- *
- * The stream only does synchronous access and will never return `E_PENDING` on I/O.
- *
- * The returned stream object should be treated just like any other
- * COM object, and released via `IUnknown_Release()`.
- * its elements have been unreffed with g_object_unref().
- *
- * Returns: (nullable) (transfer full): a new IStream object on success, %NULL on failure.
- **/
-IStream *
-g_win32_file_sync_stream_new (HANDLE    file_handle,
-                              gboolean  owns_handle,
-                              DWORD     stgm_mode,
-                              HRESULT  *output_hresult)
-{
-  GWin32FileSyncStream *new_stream;
-  IStream *result;
-  HRESULT hr;
-
-  new_stream = g_new0 (GWin32FileSyncStream, 1);
-  new_stream->self.lpVtbl = &_file_sync_stream_vtbl;
-
-  hr = IUnknown_QueryInterface ((IUnknown *) new_stream, &IID_IStream, (void **) &result);
-  if (!SUCCEEDED (hr))
-    {
-      g_free (new_stream);
-
-      if (output_hresult)
-        *output_hresult = hr;
-
-      return NULL;
-    }
-
-  new_stream->stgm_mode = stgm_mode;
-  new_stream->file_handle = file_handle;
-  new_stream->owns_handle = owns_handle;
-
-  if (output_hresult)
-    *output_hresult = S_OK;
-
-  return result;
-}
diff --git a/gio/gwin32file-sync-stream.h b/gio/gwin32file-sync-stream.h
deleted file mode 100755
index 1111111..0000000
--- a/gio/gwin32file-sync-stream.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/* GIO - GLib Input, Output and Streaming Library
- *
- * Copyright (C) 2020 Руслан Ижбулатов <lrn1986@gmail.com>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General
- * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.
- *
- */
-#ifndef __G_WIN32_FILE_SYNC_STREAM_H__
-#define __G_WIN32_FILE_SYNC_STREAM_H__
-
-#include <gio/gio.h>
-
-#ifdef G_PLATFORM_WIN32
-
-typedef struct _GWin32FileSyncStream GWin32FileSyncStream;
-
-struct _GWin32FileSyncStream
-{
-  IStream  self;
-  ULONG    ref_count;
-  HANDLE   file_handle;
-  gboolean owns_handle;
-  DWORD    stgm_mode;
-};
-
-IStream *g_win32_file_sync_stream_new (HANDLE    file_handle,
-                                       gboolean  owns_handle,
-                                       DWORD     stgm_mode,
-                                       HRESULT  *output_hresult);
-
-#endif /* G_PLATFORM_WIN32 */
-
-#endif /* __G_WIN32_FILE_SYNC_STREAM_H__ */
\ No newline at end of file
diff --git a/gio/meson.build b/gio/meson.build
index 1111111..2222222 100644
--- a/gio/meson.build
+++ b/gio/meson.build
@@ -428,7 +428,6 @@ else
     'gwin32volumemonitor.c',
     'gwin32inputstream.c',
     'gwin32outputstream.c',
-    'gwin32file-sync-stream.c',
     'gwin32networkmonitor.c',
     'gwin32networkmonitor.h',
     'gwin32notificationbackend.c',

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 11:16:59 +0100
Subject: [PATCH 12/14] Revert "glib/gtimezone.c: Use RegLoadMUIStringW() to
 query Std/Dlt strings"

This reverts commit 2e5d3aa91114ebc930393b74ff5a1af474c745bb.

diff --git a/glib/gtimezone.c b/glib/gtimezone.c
index 1111111..2222222 100644
--- a/glib/gtimezone.c
+++ b/glib/gtimezone.c
@@ -932,14 +932,10 @@ rules_from_windows_time_zone (const gchar   *identifier,
   DWORD size;
   guint rules_num = 0;
   RegTZI regtzi = { 0 }, regtzi_prev;
-  WCHAR winsyspath[MAX_PATH];
   gunichar2 *subkey_w, *subkey_dynamic_w;
 
   subkey_dynamic_w = NULL;
 
-  if (GetSystemDirectoryW (winsyspath, MAX_PATH) == 0)
-    return 0;
-
   g_assert (rules != NULL);
 
   *rules = NULL;
@@ -965,33 +961,18 @@ rules_from_windows_time_zone (const gchar   *identifier,
 
   if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey_w, 0,
                      KEY_QUERY_VALUE, &key) != ERROR_SUCCESS)
-      goto utf16_conv_failed;
+      return 0;
 
   size = sizeof tzi.StandardName;
-
-  /* use RegLoadMUIStringW() to query MUI_Std from the registry if possible, otherwise
-     fallback to querying Std */
-  if (RegLoadMUIStringW (key, L"MUI_Std", tzi.StandardName,
-                         size, &size, 0, winsyspath) != ERROR_SUCCESS)
-    {
-      size = sizeof tzi.StandardName;
-      if (RegQueryValueExW (key, L"Std", NULL, NULL,
-                            (LPBYTE)&(tzi.StandardName), &size) != ERROR_SUCCESS)
-        goto registry_failed;
-    }
+  if (RegQueryValueExW (key, L"Std", NULL, NULL,
+                        (LPBYTE)&(tzi.StandardName), &size) != ERROR_SUCCESS)
+    goto registry_failed;
 
   size = sizeof tzi.DaylightName;
 
-  /* use RegLoadMUIStringW() to query MUI_Dlt from the registry if possible, otherwise
-     fallback to querying Dlt */
-  if (RegLoadMUIStringW (key, L"MUI_Dlt", tzi.DaylightName,
-                         size, &size, 0, winsyspath) != ERROR_SUCCESS)
-    {
-      size = sizeof tzi.DaylightName;
-      if (RegQueryValueExW (key, L"Dlt", NULL, NULL,
-                            (LPBYTE)&(tzi.DaylightName), &size) != ERROR_SUCCESS)
-        goto registry_failed;
-    }
+  if (RegQueryValueExW (key, L"Dlt", NULL, NULL,
+                        (LPBYTE)&(tzi.DaylightName), &size) != ERROR_SUCCESS)
+    goto registry_failed;
 
   RegCloseKey (key);
   if (RegOpenKeyExW (HKEY_LOCAL_MACHINE, subkey_dynamic_w, 0,

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 11:19:24 +0100
Subject: [PATCH 11/14] Revert "win32: Remove all remaining WinXP compat code"

This reverts commit a2aa91ae5d263eb00e440680262155b755077114.

diff --git a/gio/ginetaddress.c b/gio/ginetaddress.c
index 1111111..2222222 100644
--- a/gio/ginetaddress.c
+++ b/gio/ginetaddress.c
@@ -384,6 +384,98 @@ g_inet_address_init (GInetAddress *address)
   address->priv = g_inet_address_get_instance_private (address);
 }
 
+/* These are provided so that we can use inet_pton() and inet_ntop() on Windows
+ * if they are available (i.e. Vista and later), and use the existing code path
+ * on Windows XP/Server 2003.  We can drop this portion when we drop support for
+ * XP/Server 2003.
+ */
+#if defined(G_OS_WIN32) && _WIN32_WINNT < 0x0600
+static gint
+inet_pton (gint family,
+           const gchar *addr_string,
+           gpointer addr)
+{
+  /* For Vista/Server 2008 and later, there is native inet_pton() in Winsock2 */
+  if (ws2funcs.pInetPton != NULL)
+    return ws2funcs.pInetPton (family, addr_string, addr);
+  else
+    {
+      /* Fallback codepath for XP/Server 2003 */
+      struct sockaddr_storage sa;
+      struct sockaddr_in *sin = (struct sockaddr_in *)&sa;
+      struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&sa;
+      gint len = sizeof (sa);
+
+      if (family != AF_INET && family != AF_INET6)
+        {
+          WSASetLastError (WSAEAFNOSUPPORT);
+          return -1;
+        }
+
+      /* WSAStringToAddress() will accept various not-an-IP-address
+       * strings like "127.0.0.1:80", "[1234::5678]:80", "127.1", etc.
+       */
+      if (!g_hostname_is_ip_address (addr_string))
+        return 0;
+
+      if (WSAStringToAddress ((LPTSTR) addr_string, family, NULL, (LPSOCKADDR) &sa, &len) != 0)
+        return 0;
+
+      if (family == AF_INET)
+        *(IN_ADDR *)addr = sin->sin_addr;
+      else
+        *(IN6_ADDR *)addr = sin6->sin6_addr;
+
+      return 1;
+    }
+}
+
+static const gchar *
+inet_ntop (gint family,
+           const gpointer addr,
+           gchar *addr_str,
+           socklen_t size)
+{
+  /* On Vista/Server 2008 and later, there is native inet_ntop() in Winsock2 */
+  if (ws2funcs.pInetNtop != NULL)
+    return ws2funcs.pInetNtop (family, addr, addr_str, size);
+  else
+    {
+      /* Fallback codepath for XP/Server 2003 */
+      DWORD buflen = size, addrlen;
+      struct sockaddr_storage sa;
+      struct sockaddr_in *sin = (struct sockaddr_in *)&sa;
+      struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&sa;
+
+      memset (&sa, 0, sizeof (sa));
+      sa.ss_family = family;
+      if (sa.ss_family == AF_INET)
+        {
+          struct in_addr *addrv4 = (struct in_addr *) addr;
+
+          addrlen = sizeof (*sin);
+          memcpy (&sin->sin_addr, addrv4, sizeof (sin->sin_addr));
+        }
+      else if (sa.ss_family == AF_INET6)
+        {
+          struct in6_addr *addrv6 = (struct in6_addr *) addr;
+
+          addrlen = sizeof (*sin6);
+          memcpy (&sin6->sin6_addr, addrv6, sizeof (sin6->sin6_addr));
+        }
+      else
+        {
+          WSASetLastError (WSAEAFNOSUPPORT);
+          return NULL;
+        }
+      if (WSAAddressToString ((LPSOCKADDR) &sa, addrlen, NULL, addr_str, &buflen) == 0)
+        return addr_str;
+      else
+        return NULL;
+    }
+}
+#endif
+
 /**
  * g_inet_address_new_from_string:
  * @string: a string representation of an IP address
diff --git a/glib/gmessages.c b/glib/gmessages.c
index 1111111..2222222 100644
--- a/glib/gmessages.c
+++ b/glib/gmessages.c
@@ -213,6 +213,47 @@
 #define ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
 #endif
 
+/* XXX: Remove once XP support really dropped */
+#if _WIN32_WINNT < 0x0600
+
+typedef enum _FILE_INFO_BY_HANDLE_CLASS
+{
+  FileBasicInfo                   = 0,
+  FileStandardInfo                = 1,
+  FileNameInfo                    = 2,
+  FileRenameInfo                  = 3,
+  FileDispositionInfo             = 4,
+  FileAllocationInfo              = 5,
+  FileEndOfFileInfo               = 6,
+  FileStreamInfo                  = 7,
+  FileCompressionInfo             = 8,
+  FileAttributeTagInfo            = 9,
+  FileIdBothDirectoryInfo         = 10,
+  FileIdBothDirectoryRestartInfo  = 11,
+  FileIoPriorityHintInfo          = 12,
+  FileRemoteProtocolInfo          = 13,
+  FileFullDirectoryInfo           = 14,
+  FileFullDirectoryRestartInfo    = 15,
+  FileStorageInfo                 = 16,
+  FileAlignmentInfo               = 17,
+  FileIdInfo                      = 18,
+  FileIdExtdDirectoryInfo         = 19,
+  FileIdExtdDirectoryRestartInfo  = 20,
+  MaximumFileInfoByHandlesClass
+} FILE_INFO_BY_HANDLE_CLASS;
+
+typedef struct _FILE_NAME_INFO
+{
+  DWORD FileNameLength;
+  WCHAR FileName[1];
+} FILE_NAME_INFO;
+
+typedef BOOL (WINAPI fGetFileInformationByHandleEx) (HANDLE,
+                                                     FILE_INFO_BY_HANDLE_CLASS,
+                                                     LPVOID,
+                                                     DWORD);
+#endif
+
 #if defined (_MSC_VER) && (_MSC_VER >=1400)
 /* This is ugly, but we need it for isatty() in case we have bad fd's,
  * otherwise Windows will abort() the program on msvcrt80.dll and later
@@ -1546,13 +1587,34 @@ win32_is_pipe_tty (int fd)
   wchar_t *name = NULL;
   gint length;
 
+  /* XXX: Remove once XP support really dropped */
+#if _WIN32_WINNT < 0x0600
+  HANDLE h_kerneldll = NULL;
+  fGetFileInformationByHandleEx *GetFileInformationByHandleEx;
+#endif
+
   h_fd = (HANDLE) _get_osfhandle (fd);
 
   if (h_fd == INVALID_HANDLE_VALUE || GetFileType (h_fd) != FILE_TYPE_PIPE)
     goto done_query;
 
+  /* The following check is available on Vista or later, so on XP, no color support */
   /* mintty uses a pipe, in the form of \{cygwin|msys}-xxxxxxxxxxxxxxxx-ptyN-{from|to}-master */
 
+  /* XXX: Remove once XP support really dropped */
+#if _WIN32_WINNT < 0x0600
+  h_kerneldll = LoadLibraryW (L"kernel32.dll");
+
+  if (h_kerneldll == NULL)
+    goto done_query;
+
+  GetFileInformationByHandleEx =
+    (fGetFileInformationByHandleEx *) GetProcAddress (h_kerneldll, "GetFileInformationByHandleEx");
+
+  if (GetFileInformationByHandleEx == NULL)
+    goto done_query;
+#endif
+
   info = g_try_malloc (info_size);
 
   if (info == NULL ||
@@ -1600,6 +1662,12 @@ done_query:
   if (info != NULL)
     g_free (info);
 
+  /* XXX: Remove once XP support really dropped */
+#if _WIN32_WINNT < 0x0600
+  if (h_kerneldll != NULL)
+    FreeLibrary (h_kerneldll);
+#endif
+
   return result;
 }
 #endif

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 11:19:41 +0100
Subject: [PATCH 11/14] Revert "gthread-win32: Remove WinXP compat code"

This reverts commit cce29579389e892eb263d8507a71b3b3ca7433bb.

diff --git a/glib/gthread-win32.c b/glib/gthread-win32.c
index 1111111..2222222 100644
--- a/glib/gthread-win32.c
+++ b/glib/gthread-win32.c
@@ -73,36 +73,81 @@ g_thread_abort (gint         status,
  * of these new types is that they can be statically initialised to
  * zero.  That means that they are completely ABI compatible with our
  * GMutex and GCond APIs.
+ *
+ * Unfortunately, Windows XP lacks these facilities and GLib still
+ * needs to support Windows XP.  Our approach here is as follows:
+ *
+ *   - avoid depending on structure declarations at compile-time by
+ *     declaring our own GMutex and GCond strutures to be
+ *     ABI-compatible with SRWLock and CONDITION_VARIABLE and using
+ *     those instead
+ *
+ *   - avoid a hard dependency on the symbols used to manipulate these
+ *     structures by doing a dynamic lookup of those symbols at
+ *     runtime
+ *
+ *   - if the symbols are not available, emulate them using other
+ *     primatives
+ *
+ * Using this approach also allows us to easily build a GLib that lacks
+ * support for Windows XP or to remove this code entirely when XP is no
+ * longer supported (end of line is currently April 8, 2014).
  */
+typedef struct
+{
+  void     (__stdcall * CallThisOnThreadExit)        (void);              /* fake */
+
+  void     (__stdcall * InitializeSRWLock)           (gpointer lock);
+  void     (__stdcall * DeleteSRWLock)               (gpointer lock);     /* fake */
+  void     (__stdcall * AcquireSRWLockExclusive)     (gpointer lock);
+  BOOLEAN  (__stdcall * TryAcquireSRWLockExclusive)  (gpointer lock);
+  void     (__stdcall * ReleaseSRWLockExclusive)     (gpointer lock);
+  void     (__stdcall * AcquireSRWLockShared)        (gpointer lock);
+  BOOLEAN  (__stdcall * TryAcquireSRWLockShared)     (gpointer lock);
+  void     (__stdcall * ReleaseSRWLockShared)        (gpointer lock);
+
+  void     (__stdcall * InitializeConditionVariable) (gpointer cond);
+  void     (__stdcall * DeleteConditionVariable)     (gpointer cond);     /* fake */
+  BOOL     (__stdcall * SleepConditionVariableSRW)   (gpointer cond,
+                                                      gpointer lock,
+                                                      DWORD    timeout,
+                                                      ULONG    flags);
+  void     (__stdcall * WakeAllConditionVariable)    (gpointer cond);
+  void     (__stdcall * WakeConditionVariable)       (gpointer cond);
+} GThreadImplVtable;
+
+static GThreadImplVtable g_thread_impl_vtable;
 
 /* {{{1 GMutex */
 void
 g_mutex_init (GMutex *mutex)
 {
-  InitializeSRWLock ((gpointer) mutex);
+  g_thread_impl_vtable.InitializeSRWLock (mutex);
 }
 
 void
 g_mutex_clear (GMutex *mutex)
 {
+  if (g_thread_impl_vtable.DeleteSRWLock != NULL)
+    g_thread_impl_vtable.DeleteSRWLock (mutex);
 }
 
 void
 g_mutex_lock (GMutex *mutex)
 {
-  AcquireSRWLockExclusive ((gpointer) mutex);
+  g_thread_impl_vtable.AcquireSRWLockExclusive (mutex);
 }
 
 gboolean
 g_mutex_trylock (GMutex *mutex)
 {
-  return TryAcquireSRWLockExclusive ((gpointer) mutex);
+  return g_thread_impl_vtable.TryAcquireSRWLockExclusive (mutex);
 }
 
 void
 g_mutex_unlock (GMutex *mutex)
 {
-  ReleaseSRWLockExclusive ((gpointer) mutex);
+  g_thread_impl_vtable.ReleaseSRWLockExclusive (mutex);
 }
 
 /* {{{1 GRecMutex */
@@ -176,79 +221,83 @@ g_rec_mutex_trylock (GRecMutex *mutex)
 void
 g_rw_lock_init (GRWLock *lock)
 {
-  InitializeSRWLock ((gpointer) lock);
+  g_thread_impl_vtable.InitializeSRWLock (lock);
 }
 
 void
 g_rw_lock_clear (GRWLock *lock)
 {
+  if (g_thread_impl_vtable.DeleteSRWLock != NULL)
+    g_thread_impl_vtable.DeleteSRWLock (lock);
 }
 
 void
 g_rw_lock_writer_lock (GRWLock *lock)
 {
-  AcquireSRWLockExclusive ((gpointer) lock);
+  g_thread_impl_vtable.AcquireSRWLockExclusive (lock);
 }
 
 gboolean
 g_rw_lock_writer_trylock (GRWLock *lock)
 {
-  return TryAcquireSRWLockExclusive ((gpointer) lock);
+  return g_thread_impl_vtable.TryAcquireSRWLockExclusive (lock);
 }
 
 void
 g_rw_lock_writer_unlock (GRWLock *lock)
 {
-  ReleaseSRWLockExclusive ((gpointer) lock);
+  g_thread_impl_vtable.ReleaseSRWLockExclusive (lock);
 }
 
 void
 g_rw_lock_reader_lock (GRWLock *lock)
 {
-  AcquireSRWLockShared ((gpointer) lock);
+  g_thread_impl_vtable.AcquireSRWLockShared (lock);
 }
 
 gboolean
 g_rw_lock_reader_trylock (GRWLock *lock)
 {
-  return TryAcquireSRWLockShared ((gpointer) lock);
+  return g_thread_impl_vtable.TryAcquireSRWLockShared (lock);
 }
 
 void
 g_rw_lock_reader_unlock (GRWLock *lock)
 {
-  ReleaseSRWLockShared ((gpointer) lock);
+  g_thread_impl_vtable.ReleaseSRWLockShared (lock);
 }
 
 /* {{{1 GCond */
 void
 g_cond_init (GCond *cond)
 {
-  InitializeConditionVariable ((gpointer) cond);
+  g_thread_impl_vtable.InitializeConditionVariable (cond);
 }
 
 void
 g_cond_clear (GCond *cond)
 {
+  if (g_thread_impl_vtable.DeleteConditionVariable)
+    g_thread_impl_vtable.DeleteConditionVariable (cond);
 }
 
 void
 g_cond_signal (GCond *cond)
 {
-  WakeConditionVariable ((gpointer) cond);
+  g_thread_impl_vtable.WakeConditionVariable (cond);
 }
 
 void
 g_cond_broadcast (GCond *cond)
 {
-  WakeAllConditionVariable ((gpointer) cond);
+  g_thread_impl_vtable.WakeAllConditionVariable (cond);
 }
 
 void
 g_cond_wait (GCond  *cond,
              GMutex *entered_mutex)
 {
-  SleepConditionVariableSRW ((gpointer) cond, (gpointer) entered_mutex, INFINITE, 0);
+  g_thread_impl_vtable.SleepConditionVariableSRW (cond, entered_mutex, INFINITE, 0);
 }
 
 gboolean
@@ -277,7 +326,7 @@ g_cond_wait_until (GCond  *cond,
       if (span_millis >= INFINITE)
         span_millis = INFINITE - 1;
 
-      signalled = SleepConditionVariableSRW ((gpointer) cond, (gpointer) entered_mutex, span_millis, 0);
+      signalled = g_thread_impl_vtable.SleepConditionVariableSRW (cond, entered_mutex, span_millis, 0);
       if (signalled)
         break;
 
@@ -687,11 +736,491 @@ g_system_thread_set_name (const gchar *name)
     SetThreadName ((DWORD) -1, name);
 }
 
+/* {{{1 SRWLock and CONDITION_VARIABLE emulation (for Windows XP) */
+
+static CRITICAL_SECTION g_thread_xp_lock;
+static DWORD            g_thread_xp_waiter_tls;
+
+/* {{{2 GThreadWaiter utility class for CONDITION_VARIABLE emulation */
+typedef struct _GThreadXpWaiter GThreadXpWaiter;
+struct _GThreadXpWaiter
+{
+  HANDLE                     event;
+  volatile GThreadXpWaiter  *next;
+  volatile GThreadXpWaiter **my_owner;
+};
+
+static GThreadXpWaiter *
+g_thread_xp_waiter_get (void)
+{
+  GThreadXpWaiter *waiter;
+
+  waiter = TlsGetValue (g_thread_xp_waiter_tls);
+
+  if G_UNLIKELY (waiter == NULL)
+    {
+      waiter = malloc (sizeof (GThreadXpWaiter));
+      if (waiter == NULL)
+        g_thread_abort (GetLastError (), "malloc");
+      waiter->event = CreateEvent (0, FALSE, FALSE, NULL);
+      if (waiter->event == NULL)
+        g_thread_abort (GetLastError (), "CreateEvent");
+      waiter->my_owner = NULL;
+
+      TlsSetValue (g_thread_xp_waiter_tls, waiter);
+    }
+
+  return waiter;
+}
+
+static void __stdcall
+g_thread_xp_CallThisOnThreadExit (void)
+{
+  GThreadXpWaiter *waiter;
+
+  waiter = TlsGetValue (g_thread_xp_waiter_tls);
+
+  if (waiter != NULL)
+    {
+      TlsSetValue (g_thread_xp_waiter_tls, NULL);
+      CloseHandle (waiter->event);
+      free (waiter);
+    }
+}
+
+/* {{{2 SRWLock emulation */
+typedef struct
+{
+  CRITICAL_SECTION  writer_lock;
+  gboolean          ever_shared;    /* protected by writer_lock */
+  gboolean          writer_locked;  /* protected by writer_lock */
+
+  /* below is only ever touched if ever_shared becomes true */
+  CRITICAL_SECTION  atomicity;
+  GThreadXpWaiter  *queued_writer; /* protected by atomicity lock */
+  gint              num_readers;   /* protected by atomicity lock */
+} GThreadSRWLock;
+
+static void __stdcall
+g_thread_xp_InitializeSRWLock (gpointer mutex)
+{
+  *(GThreadSRWLock * volatile *) mutex = NULL;
+}
+
+static void __stdcall
+g_thread_xp_DeleteSRWLock (gpointer mutex)
+{
+  GThreadSRWLock *lock = *(GThreadSRWLock * volatile *) mutex;
+
+  if (lock)
+    {
+      if (lock->ever_shared)
+        DeleteCriticalSection (&lock->atomicity);
+
+      DeleteCriticalSection (&lock->writer_lock);
+      free (lock);
+    }
+}
+
+static GThreadSRWLock * __stdcall
+g_thread_xp_get_srwlock (GThreadSRWLock * volatile *lock)
+{
+  GThreadSRWLock *result;
+
+  /* It looks like we're missing some barriers here, but this code only
+   * ever runs on Windows XP, which in turn only ever runs on hardware
+   * with a relatively rigid memory model.  The 'volatile' will take
+   * care of the compiler.
+   */
+  result = *lock;
+
+  if G_UNLIKELY (result == NULL)
+    {
+      EnterCriticalSection (&g_thread_xp_lock);
+
+      /* Check again */
+      result = *lock;
+      if (result == NULL)
+        {
+          result = malloc (sizeof (GThreadSRWLock));
+
+          if (result == NULL)
+            g_thread_abort (errno, "malloc");
+
+          InitializeCriticalSection (&result->writer_lock);
+          result->writer_locked = FALSE;
+          result->ever_shared = FALSE;
+          *lock = result;
+        }
+
+      LeaveCriticalSection (&g_thread_xp_lock);
+    }
+
+  return result;
+}
+
+static void __stdcall
+g_thread_xp_AcquireSRWLockExclusive (gpointer mutex)
+{
+  GThreadSRWLock *lock = g_thread_xp_get_srwlock (mutex);
+
+  EnterCriticalSection (&lock->writer_lock);
+
+  /* CRITICAL_SECTION is reentrant, but SRWLock is not.
+   * Detect the deadlock that would occur on later Windows version.
+   */
+  g_assert (!lock->writer_locked);
+  lock->writer_locked = TRUE;
+
+  if (lock->ever_shared)
+    {
+      GThreadXpWaiter *waiter = NULL;
+
+      EnterCriticalSection (&lock->atomicity);
+      if (lock->num_readers > 0)
+        lock->queued_writer = waiter = g_thread_xp_waiter_get ();
+      LeaveCriticalSection (&lock->atomicity);
+
+      if (waiter != NULL)
+        WaitForSingleObject (waiter->event, INFINITE);
+
+      lock->queued_writer = NULL;
+    }
+}
+
+static BOOLEAN __stdcall
+g_thread_xp_TryAcquireSRWLockExclusive (gpointer mutex)
+{
+  GThreadSRWLock *lock = g_thread_xp_get_srwlock (mutex);
+
+  if (!TryEnterCriticalSection (&lock->writer_lock))
+    return FALSE;
+
+  /* CRITICAL_SECTION is reentrant, but SRWLock is not.
+   * Ensure that this properly returns FALSE (as SRWLock would).
+   */
+  if G_UNLIKELY (lock->writer_locked)
+    {
+      LeaveCriticalSection (&lock->writer_lock);
+      return FALSE;
+    }
+
+  lock->writer_locked = TRUE;
+
+  if (lock->ever_shared)
+    {
+      gboolean available;
+
+      EnterCriticalSection (&lock->atomicity);
+      available = lock->num_readers == 0;
+      LeaveCriticalSection (&lock->atomicity);
+
+      if (!available)
+        {
+          LeaveCriticalSection (&lock->writer_lock);
+          return FALSE;
+        }
+    }
+
+  return TRUE;
+}
+
+static void __stdcall
+g_thread_xp_ReleaseSRWLockExclusive (gpointer mutex)
+{
+  GThreadSRWLock *lock = *(GThreadSRWLock * volatile *) mutex;
+
+  lock->writer_locked = FALSE;
+
+  /* We need this until we fix some weird parts of GLib that try to
+   * unlock freshly-allocated mutexes.
+   */
+  if (lock != NULL)
+    LeaveCriticalSection (&lock->writer_lock);
+}
+
+static void
+g_thread_xp_srwlock_become_reader (GThreadSRWLock *lock)
+{
+  if G_UNLIKELY (!lock->ever_shared)
+    {
+      InitializeCriticalSection (&lock->atomicity);
+      lock->queued_writer = NULL;
+      lock->num_readers = 0;
+
+      lock->ever_shared = TRUE;
+    }
+
+  EnterCriticalSection (&lock->atomicity);
+  lock->num_readers++;
+  LeaveCriticalSection (&lock->atomicity);
+}
+
+static void __stdcall
+g_thread_xp_AcquireSRWLockShared (gpointer mutex)
+{
+  GThreadSRWLock *lock = g_thread_xp_get_srwlock (mutex);
+
+  EnterCriticalSection (&lock->writer_lock);
+
+  /* See g_thread_xp_AcquireSRWLockExclusive */
+  g_assert (!lock->writer_locked);
+
+  g_thread_xp_srwlock_become_reader (lock);
+
+  LeaveCriticalSection (&lock->writer_lock);
+}
+
+static BOOLEAN __stdcall
+g_thread_xp_TryAcquireSRWLockShared (gpointer mutex)
+{
+  GThreadSRWLock *lock = g_thread_xp_get_srwlock (mutex);
+
+  if (!TryEnterCriticalSection (&lock->writer_lock))
+    return FALSE;
+
+  /* See g_thread_xp_AcquireSRWLockExclusive */
+  if G_UNLIKELY (lock->writer_locked)
+    {
+      LeaveCriticalSection (&lock->writer_lock);
+      return FALSE;
+    }
+
+  g_thread_xp_srwlock_become_reader (lock);
+
+  LeaveCriticalSection (&lock->writer_lock);
+
+  return TRUE;
+}
+
+static void __stdcall
+g_thread_xp_ReleaseSRWLockShared (gpointer mutex)
+{
+  GThreadSRWLock *lock = g_thread_xp_get_srwlock (mutex);
+
+  EnterCriticalSection (&lock->atomicity);
+
+  lock->num_readers--;
+
+  if (lock->num_readers == 0 && lock->queued_writer)
+    SetEvent (lock->queued_writer->event);
+
+  LeaveCriticalSection (&lock->atomicity);
+}
+
+/* {{{2 CONDITION_VARIABLE emulation */
+typedef struct
+{
+  volatile GThreadXpWaiter  *first;
+  volatile GThreadXpWaiter **last_ptr;
+} GThreadXpCONDITION_VARIABLE;
+
+static void __stdcall
+g_thread_xp_InitializeConditionVariable (gpointer cond)
+{
+  *(GThreadXpCONDITION_VARIABLE * volatile *) cond = NULL;
+}
+
+static void __stdcall
+g_thread_xp_DeleteConditionVariable (gpointer cond)
+{
+  GThreadXpCONDITION_VARIABLE *cv = *(GThreadXpCONDITION_VARIABLE * volatile *) cond;
+
+  if (cv)
+    free (cv);
+}
+
+static GThreadXpCONDITION_VARIABLE * __stdcall
+g_thread_xp_get_condition_variable (GThreadXpCONDITION_VARIABLE * volatile *cond)
+{
+  GThreadXpCONDITION_VARIABLE *result;
+
+  /* It looks like we're missing some barriers here, but this code only
+   * ever runs on Windows XP, which in turn only ever runs on hardware
+   * with a relatively rigid memory model.  The 'volatile' will take
+   * care of the compiler.
+   */
+  result = *cond;
+
+  if G_UNLIKELY (result == NULL)
+    {
+      result = malloc (sizeof (GThreadXpCONDITION_VARIABLE));
+
+      if (result == NULL)
+        g_thread_abort (errno, "malloc");
+
+      result->first = NULL;
+      result->last_ptr = &result->first;
+
+      if (InterlockedCompareExchangePointer (cond, result, NULL) != NULL)
+        {
+          free (result);
+          result = *cond;
+        }
+    }
+
+  return result;
+}
+
+static BOOL __stdcall
+g_thread_xp_SleepConditionVariableSRW (gpointer cond,
+                                       gpointer mutex,
+                                       DWORD    timeout,
+                                       ULONG    flags)
+{
+  GThreadXpCONDITION_VARIABLE *cv = g_thread_xp_get_condition_variable (cond);
+  GThreadXpWaiter *waiter = g_thread_xp_waiter_get ();
+  DWORD status;
+
+  waiter->next = NULL;
+
+  EnterCriticalSection (&g_thread_xp_lock);
+  waiter->my_owner = cv->last_ptr;
+  *cv->last_ptr = waiter;
+  cv->last_ptr = &waiter->next;
+  LeaveCriticalSection (&g_thread_xp_lock);
+
+  g_mutex_unlock (mutex);
+  status = WaitForSingleObject (waiter->event, timeout);
+
+  if (status != WAIT_TIMEOUT && status != WAIT_OBJECT_0)
+    g_thread_abort (GetLastError (), "WaitForSingleObject");
+  g_mutex_lock (mutex);
+
+  if (status == WAIT_TIMEOUT)
+    {
+      EnterCriticalSection (&g_thread_xp_lock);
+      if (waiter->my_owner)
+        {
+          if (waiter->next)
+            waiter->next->my_owner = waiter->my_owner;
+          else
+            cv->last_ptr = waiter->my_owner;
+          *waiter->my_owner = waiter->next;
+          waiter->my_owner = NULL;
+        }
+      LeaveCriticalSection (&g_thread_xp_lock);
+    }
+
+  return status == WAIT_OBJECT_0;
+}
+
+static void __stdcall
+g_thread_xp_WakeConditionVariable (gpointer cond)
+{
+  GThreadXpCONDITION_VARIABLE *cv = g_thread_xp_get_condition_variable (cond);
+  volatile GThreadXpWaiter *waiter;
+
+  EnterCriticalSection (&g_thread_xp_lock);
+
+  waiter = cv->first;
+  if (waiter != NULL)
+    {
+      waiter->my_owner = NULL;
+      cv->first = waiter->next;
+      if (cv->first != NULL)
+        cv->first->my_owner = &cv->first;
+      else
+        cv->last_ptr = &cv->first;
+    }
+
+  if (waiter != NULL)
+    SetEvent (waiter->event);
+
+  LeaveCriticalSection (&g_thread_xp_lock);
+}
+
+static void __stdcall
+g_thread_xp_WakeAllConditionVariable (gpointer cond)
+{
+  GThreadXpCONDITION_VARIABLE *cv = g_thread_xp_get_condition_variable (cond);
+  volatile GThreadXpWaiter *waiter;
+
+  EnterCriticalSection (&g_thread_xp_lock);
+
+  waiter = cv->first;
+  cv->first = NULL;
+  cv->last_ptr = &cv->first;
+
+  while (waiter != NULL)
+    {
+      volatile GThreadXpWaiter *next;
+
+      next = waiter->next;
+      SetEvent (waiter->event);
+      waiter->my_owner = NULL;
+      waiter = next;
+    }
+
+  LeaveCriticalSection (&g_thread_xp_lock);
+}
+
+/* {{{2 XP Setup */
+static void
+g_thread_xp_init (void)
+{
+  static const GThreadImplVtable g_thread_xp_impl_vtable = {
+    g_thread_xp_CallThisOnThreadExit,
+    g_thread_xp_InitializeSRWLock,
+    g_thread_xp_DeleteSRWLock,
+    g_thread_xp_AcquireSRWLockExclusive,
+    g_thread_xp_TryAcquireSRWLockExclusive,
+    g_thread_xp_ReleaseSRWLockExclusive,
+    g_thread_xp_AcquireSRWLockShared,
+    g_thread_xp_TryAcquireSRWLockShared,
+    g_thread_xp_ReleaseSRWLockShared,
+    g_thread_xp_InitializeConditionVariable,
+    g_thread_xp_DeleteConditionVariable,
+    g_thread_xp_SleepConditionVariableSRW,
+    g_thread_xp_WakeAllConditionVariable,
+    g_thread_xp_WakeConditionVariable
+  };
+
+  InitializeCriticalSection (&g_thread_xp_lock);
+  g_thread_xp_waiter_tls = TlsAlloc ();
+
+  g_thread_impl_vtable = g_thread_xp_impl_vtable;
+}
+
 /* {{{1 Epilogue */
 
+static gboolean
+g_thread_lookup_native_funcs (void)
+{
+  GThreadImplVtable native_vtable = { 0, };
+  HMODULE kernel32;
+
+  kernel32 = GetModuleHandle ("KERNEL32.DLL");
+
+  if (kernel32 == NULL)
+    return FALSE;
+
+#define GET_FUNC(name) if ((native_vtable.name = (void *) GetProcAddress (kernel32, #name)) == NULL) return FALSE
+  GET_FUNC(InitializeSRWLock);
+  GET_FUNC(AcquireSRWLockExclusive);
+  GET_FUNC(TryAcquireSRWLockExclusive);
+  GET_FUNC(ReleaseSRWLockExclusive);
+  GET_FUNC(AcquireSRWLockShared);
+  GET_FUNC(TryAcquireSRWLockShared);
+  GET_FUNC(ReleaseSRWLockShared);
+
+  GET_FUNC(InitializeConditionVariable);
+  GET_FUNC(SleepConditionVariableSRW);
+  GET_FUNC(WakeAllConditionVariable);
+  GET_FUNC(WakeConditionVariable);
+#undef GET_FUNC
+
+  g_thread_impl_vtable = native_vtable;
+
+  return TRUE;
+}
+
 void
 g_thread_win32_init (void)
 {
+  if (!g_thread_lookup_native_funcs ())
+    g_thread_xp_init ();
+
   InitializeCriticalSection (&g_private_lock);
 
 #ifndef _MSC_VER
@@ -736,6 +1265,9 @@ g_thread_win32_thread_detach (void)
         }
     }
   while (dtors_called);
+
+  if (g_thread_impl_vtable.CallThisOnThreadExit)
+    g_thread_impl_vtable.CallThisOnThreadExit ();
 }
 
 void

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 13:52:35 +0100
Subject: [PATCH 13/14] Revert "GNetworkMonitorWindows: Add IPv4/IPv6 network
 monitor backend for windows"

This reverts commit f9aacf3952effff897ab42991b5ba9090de5d970.

diff --git a/gio/giomodule.c b/gio/giomodule.c
index 1111111..2222222 100644
--- a/gio/giomodule.c
+++ b/gio/giomodule.c
@@ -1106,7 +1106,6 @@ extern GType g_cocoa_notification_backend_get_type (void);
 extern GType g_win32_notification_backend_get_type (void);
 
 #include <windows.h>
-extern GType _g_win32_network_monitor_get_type (void);
 
 static HMODULE gio_dll = NULL;
 
@@ -1373,9 +1372,6 @@ _g_io_modules_ensure_loaded (void)
 #ifdef HAVE_NETLINK
       g_type_ensure (_g_network_monitor_netlink_get_type ());
       g_type_ensure (_g_network_monitor_nm_get_type ());
-#endif
-#ifdef G_OS_WIN32
-      g_type_ensure (_g_win32_network_monitor_get_type ());
 #endif
     }
 
diff --git a/gio/gwin32networkmonitor.c b/gio/gwin32networkmonitor.c
deleted file mode 100644
index 1111111..0000000
--- a/gio/gwin32networkmonitor.c
+++ /dev/null
@@ -1,339 +0,0 @@
-/* GIO - GLib Input, Output and Streaming Library
- *
- * Copyright 2014-2018 Jan-Michael Brummer <jan.brummer@tabos.org>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General
- * Public License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#include "config.h"
-
-#include <errno.h>
-
-#ifdef HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
-#include <winsock2.h>
-#include <ws2tcpip.h>
-#include <iphlpapi.h>
-#include <stdio.h>
-
-#include "gwin32networkmonitor.h"
-#include "ginetaddress.h"
-#include "ginetaddressmask.h"
-#include "ginitable.h"
-#include "giomodule-priv.h"
-#include "glibintl.h"
-#include "glib/gstdio.h"
-#include "gnetworkingprivate.h"
-#include "gsocket.h"
-#include "gnetworkmonitor.h"
-#include "gioerror.h"
-
-static GInitableIface *initable_parent_iface;
-static void g_win32_network_monitor_iface_init (GNetworkMonitorInterface *iface);
-static void g_win32_network_monitor_initable_iface_init (GInitableIface *iface);
-
-struct _GWin32NetworkMonitorPrivate
-{
-  gboolean initialized;
-  GError *init_error;
-  GMainContext *main_context;
-  GSource *route_change_source;
-  HANDLE handle;
-};
-
-#define g_win32_network_monitor_get_type _g_win32_network_monitor_get_type
-G_DEFINE_TYPE_WITH_CODE (GWin32NetworkMonitor, g_win32_network_monitor, G_TYPE_NETWORK_MONITOR_BASE,
-                         G_ADD_PRIVATE (GWin32NetworkMonitor)
-                         G_IMPLEMENT_INTERFACE (G_TYPE_NETWORK_MONITOR,
-                                                g_win32_network_monitor_iface_init)
-                         G_IMPLEMENT_INTERFACE (G_TYPE_INITABLE,
-                                                g_win32_network_monitor_initable_iface_init)
-                         _g_io_modules_ensure_extension_points_registered ();
-                         g_io_extension_point_implement (G_NETWORK_MONITOR_EXTENSION_POINT_NAME,
-                                                         g_define_type_id,
-                                                         "win32",
-                                                         20))
-
-static void
-g_win32_network_monitor_init (GWin32NetworkMonitor *win)
-{
-  win->priv = g_win32_network_monitor_get_instance_private (win);
-}
-
-static gboolean
-win_network_monitor_get_ip_info (IP_ADDRESS_PREFIX  prefix,
-                                 GSocketFamily     *family,
-                                 const guint8     **dest,
-                                 gsize             *len)
-{
-  switch (prefix.Prefix.si_family)
-    {
-      case AF_UNSPEC:
-        /* Fall-through: AF_UNSPEC deliveres both IPV4 and IPV6 infos, let`s stick with IPV4 here */
-      case AF_INET:
-        *family = G_SOCKET_FAMILY_IPV4;
-        *dest = (guint8 *) &prefix.Prefix.Ipv4.sin_addr;
-        *len = prefix.PrefixLength;
-        break;
-      case AF_INET6:
-        *family = G_SOCKET_FAMILY_IPV6;
-        *dest = (guint8 *) &prefix.Prefix.Ipv6.sin6_addr;
-        *len = prefix.PrefixLength;
-        break;
-      default:
-        return FALSE;
-    }
-
-  return TRUE;
-}
-
-static GInetAddressMask *
-get_network_mask (GSocketFamily  family,
-                  const guint8  *dest,
-                  gsize          len)
-{
-  GInetAddressMask *network;
-  GInetAddress *dest_addr;
-
-  if (dest != NULL)
-    dest_addr = g_inet_address_new_from_bytes (dest, family);
-  else
-    dest_addr = g_inet_address_new_any (family);
-
-  network = g_inet_address_mask_new (dest_addr, len, NULL);
-  g_object_unref (dest_addr);
-
-  return network;
-}
-
-static gboolean
-win_network_monitor_process_table (GWin32NetworkMonitor  *win,
-                                   GError                 **error)
-{
-  DWORD ret = 0;
-  GPtrArray *networks;
-  gsize i;
-  MIB_IPFORWARD_TABLE2 *routes = NULL;
-  MIB_IPFORWARD_ROW2 *route;
-
-  ret = GetIpForwardTable2 (AF_UNSPEC, &routes);
-  if (ret != ERROR_SUCCESS)
-    {
-      g_set_error (error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                   "GetIpForwardTable2 () failed: %ld", ret);
-
-      return FALSE;
-    }
-
-  networks = g_ptr_array_new_full (routes->NumEntries, g_object_unref);
-  for (i = 0; i < routes->NumEntries; i++)
-    {
-      GInetAddressMask *network;
-      const guint8 *dest;
-      gsize len;
-      GSocketFamily family;
-
-      route = routes->Table + i;
-
-      if (!win_network_monitor_get_ip_info (route->DestinationPrefix, &family, &dest, &len))
-        continue;
-
-      network = get_network_mask (family, dest, len);
-      if (network == NULL)
-        continue;
-
-      g_ptr_array_add (networks, network);
-    }
-
-  g_network_monitor_base_set_networks (G_NETWORK_MONITOR_BASE (win),
-                                       (GInetAddressMask **) networks->pdata,
-                                       networks->len);
-
-  return TRUE;
-}
-
-static void
-add_network (GWin32NetworkMonitor *win,
-             GSocketFamily         family,
-             const guint8         *dest,
-             gsize                 dest_len)
-{
-  GInetAddressMask *network;
-
-  network = get_network_mask (family, dest, dest_len);
-  if (network != NULL)
-    {
-      g_network_monitor_base_add_network (G_NETWORK_MONITOR_BASE (win), network);
-      g_object_unref (network);
-    }
-}
-
-static void
-remove_network (GWin32NetworkMonitor *win,
-                GSocketFamily         family,
-                const guint8         *dest,
-                gsize                 dest_len)
-{
-  GInetAddressMask *network;
-
-  network = get_network_mask (family, dest, dest_len);
-  if (network != NULL)
-    {
-      g_network_monitor_base_remove_network (G_NETWORK_MONITOR_BASE (win), network);
-      g_object_unref (network);
-    }
-}
-
-typedef struct {
-  PMIB_IPFORWARD_ROW2 route;
-  MIB_NOTIFICATION_TYPE type;
-  GWin32NetworkMonitor *win;
-} RouteData;
-
-static gboolean
-win_network_monitor_invoke_route_changed (gpointer user_data)
-{
-  GSocketFamily family;
-  RouteData *route_data = user_data;
-  const guint8 *dest;
-  gsize len;
-
-  switch (route_data->type)
-    {
-      case MibDeleteInstance:
-        if (!win_network_monitor_get_ip_info (route_data->route->DestinationPrefix, &family, &dest, &len))
-          break;
-
-        remove_network (route_data->win, family, dest, len);
-        break;
-      case MibAddInstance:
-        if (!win_network_monitor_get_ip_info (route_data->route->DestinationPrefix, &family, &dest, &len))
-            break;
-
-        add_network (route_data->win, family, dest, len);
-        break;
-      case MibInitialNotification:
-      default:
-        break;
-    }
-
-  return G_SOURCE_REMOVE;
-}
-
-static VOID WINAPI
-win_network_monitor_route_changed_cb (PVOID                 context,
-                                      PMIB_IPFORWARD_ROW2   route,
-                                      MIB_NOTIFICATION_TYPE type)
-{
-  GWin32NetworkMonitor *win = context;
-  RouteData *route_data;
-
-  route_data = g_new0 (RouteData, 1);
-  route_data->route = route;
-  route_data->type = type;
-  route_data->win = win;
-
-  win->priv->route_change_source = g_idle_source_new ();
-  g_source_set_priority (win->priv->route_change_source, G_PRIORITY_DEFAULT);
-  g_source_set_callback (win->priv->route_change_source,
-                         win_network_monitor_invoke_route_changed,
-                         route_data,
-                         g_free);
-
-  g_source_attach (win->priv->route_change_source, win->priv->main_context);
-}
-
-static gboolean
-g_win32_network_monitor_initable_init (GInitable     *initable,
-                                       GCancellable  *cancellable,
-                                       GError       **error)
-{
-  GWin32NetworkMonitor *win = G_WIN32_NETWORK_MONITOR (initable);
-  NTSTATUS status;
-  gboolean read;
-
-  if (!win->priv->initialized)
-    {
-      win->priv->main_context = g_main_context_ref_thread_default ();
-
-      /* Read current IP routing table. */
-      read = win_network_monitor_process_table (win, &win->priv->init_error);
-      if (read)
-        {
-          /* Register for IPv4 and IPv6 route updates. */
-          status = NotifyRouteChange2 (AF_UNSPEC, (PIPFORWARD_CHANGE_CALLBACK) win_network_monitor_route_changed_cb, win, FALSE, &win->priv->handle);
-          if (status != NO_ERROR)
-            g_set_error (&win->priv->init_error, G_IO_ERROR, G_IO_ERROR_FAILED,
-                         "NotifyRouteChange2() error: %ld", status);
-        }
-
-      win->priv->initialized = TRUE;
-    }
-
-  /* Forward the results. */
-  if (win->priv->init_error != NULL)
-    {
-      g_propagate_error (error, g_error_copy (win->priv->init_error));
-      return FALSE;
-    }
-
-  return initable_parent_iface->init (initable, cancellable, error);
-}
-
-static void
-g_win32_network_monitor_finalize (GObject *object)
-{
-  GWin32NetworkMonitor *win = G_WIN32_NETWORK_MONITOR (object);
-
-  /* Cancel notification event */
-  if (win->priv->handle)
-    CancelMibChangeNotify2 (win->priv->handle);
-
-  g_clear_error (&win->priv->init_error);
-
-  if (win->priv->route_change_source != NULL)
-    {
-      g_source_destroy (win->priv->route_change_source);
-      g_source_unref (win->priv->route_change_source);
-    }
-
-  g_main_context_unref (win->priv->main_context);
-
-  G_OBJECT_CLASS (g_win32_network_monitor_parent_class)->finalize (object);
-}
-
-static void
-g_win32_network_monitor_class_init (GWin32NetworkMonitorClass *win_class)
-{
-  GObjectClass *gobject_class = G_OBJECT_CLASS (win_class);
-
-  gobject_class->finalize = g_win32_network_monitor_finalize;
-}
-
-static void
-g_win32_network_monitor_iface_init (GNetworkMonitorInterface *monitor_iface)
-{
-}
-
-static void
-g_win32_network_monitor_initable_iface_init (GInitableIface *iface)
-{
-  initable_parent_iface = g_type_interface_peek_parent (iface);
-
-  iface->init = g_win32_network_monitor_initable_init;
-}
diff --git a/gio/gwin32networkmonitor.h b/gio/gwin32networkmonitor.h
deleted file mode 100644
index 1111111..0000000
--- a/gio/gwin32networkmonitor.h
+++ /dev/null
@@ -1,53 +0,0 @@
-/* GIO - GLib Input, Output and Streaming Library
- *
- * Copyright 2014-2018 Jan-Michael Brummer <jan.brummer@tabos.org>
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General
- * Public License along with this library; if not, write to the
- * Free Software Foundation, Inc., 59 Temple Place, Suite 330,
- * Boston, MA 02111-1307, USA.
- */
-
-#ifndef __G_WIN32_NETWORK_MONITOR_H__
-#define __G_WIN32_NETWORK_MONITOR_H__
-
-#include "gnetworkmonitorbase.h"
-
-G_BEGIN_DECLS
-
-#define G_TYPE_WIN32_NETWORK_MONITOR         (_g_win32_network_monitor_get_type ())
-#define G_WIN32_NETWORK_MONITOR(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), G_TYPE_WIN32_NETWORK_MONITOR, GWin32NetworkMonitor))
-#define G_WIN32_NETWORK_MONITOR_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), G_TYPE_WIN32_NETWORK_MONITOR, GWin32NetworkMonitorClass))
-#define G_IS_WIN32_NETWORK_MONITOR(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), G_TYPE_WIN32_NETWORK_MONITOR))
-#define G_IS_WIN32_NETWORK_MONITOR_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), G_TYPE_WIN32_NETWORK_MONITOR))
-#define G_WIN32_NETWORK_MONITOR_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), G_TYPE_WIN32_NETWORK_MONITOR, GWin32NetworkMonitorClass))
-
-typedef struct _GWin32NetworkMonitor        GWin32NetworkMonitor;
-typedef struct _GWin32NetworkMonitorClass   GWin32NetworkMonitorClass;
-typedef struct _GWin32NetworkMonitorPrivate GWin32NetworkMonitorPrivate;
-
-struct _GWin32NetworkMonitor {
-  GNetworkMonitorBase parent_instance;
-
-  GWin32NetworkMonitorPrivate *priv;
-};
-
-struct _GWin32NetworkMonitorClass {
-  GNetworkMonitorBaseClass parent_class;
-};
-
-GType _g_win32_network_monitor_get_type (void);
-
-G_END_DECLS
-
-#endif /* __G_WIN32_NETWORK_MONITOR_H__ */
diff --git a/gio/meson.build b/gio/meson.build
index 1111111..2222222 100644
--- a/gio/meson.build
+++ b/gio/meson.build
@@ -428,8 +428,6 @@ else
     'gwin32volumemonitor.c',
     'gwin32inputstream.c',
     'gwin32outputstream.c',
-    'gwin32networkmonitor.c',
-    'gwin32networkmonitor.h',
     'gwin32notificationbackend.c',
     'gwin32sid.c',
     'gwin32sid.h',

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 11:20:54 +0100
Subject: [PATCH 14/14] Restore compatibility with Windows XP


diff --git a/gio/glocalfileinfo.c b/gio/glocalfileinfo.c
index 1111111..2222222 100644
--- a/gio/glocalfileinfo.c
+++ b/gio/glocalfileinfo.c
@@ -1007,7 +1007,7 @@ set_info_from_stat (GFileInfo             *info,
   _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_UNIX_BLOCKS, _g_stat_blocks (statbuf));
   _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_STANDARD_ALLOCATED_SIZE,
                                            _g_stat_blocks (statbuf) * G_GUINT64_CONSTANT (512));
-#elif defined (G_OS_WIN32)
+#elif defined (G_OS_WIN32) && _WIN32_WINNT > 0x0600
   _g_file_info_set_attribute_uint64_by_id (info, G_FILE_ATTRIBUTE_ID_STANDARD_ALLOCATED_SIZE,
                                            statbuf->allocated_size);
 
diff --git a/gio/gsocket.c b/gio/gsocket.c
index 1111111..2222222 100644
--- a/gio/gsocket.c
+++ b/gio/gsocket.c
@@ -2221,7 +2221,7 @@ g_socket_bind (GSocket         *socket,
   return TRUE;
 }
 
-#ifdef G_OS_WIN32
+#if defined(G_OS_WIN32) && defined (HAVE_IF_NAMETOINDEX)
 static gulong
 g_socket_w32_get_adapter_ipv4_addr (const gchar *name_or_ip)
 {
@@ -2372,7 +2372,7 @@ g_socket_multicast_group_operation (GSocket       *socket,
         mc_req.imr_ifindex = if_nametoindex (iface);
       else
         mc_req.imr_ifindex = 0;  /* Pick any.  */
-#elif defined(G_OS_WIN32)
+#elif defined(G_OS_WIN32) && defined (HAVE_IF_NAMETOINDEX)
       if (iface)
         mc_req.imr_interface.s_addr = g_socket_w32_get_adapter_ipv4_addr (iface);
       else
@@ -2573,7 +2573,7 @@ g_socket_multicast_group_operation_ssm (GSocket       *socket,
 
         if (iface)
           {
-#if defined(G_OS_WIN32)
+#if defined(G_OS_WIN32) && defined (HAVE_IF_NAMETOINDEX)
             S_ADDR_FIELD(mc_req_src) = g_socket_w32_get_adapter_ipv4_addr (iface);
 #elif defined (HAVE_SIOCGIFADDR)
             int ret;
diff --git a/glib/gstdio.c b/glib/gstdio.c
index 1111111..2222222 100644
--- a/glib/gstdio.c
+++ b/glib/gstdio.c
@@ -313,7 +313,9 @@ _g_win32_fill_statbuf_from_handle_info (const wchar_t                    *filena
 static void
 _g_win32_fill_privatestat (const struct __stat64            *statbuf,
                            const BY_HANDLE_FILE_INFORMATION *handle_info,
+#if _WIN32_WINNT > 0x0600
                            const FILE_STANDARD_INFO         *std_info,
+#endif
                            DWORD                             reparse_tag,
                            GWin32PrivateStat                *buf)
 {
@@ -325,7 +327,9 @@ _g_win32_fill_privatestat (const struct __stat64            *statbuf,
   buf->attributes = handle_info->dwFileAttributes;
   buf->st_nlink = handle_info->nNumberOfLinks;
   buf->st_size = (((guint64) handle_info->nFileSizeHigh) << 32) | handle_info->nFileSizeLow;
+#if _WIN32_WINNT > 0x0600
   buf->allocated_size = std_info->AllocationSize.QuadPart;
+#endif
 
   buf->reparse_tag = reparse_tag;
 
@@ -581,7 +585,9 @@ _g_win32_stat_utf16_no_trailing_slashes (const gunichar2    *filename,
 {
   struct __stat64 statbuf;
   BY_HANDLE_FILE_INFORMATION handle_info;
+#if _WIN32_WINNT > 0x0600
   FILE_STANDARD_INFO std_info;
+#endif
   gboolean is_symlink = FALSE;
   wchar_t *filename_target = NULL;
   DWORD immediate_attributes;
@@ -630,6 +636,7 @@ _g_win32_stat_utf16_no_trailing_slashes (const gunichar2    *filename,
                                                  &handle_info);
   error_code = GetLastError ();
 
+#if _WIN32_WINNT > 0x0600
   if (succeeded_so_far)
     {
       succeeded_so_far = GetFileInformationByHandleEx (file_handle,
@@ -638,6 +645,7 @@ _g_win32_stat_utf16_no_trailing_slashes (const gunichar2    *filename,
                                                        sizeof (std_info));
       error_code = GetLastError ();
     }
+#endif
 
   if (!succeeded_so_far)
     {
@@ -673,7 +681,9 @@ _g_win32_stat_utf16_no_trailing_slashes (const gunichar2    *filename,
   g_free (filename_target);
   _g_win32_fill_privatestat (&statbuf,
                              &handle_info,
+#if _WIN32_WINNT > 0x0600
                              &std_info,
+#endif
                              reparse_tag,
                              buf);
 
@@ -690,7 +700,9 @@ _g_win32_stat_fd (int                 fd,
   DWORD error_code;
   struct __stat64 statbuf;
   BY_HANDLE_FILE_INFORMATION handle_info;
+#if _WIN32_WINNT > 0x0600
   FILE_STANDARD_INFO std_info;
+#endif
   DWORD reparse_tag = 0;
   gboolean is_symlink = FALSE;
 
@@ -703,6 +715,7 @@ _g_win32_stat_fd (int                 fd,
                                                  &handle_info);
   error_code = GetLastError ();
 
+#if _WIN32_WINNT > 0x0600
   if (succeeded_so_far)
     {
       succeeded_so_far = GetFileInformationByHandleEx (file_handle,
@@ -711,6 +724,7 @@ _g_win32_stat_fd (int                 fd,
                                                        sizeof (std_info));
       error_code = GetLastError ();
     }
+#endif
 
   if (!succeeded_so_far)
     {
@@ -729,7 +743,9 @@ _g_win32_stat_fd (int                 fd,
 
   _g_win32_fill_privatestat (&statbuf,
                              &handle_info,
+#if _WIN32_WINNT > 0x0600
                              &std_info,
+#endif
                              reparse_tag,
                              buf);
 
diff --git a/meson.build b/meson.build
index 1111111..2222222 100644
--- a/meson.build
+++ b/meson.build
@@ -518,8 +518,8 @@ if host_system == 'windows'
     # We require Windows 10+ on WinRT
     glib_conf.set('_WIN32_WINNT', '0x0A00')
   else
-    # We require Windows 7+ on Win32
-    glib_conf.set('_WIN32_WINNT', '0x0601')
+    # We require Windows XP+ on Win32
+    glib_conf.set('_WIN32_WINNT', '0x0501')
   endif
 endif
 
