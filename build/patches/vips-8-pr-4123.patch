From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Tue, 27 Aug 2024 11:11:48 +0200
Subject: [PATCH 1/1] threadpool: prefer use of dedicated GLib atomic operations

That is:
`g_atomic_int_add(..., 1)` -> `g_atomic_int_inc(...)`
`g_atomic_int_add(..., -1)` -> `g_atomic_int_dec_and_test(...)`

Upstream-Status: Submitted [https://github.com/libvips/libvips/pull/4123]

diff --git a/libvips/iofuncs/threadpool.c b/libvips/iofuncs/threadpool.c
index 1111111..2222222 100644
--- a/libvips/iofuncs/threadpool.c
+++ b/libvips/iofuncs/threadpool.c
@@ -272,7 +272,7 @@ typedef struct _VipsThreadpool {
 	/* The number of workers queueing up on allocate_lock. Use this to
 	 * grow and shrink the threadpool.
 	 */
-	int n_waiting;
+	int n_waiting;  /* (atomic) */
 
 	/* Set this to abort evaluation early with an error.
 	 */
@@ -285,7 +285,7 @@ typedef struct _VipsThreadpool {
 	/* Set this and the next worker to see it will clear the flag and exit
 	 * (used to downsize the threadpool).
 	 */
-	int exit;
+	int exit;  /* (atomic) */
 } VipsThreadpool;
 
 static int
@@ -329,7 +329,7 @@ vips_worker_work_unit(VipsWorker *worker)
 
 	/* Has a thread been asked to exit? Volunteer if yes.
 	 */
-	if (g_atomic_int_add(&pool->exit, -1) > 0) {
+	if (g_atomic_int_dec_and_test(&pool->exit)) {
 		/* A thread had been asked to exit, and we've grabbed the
 		 * flag.
 		 */
@@ -341,7 +341,7 @@ vips_worker_work_unit(VipsWorker *worker)
 		/* No one had been asked to exit and we've mistakenly taken
 		 * the exit count below zero. Put it back up again.
 		 */
-		g_atomic_int_add(&pool->exit, 1);
+		g_atomic_int_inc(&pool->exit);
 	}
 
 	if (vips_worker_allocate(worker)) {
@@ -460,10 +460,10 @@ vips__worker_lock(GMutex *mutex)
 	VipsWorker *worker = (VipsWorker *) g_private_get(worker_key);
 
 	if (worker)
-		g_atomic_int_add(&worker->pool->n_waiting, 1);
+		g_atomic_int_inc(&worker->pool->n_waiting);
 	g_mutex_lock(mutex);
 	if (worker)
-		g_atomic_int_add(&worker->pool->n_waiting, -1);
+		g_atomic_int_dec_and_test(&worker->pool->n_waiting);
 }
 
 void
@@ -472,10 +472,10 @@ vips__worker_cond_wait(GCond *cond, GMutex *mutex)
 	VipsWorker *worker = (VipsWorker *) g_private_get(worker_key);
 
 	if (worker)
-		g_atomic_int_add(&worker->pool->n_waiting, 1);
+		g_atomic_int_inc(&worker->pool->n_waiting);
 	g_cond_wait(cond, mutex);
 	if (worker)
-		g_atomic_int_add(&worker->pool->n_waiting, -1);
+		g_atomic_int_dec_and_test(&worker->pool->n_waiting);
 }
 
 static void
@@ -706,7 +706,7 @@ vips_threadpool_run(VipsImage *im,
 		if (n_waiting > 3 &&
 			n_working > 1) {
 			VIPS_DEBUG_MSG("shrinking thread pool\n");
-			g_atomic_int_add(&pool->exit, 1);
+			g_atomic_int_inc(&pool->exit);
 			n_working -= 1;
 		}
 		else if (n_waiting < 2 &&
