From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Mon, 2 Aug 2021 19:48:54 +0200
Subject: [PATCH 1/1] [WiP] Remove seq line cache from shrinkv/reduceh

This partially reverts commit 55840cf1 and 3ca20681.

See: https://github.com/libvips/libvips/discussions/2757

diff --git a/libvips/resample/reducev.cpp b/libvips/resample/reducev.cpp
index 1111111..2222222 100644
--- a/libvips/resample/reducev.cpp
+++ b/libvips/resample/reducev.cpp
@@ -23,6 +23,8 @@
  * 	- speed up the mask construction for uchar/ushort images
  * 22/4/22 kleisauke
  * 	- add @gap option
+ * 25/7/22 kleisauke
+ * 	- remove seq line cache
  */
 
 /*
@@ -769,7 +771,6 @@ vips_reducev_raw( VipsReducev *reducev, VipsImage *in, int height,
 		generate = vips_reducev_vector_gen;
 	}
 
-	*out = vips_image_new();
 	if( vips_image_pipelinev( *out, 
 		VIPS_DEMAND_STYLE_THINSTRIP, in, (void *) NULL ) )
 		return( -1 );
@@ -807,7 +808,8 @@ vips_reducev_build( VipsObject *object )
 	VipsObjectClass *object_class = VIPS_OBJECT_GET_CLASS( object );
 	VipsResample *resample = VIPS_RESAMPLE( object );
 	VipsReducev *reducev = (VipsReducev *) object;
-	VipsImage **t = (VipsImage **) vips_object_local_array( object, 5 );
+	VipsImage **t = (VipsImage **) 
+		vips_object_local_array( object, 3 );
 
 	VipsImage *in;
 	int height;
@@ -924,33 +926,8 @@ vips_reducev_build( VipsObject *object )
 		return( -1 );
 	in = t[2];
 
-	if( vips_reducev_raw( reducev, in, height, &t[3] ) )
+	if( vips_reducev_raw( reducev, in, height, &resample->out ) )
 		return( -1 );
-	in = t[3];
-
-	/* Large reducev will throw off sequential mode. Suppose thread1 is
-	 * generating tile (0, 0), but stalls. thread2 generates tile
-	 * (0, 1), 128 lines further down the output. After it has done,
-	 * thread1 tries to generate (0, 0), but by then the pixels it needs
-	 * have gone from the input image line cache if the reducev is large.
-	 *
-	 * To fix this, put another seq on the output of reducev. Now we'll
-	 * always have the previous XX lines of the shrunk image, and we won't
-	 * fetch out of order. 
-	 */
-	if( vips_image_get_typeof( in, VIPS_META_SEQUENTIAL ) ) { 
-		g_info( "reducev sequential line cache" ); 
-
-		if( vips_sequential( in, &t[4], 
-			"tile_height", 10,
-			// "trace", TRUE,
-			(void *) NULL ) )
-			return( -1 );
-		in = t[4];
-	}
-
-	if( vips_image_write( in, resample->out ) )
-		return( -1 ); 
 
 	return( 0 );
 }
diff --git a/libvips/resample/shrinkv.c b/libvips/resample/shrinkv.c
index 1111111..2222222 100644
--- a/libvips/resample/shrinkv.c
+++ b/libvips/resample/shrinkv.c
@@ -49,6 +49,8 @@
  * 	- use a double sum buffer for int32 types
  * 22/4/22 kleisauke
  * 	- add @ceil option
+ * 25/7/22 kleisauke
+ * 	- remove seq line cache
  */
 
 /*
@@ -332,7 +334,7 @@ vips_shrinkv_build( VipsObject *object )
 	VipsResample *resample = VIPS_RESAMPLE( object );
 	VipsShrinkv *shrink = (VipsShrinkv *) object;
 	VipsImage **t = (VipsImage **) 
-		vips_object_local_array( object, 4 );
+		vips_object_local_array( object, 2 );
 
 	VipsImage *in;
 
@@ -370,8 +372,7 @@ vips_shrinkv_build( VipsObject *object )
 	/* SMALLTILE or we'll need huge input areas for our output. In seq
 	 * mode, the linecache above will keep us sequential. 
 	 */
-	t[2] = vips_image_new();
-	if( vips_image_pipelinev( t[2],
+	if( vips_image_pipelinev( resample->out,
 		VIPS_DEMAND_STYLE_SMALLTILE, in, NULL ) )
 		return( -1 );
 
@@ -381,11 +382,11 @@ vips_shrinkv_build( VipsObject *object )
 	 * example, vipsthumbnail knows the true shrink factor (including the
 	 * fractional part), we just see the integer part here.
 	 */
-	t[2]->Ysize = shrink->ceil ?
+	resample->out->Ysize = shrink->ceil ?
 		VIPS_CEIL( (double) resample->in->Ysize / shrink->vshrink ) :
 		VIPS_ROUND_UINT( 
 			(double) resample->in->Ysize / shrink->vshrink );
-	if( t[2]->Ysize <= 0 ) {
+	if( resample->out->Ysize <= 0 ) {
 		vips_error( class->nickname, 
 			"%s", _( "image has shrunk to nothing" ) );
 		return( -1 );
@@ -394,39 +395,14 @@ vips_shrinkv_build( VipsObject *object )
 #ifdef DEBUG
 	printf( "vips_shrinkv_build: shrinking %d x %d image to %d x %d\n", 
 		in->Xsize, in->Ysize, 
-		t[2]->Xsize, t[2]->Ysize );  
+		resample->out->Xsize, resample->out->Ysize );  
 #endif /*DEBUG*/
 
-	if( vips_image_generate( t[2],
+	if( vips_image_generate( resample->out,
 		vips_shrinkv_start, vips_shrinkv_gen, vips_shrinkv_stop, 
 		in, shrink ) )
 		return( -1 );
 
-	in = t[2];
-
-	/* Large vshrinks will throw off sequential mode. Suppose thread1 is
-	 * generating tile (0, 0), but stalls. thread2 generates tile
-	 * (0, 1), 128 lines further down the output. After it has done,
-	 * thread1 tries to generate (0, 0), but by then the pixels it needs
-	 * have gone from the input image line cache if the vshrink is large.
-	 *
-	 * To fix this, put another seq on the output of vshrink. Now we'll
-	 * always have the previous XX lines of the shrunk image, and we won't
-	 * fetch out of order. 
-	 */
-	if( vips_image_is_sequential( in ) ) { 
-		g_info( "shrinkv sequential line cache" ); 
-
-		if( vips_sequential( in, &t[3], 
-			"tile_height", 10,
-			NULL ) )
-			return( -1 );
-		in = t[3];
-	}
-
-	if( vips_image_write( in, resample->out ) )
-		return( -1 ); 
-
 	return( 0 );
 }
 
