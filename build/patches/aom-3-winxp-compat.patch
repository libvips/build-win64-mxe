From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Thu, 10 Mar 2022 10:48:17 +0100
Subject: [PATCH 1/3] Revert "Require Windows Vista / Server 2008 or greater."

This reverts commit 7e48669d25a939833f548a66992f5af2a43bbec4.

diff --git a/aom_util/aom_thread.h b/aom_util/aom_thread.h
index 1111111..2222222 100644
--- a/aom_util/aom_thread.h
+++ b/aom_util/aom_thread.h
@@ -36,10 +36,16 @@ extern "C" {
 typedef HANDLE pthread_t;
 typedef CRITICAL_SECTION pthread_mutex_t;
 
-#if _WIN32_WINNT < 0x0600
-#error _WIN32_WINNT must target Windows Vista / Server 2008 or newer.
-#endif
+#if _WIN32_WINNT >= 0x0600  // Windows Vista / Server 2008 or greater
+#define USE_WINDOWS_CONDITION_VARIABLE
 typedef CONDITION_VARIABLE pthread_cond_t;
+#else
+typedef struct {
+  HANDLE waiting_sem_;
+  HANDLE received_sem_;
+  HANDLE signal_event_;
+} pthread_cond_t;
+#endif  // _WIN32_WINNT >= 0x600
 
 #ifndef WINAPI_FAMILY_PARTITION
 #define WINAPI_PARTITION_DESKTOP 1
@@ -57,6 +63,11 @@ typedef CONDITION_VARIABLE pthread_cond_t;
 #define THREADFN FORCE_ALIGN unsigned int __stdcall
 #define THREAD_RETURN(val) (unsigned int)((DWORD_PTR)val)
 
+#if _WIN32_WINNT >= 0x0501  // Windows XP or greater
+#define WaitForSingleObject(obj, timeout) \
+  WaitForSingleObjectEx(obj, timeout, FALSE /*bAlertable*/)
+#endif
+
 static INLINE int pthread_create(pthread_t *const thread, const void *attr,
                                  unsigned int(__stdcall *start)(void *),
                                  void *arg) {
@@ -79,8 +90,7 @@ static INLINE int pthread_create(pthread_t *const thread, const void *attr,
 
 static INLINE int pthread_join(pthread_t thread, void **value_ptr) {
   (void)value_ptr;
-  return (WaitForSingleObjectEx(thread, INFINITE, FALSE /*bAlertable*/) !=
-              WAIT_OBJECT_0 ||
+  return (WaitForSingleObject(thread, INFINITE) != WAIT_OBJECT_0 ||
           CloseHandle(thread) == 0);
 }
 
@@ -88,7 +98,11 @@ static INLINE int pthread_join(pthread_t thread, void **value_ptr) {
 static INLINE int pthread_mutex_init(pthread_mutex_t *const mutex,
                                      void *mutexattr) {
   (void)mutexattr;
+#if _WIN32_WINNT >= 0x0600  // Windows Vista / Server 2008 or greater
   InitializeCriticalSectionEx(mutex, 0 /*dwSpinCount*/, 0 /*Flags*/);
+#else
+  InitializeCriticalSection(mutex);
+#endif
   return 0;
 }
 
@@ -113,31 +127,85 @@ static INLINE int pthread_mutex_destroy(pthread_mutex_t *const mutex) {
 
 // Condition
 static INLINE int pthread_cond_destroy(pthread_cond_t *const condition) {
+  int ok = 1;
+#ifdef USE_WINDOWS_CONDITION_VARIABLE
   (void)condition;
-  return 0;
+#else
+  ok &= (CloseHandle(condition->waiting_sem_) != 0);
+  ok &= (CloseHandle(condition->received_sem_) != 0);
+  ok &= (CloseHandle(condition->signal_event_) != 0);
+#endif
+  return !ok;
 }
 
 static INLINE int pthread_cond_init(pthread_cond_t *const condition,
                                     void *cond_attr) {
   (void)cond_attr;
+#ifdef USE_WINDOWS_CONDITION_VARIABLE
   InitializeConditionVariable(condition);
+#else
+  condition->waiting_sem_ = CreateSemaphore(NULL, 0, MAX_NUM_THREADS, NULL);
+  condition->received_sem_ = CreateSemaphore(NULL, 0, MAX_NUM_THREADS, NULL);
+  condition->signal_event_ = CreateEvent(NULL, FALSE, FALSE, NULL);
+  if (condition->waiting_sem_ == NULL || condition->received_sem_ == NULL ||
+      condition->signal_event_ == NULL) {
+    pthread_cond_destroy(condition);
+    return 1;
+  }
+#endif
   return 0;
 }
 
 static INLINE int pthread_cond_signal(pthread_cond_t *const condition) {
+  int ok = 1;
+#ifdef USE_WINDOWS_CONDITION_VARIABLE
   WakeConditionVariable(condition);
-  return 0;
+#else
+  if (WaitForSingleObject(condition->waiting_sem_, 0) == WAIT_OBJECT_0) {
+    // a thread is waiting in pthread_cond_wait: allow it to be notified
+    ok = SetEvent(condition->signal_event_);
+    // wait until the event is consumed so the signaler cannot consume
+    // the event via its own pthread_cond_wait.
+    ok &= (WaitForSingleObject(condition->received_sem_, INFINITE) !=
+           WAIT_OBJECT_0);
+  }
+#endif
+  return !ok;
 }
 
 static INLINE int pthread_cond_broadcast(pthread_cond_t *const condition) {
+  int ok = 1;
+#ifdef USE_WINDOWS_CONDITION_VARIABLE
   WakeAllConditionVariable(condition);
-  return 0;
+#else
+  while (WaitForSingleObject(condition->waiting_sem_, 0) == WAIT_OBJECT_0) {
+    // a thread is waiting in pthread_cond_wait: allow it to be notified
+    ok &= SetEvent(condition->signal_event_);
+    // wait until the event is consumed so the signaler cannot consume
+    // the event via its own pthread_cond_wait.
+    ok &= (WaitForSingleObject(condition->received_sem_, INFINITE) !=
+           WAIT_OBJECT_0);
+  }
+#endif
+  return !ok;
 }
 
 static INLINE int pthread_cond_wait(pthread_cond_t *const condition,
                                     pthread_mutex_t *const mutex) {
   int ok;
+#ifdef USE_WINDOWS_CONDITION_VARIABLE
   ok = SleepConditionVariableCS(condition, mutex, INFINITE);
+#else
+  // note that there is a consumer available so the signal isn't dropped in
+  // pthread_cond_signal
+  if (!ReleaseSemaphore(condition->waiting_sem_, 1, NULL)) return 1;
+  // now unlock the mutex so pthread_cond_signal may be issued
+  pthread_mutex_unlock(mutex);
+  ok = (WaitForSingleObject(condition->signal_event_, INFINITE) ==
+        WAIT_OBJECT_0);
+  ok &= ReleaseSemaphore(condition->received_sem_, 1, NULL);
+  pthread_mutex_lock(mutex);
+#endif
   return !ok;
 }
 #elif defined(__OS2__)

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Thu, 10 Mar 2022 10:51:26 +0100
Subject: [PATCH 2/3] Revert "Add -D_WIN32_WINNT=0x0601 flag to target Windows
 7"

This reverts commit 64545cb00a29ff872473db481a57cdc9bc4f1f82.

diff --git a/build/cmake/aom_configure.cmake b/build/cmake/aom_configure.cmake
index 1111111..2222222 100644
--- a/build/cmake/aom_configure.cmake
+++ b/build/cmake/aom_configure.cmake
@@ -199,12 +199,6 @@ if(AOM_TARGET_SYSTEM MATCHES "Darwin\|Linux\|Windows\|Android")
   set(CONFIG_OS_SUPPORT 1)
 endif()
 
-# The default _WIN32_WINNT value in MinGW is 0x0502 (Windows XP with SP2). Set
-# it to 0x0601 (Windows 7).
-if(AOM_TARGET_SYSTEM STREQUAL "Windows")
-  add_compiler_flag_if_supported("-D_WIN32_WINNT=0x0601")
-endif()
-
 #
 # Fix CONFIG_* dependencies. This must be done before including cpu.cmake to
 # ensure RTCD_CONFIG_* are properly set.

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Mar 2022 21:29:07 +0100
Subject: [PATCH 3/3] Revert "Implement aom_once using Win32 InitOnce functions."

This reverts commit e5eec6c5eb14e66e2733b135ef1c405c7e6424bf.

diff --git a/aom_ports/aom_once.h b/aom_ports/aom_once.h
index 1111111..2222222 100644
--- a/aom_ports/aom_once.h
+++ b/aom_ports/aom_once.h
@@ -40,22 +40,56 @@
 
 #if CONFIG_MULTITHREAD && defined(_WIN32)
 #include <windows.h>
+#include <stdlib.h>
 /* Declare a per-compilation-unit state variable to track the progress
  * of calling func() only once. This must be at global scope because
  * local initializers are not thread-safe in MSVC prior to Visual
  * Studio 2015.
+ *
+ * As a static, aom_once_state will be zero-initialized as program start.
  */
-static INIT_ONCE aom_init_once = INIT_ONCE_STATIC_INIT;
-
+static LONG aom_once_state;
 static void aom_once(void (*func)(void)) {
-  BOOL pending;
-  InitOnceBeginInitialize(&aom_init_once, 0, &pending, NULL);
-  if (!pending) {
-    // Initialization has already completed.
+  /* Try to advance aom_once_state from its initial value of 0 to 1.
+   * Only one thread can succeed in doing so.
+   */
+  if (InterlockedCompareExchange(&aom_once_state, 1, 0) == 0) {
+    /* We're the winning thread, having set aom_once_state to 1.
+     * Call our function. */
+    func();
+    /* Now advance aom_once_state to 2, unblocking any other threads. */
+    InterlockedIncrement(&aom_once_state);
     return;
   }
-  func();
-  InitOnceComplete(&aom_init_once, 0, NULL);
+
+  /* We weren't the winning thread, but we want to block on
+   * the state variable so we don't return before func()
+   * has finished executing elsewhere.
+   *
+   * Try to advance aom_once_state from 2 to 2, which is only possible
+   * after the winning thead advances it from 1 to 2.
+   */
+  while (InterlockedCompareExchange(&aom_once_state, 2, 2) != 2) {
+    /* State isn't yet 2. Try again.
+     *
+     * We are used for singleton initialization functions,
+     * which should complete quickly. Contention will likewise
+     * be rare, so it's worthwhile to use a simple but cpu-
+     * intensive busy-wait instead of successive backoff,
+     * waiting on a kernel object, or another heavier-weight scheme.
+     *
+     * We can at least yield our timeslice.
+     */
+    Sleep(0);
+  }
+
+  /* We've seen aom_once_state advance to 2, so we know func()
+   * has been called. And we've left aom_once_state as we found it,
+   * so other threads will have the same experience.
+   *
+   * It's safe to return now.
+   */
+  return;
 }
 
 #elif CONFIG_MULTITHREAD && defined(__OS2__)
