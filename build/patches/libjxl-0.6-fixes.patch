From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 2 Jun 2021 14:07:04 +0200
Subject: [PATCH 1/9] Remove LCMS mutex

Upstream-Status: Submitted [https://github.com/libjxl/libjxl/pull/112]

diff --git a/lib/jxl/enc_color_management.cc b/lib/jxl/enc_color_management.cc
index 1111111..2222222 100644
--- a/lib/jxl/enc_color_management.cc
+++ b/lib/jxl/enc_color_management.cc
@@ -20,7 +20,6 @@
 #include <array>
 #include <atomic>
 #include <memory>
-#include <mutex>
 #include <string>
 #include <utility>
 
@@ -236,14 +235,6 @@ namespace {
 // Define to 1 on OS X as a workaround for older LCMS lacking MD5.
 #define JXL_CMS_OLD_VERSION 0
 
-// cms functions (even *THR) are not thread-safe, except cmsDoTransform.
-// To ensure all functions are covered without frequent lock-taking nor risk of
-// recursive lock, we lock in the top-level APIs.
-static std::mutex& LcmsMutex() {
-  static std::mutex m;
-  return m;
-}
-
 #if JPEGXL_ENABLE_SKCMS
 
 JXL_MUST_USE_RESULT CIExy CIExyFromXYZ(const float XYZ[3]) {
@@ -638,9 +629,6 @@ cmsContext GetContext() {
 
 }  // namespace
 
-// All functions that call lcms directly (except ColorSpaceTransform::Run) must
-// lock LcmsMutex().
-
 Status ColorEncoding::SetFieldsFromICC() {
   // In case parsing fails, mark the ColorEncoding as invalid.
   SetColorSpace(ColorSpace::kUnknown);
@@ -679,7 +667,6 @@ Status ColorEncoding::SetFieldsFromICC() {
   rendering_intent = static_cast<RenderingIntent>(rendering_intent32);
 #else   // JPEGXL_ENABLE_SKCMS
 
-  std::lock_guard<std::mutex> guard(LcmsMutex());
   const cmsContext context = GetContext();
 
   Profile profile;
@@ -732,7 +719,6 @@ void ColorEncoding::DecideIfWantICC() {
 
 ColorSpaceTransform::~ColorSpaceTransform() {
 #if !JPEGXL_ENABLE_SKCMS
-  std::lock_guard<std::mutex> guard(LcmsMutex());
   TransformDeleter()(lcms_transform_);
 #endif
 }
@@ -748,7 +734,6 @@ Status ColorSpaceTransform::Init(const ColorEncoding& c_src,
                                  const ColorEncoding& c_dst,
                                  float intensity_target, size_t xsize,
                                  const size_t num_threads) {
-  std::lock_guard<std::mutex> guard(LcmsMutex());
 #if JXL_CMS_VERBOSE
   printf("%s -> %s\n", Description(c_src).c_str(), Description(c_dst).c_str());
 #endif

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Tue, 8 Jun 2021 12:40:01 +0200
Subject: [PATCH 2/9] Allow to build with system-wide installed lcms

See: https://gitlab.com/wg1/jpeg-xl/-/issues/124

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1111111..2222222 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -124,6 +124,8 @@ set(JPEGXL_FORCE_SYSTEM_BROTLI false CACHE BOOL
     "Force using system installed brotli instead of third_party/brotli source.")
 set(JPEGXL_FORCE_SYSTEM_HWY false CACHE BOOL
     "Force using system installed highway (libhwy-dev) instead of third_party/highway source.")
+set(JPEGXL_FORCE_SYSTEM_LCMS false CACHE BOOL
+    "Force using system installed lcms instead of third_party/lcms source.")
 
 # Check minimum compiler versions. Older compilers are not supported and fail
 # with hard to understand errors.
diff --git a/deps.sh b/deps.sh
index 1111111..2222222 100755
--- a/deps.sh
+++ b/deps.sh
@@ -16,6 +16,7 @@ MYDIR=$(dirname $(realpath "$0"))
 THIRD_PARTY_HIGHWAY="e2397743fe092df68b760d358253773699a16c93"
 THIRD_PARTY_LODEPNG="48e5364ef48ec2408f44c727657ac1b6703185f8"
 THIRD_PARTY_SKCMS="64374756e03700d649f897dbd98c95e78c30c7da"
+THIRD_PARTY_LCMS="17eb080324a9f16e0e7ab37bbcda7ae42b946294"
 THIRD_PARTY_SJPEG="868ab558fad70fcbe8863ba4e85179eeb81cc840"
 
 # Download the target revision from GitHub.
@@ -74,6 +75,7 @@ EOF
   download_github third_party/sjpeg webmproject/sjpeg
   download_github third_party/skcms \
     "https://skia.googlesource.com/skcms/+archive/"
+  download_github third_party/lcms mm2/Little-CMS
   echo "Done."
 }
 
diff --git a/third_party/CMakeLists.txt b/third_party/CMakeLists.txt
index 1111111..2222222 100644
--- a/third_party/CMakeLists.txt
+++ b/third_party/CMakeLists.txt
@@ -202,12 +202,37 @@ if (JPEGXL_ENABLE_SKCMS)
                  ${PROJECT_BINARY_DIR}/LICENSE.skcms COPYONLY)
 endif ()
 if (JPEGXL_ENABLE_VIEWERS OR NOT JPEGXL_ENABLE_SKCMS)
-  if( NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/lcms/.git" )
-    message(SEND_ERROR "Please run git submodule update --init")
+  if (NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/lcms/include/lcms2.h" OR
+      JPEGXL_FORCE_SYSTEM_LCMS)
+    pkg_check_modules(lcms2 lcms2>=2.11)
+    if (lcms2_FOUND)
+      add_library(lcms2 INTERFACE IMPORTED GLOBAL)
+      if(${CMAKE_VERSION} VERSION_LESS "3.13.5")
+        set_property(TARGET lcms2 PROPERTY INTERFACE_INCLUDE_DIRECTORIES ${lcms2_INCLUDE_DIR})
+        target_link_libraries(lcms2 INTERFACE ${lcms2_LDFLAGS})
+        set_property(TARGET lcms2 PROPERTY INTERFACE_COMPILE_OPTIONS ${lcms2_CFLAGS_OTHER})
+      else()
+        target_include_directories(lcms2
+            INTERFACE ${lcms2_INCLUDE_DIRS})
+        target_link_libraries(lcms2
+            INTERFACE ${lcms2_LINK_LIBRARIES})
+        target_link_options(lcms2
+            INTERFACE ${lcms2_LDFLAGS_OTHER})
+        target_compile_options(lcms2
+            INTERFACE ${lcms2_CFLAGS_OTHER})
+      endif()
+    else()
+      message(FATAL_ERROR
+              "lcms2 not found, install liblcms2-dev or download lcms2 source code to"
+              " third_party/lcms from https://github.com/mm2/little-cms. You can use"
+              " ${PROJECT_SOURCE_DIR}/deps.sh to download this dependency.")
+    endif()
+  else()
+    # Compile lcms from sources.
+    include(lcms2.cmake)
+    configure_file("${CMAKE_CURRENT_SOURCE_DIR}/lcms/COPYING"
+                   ${PROJECT_BINARY_DIR}/LICENSE.lcms COPYONLY)
   endif()
-  include(lcms2.cmake)
-  configure_file("${CMAKE_CURRENT_SOURCE_DIR}/lcms/COPYING"
-                 ${PROJECT_BINARY_DIR}/LICENSE.lcms COPYONLY)
 endif()
 
 # sjpeg

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Tue, 8 Jun 2021 13:14:53 +0200
Subject: [PATCH 3/9] Allow to build without LodePNG

Since there's no official release available.

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 1111111..2222222 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -87,6 +87,8 @@ set(JPEGXL_ENABLE_JNI true CACHE BOOL
     "Build JPEGXL JNI Java wrapper, if Java dependencies are installed.")
 set(JPEGXL_ENABLE_SJPEG true CACHE BOOL
     "Build JPEGXL with support for encoding with sjpeg.")
+set(JPEGXL_ENABLE_LODEPNG true CACHE BOOL
+    "Build JPEGXL with support for LodePNG.")
 set(JPEGXL_ENABLE_OPENEXR true CACHE BOOL
     "Build JPEGXL with support for OpenEXR if available.")
 set(JPEGXL_ENABLE_SKCMS true CACHE BOOL
diff --git a/lib/extras/codec.cc b/lib/extras/codec.cc
index 1111111..2222222 100644
--- a/lib/extras/codec.cc
+++ b/lib/extras/codec.cc
@@ -6,6 +6,9 @@
 #include "lib/extras/codec.h"
 
 #include "lib/jxl/base/file_io.h"
+#if JPEGXL_ENABLE_LODEPNG
+#include "lib/extras/codec_png.h"
+#endif
 #if JPEGXL_ENABLE_APNG
 #include "lib/extras/codec_apng.h"
 #endif
@@ -17,7 +20,6 @@
 #endif
 #include "lib/extras/codec_jpg.h"
 #include "lib/extras/codec_pgx.h"
-#include "lib/extras/codec_png.h"
 #include "lib/extras/codec_pnm.h"
 #include "lib/extras/codec_psd.h"
 #include "lib/jxl/image_bundle.h"
@@ -92,19 +94,21 @@ Status SetFromBytes(const Span<const uint8_t> bytes,
   io->metadata.m.bit_depth.bits_per_sample = 0;  // (For is-set check below)
 
   Codec codec;
-  if (extras::DecodeImagePNG(bytes, color_hints, pool, io)) {
+  if (extras::DecodeImagePGX(bytes, color_hints, pool, io)) {
+    codec = Codec::kPGX;
+  } else if (extras::DecodeImagePNM(bytes, color_hints, pool, io)) {
+    codec = Codec::kPNM;
+  }
+#if JPEGXL_ENABLE_LODEPNG
+  else if (extras::DecodeImagePNG(bytes, color_hints, pool, io)) {
     codec = Codec::kPNG;
   }
+#endif
 #if JPEGXL_ENABLE_APNG
   else if (extras::DecodeImageAPNG(bytes, color_hints, pool, io)) {
     codec = Codec::kPNG;
   }
 #endif
-  else if (extras::DecodeImagePGX(bytes, color_hints, pool, io)) {
-    codec = Codec::kPGX;
-  } else if (extras::DecodeImagePNM(bytes, color_hints, pool, io)) {
-    codec = Codec::kPNM;
-  }
 #if JPEGXL_ENABLE_GIF
   else if (extras::DecodeImageGIF(bytes, color_hints, pool, io)) {
     codec = Codec::kGIF;
@@ -158,8 +162,12 @@ Status Encode(const CodecInOut& io, const Codec codec,
 
   switch (codec) {
     case Codec::kPNG:
+#if JPEGXL_ENABLE_LODEPNG
       return extras::EncodeImagePNG(&io, c_desired, bits_per_sample, pool,
                                     bytes);
+#else
+      return JXL_FAILURE("JPEG XL was built without PNG support");
+#endif
     case Codec::kJPG:
       if (io.Main().IsJPEG()) {
         return extras::EncodeImageJPGCoefficients(&io, bytes);
diff --git a/lib/jxl_extras.cmake b/lib/jxl_extras.cmake
index 1111111..2222222 100644
--- a/lib/jxl_extras.cmake
+++ b/lib/jxl_extras.cmake
@@ -13,8 +13,6 @@ set(JPEGXL_EXTRAS_SOURCES
   extras/codec_jpg.h
   extras/codec_pgx.cc
   extras/codec_pgx.h
-  extras/codec_png.cc
-  extras/codec_png.h
   extras/codec_pnm.cc
   extras/codec_pnm.h
   extras/codec_psd.cc
@@ -39,9 +37,17 @@ set_property(TARGET jxl_extras-static PROPERTY POSITION_INDEPENDENT_CODE ON)
 target_include_directories(jxl_extras-static PUBLIC "${PROJECT_SOURCE_DIR}")
 target_link_libraries(jxl_extras-static PUBLIC
   jxl-static
-  lodepng
 )
 
+if (JPEGXL_ENABLE_LODEPNG)
+  target_sources(jxl_extras-static PRIVATE
+    extras/codec_png.cc
+    extras/codec_png.h
+  )
+  target_compile_definitions(jxl_extras-static PUBLIC -DJPEGXL_ENABLE_LODEPNG=1)
+  target_link_libraries(jxl_extras-static PUBLIC lodepng)
+endif()
+
 find_package(GIF 5.1)
 if(GIF_FOUND)
   target_sources(jxl_extras-static PRIVATE
diff --git a/third_party/CMakeLists.txt b/third_party/CMakeLists.txt
index 1111111..2222222 100644
--- a/third_party/CMakeLists.txt
+++ b/third_party/CMakeLists.txt
@@ -114,13 +114,15 @@ else()
 endif()
 
 # lodepng
-if( NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/lodepng/lodepng.h" )
-  message(FATAL_ERROR "Please run ${PROJECT_SOURCE_DIR}/deps.sh to fetch the "
-          "build dependencies.")
+if (JPEGXL_ENABLE_LODEPNG)
+  if (NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/lodepng/lodepng.h")
+    message(FATAL_ERROR "Please run ${PROJECT_SOURCE_DIR}/deps.sh to fetch the "
+            "build dependencies.")
+  endif()
+  include(lodepng.cmake)
+  configure_file("${CMAKE_CURRENT_SOURCE_DIR}/lodepng/LICENSE"
+                 ${PROJECT_BINARY_DIR}/LICENSE.lodepng COPYONLY)
 endif()
-include(lodepng.cmake)
-configure_file("${CMAKE_CURRENT_SOURCE_DIR}/lodepng/LICENSE"
-               ${PROJECT_BINARY_DIR}/LICENSE.lodepng COPYONLY)
 
 # brotli
 if (NOT EXISTS "${CMAKE_CURRENT_SOURCE_DIR}/brotli/c/include/brotli/decode.h" OR

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Tue, 8 Jun 2021 13:30:49 +0200
Subject: [PATCH 4/9] Ensure DLLs are installed in the bin directory


diff --git a/lib/jxl.cmake b/lib/jxl.cmake
index 1111111..2222222 100644
--- a/lib/jxl.cmake
+++ b/lib/jxl.cmake
@@ -549,7 +549,10 @@ endforeach()
 # contains symbols also in libjxl which would conflict if programs try to use
 # both.
 install(TARGETS jxl
-  DESTINATION ${CMAKE_INSTALL_LIBDIR})
+  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+)
 else()
 add_library(jxl ALIAS jxl-static)
 add_library(jxl_dec ALIAS jxl_dec-static)
diff --git a/lib/jxl_threads.cmake b/lib/jxl_threads.cmake
index 1111111..2222222 100644
--- a/lib/jxl_threads.cmake
+++ b/lib/jxl_threads.cmake
@@ -43,7 +43,11 @@ set_target_properties(${_target} PROPERTIES
 if (NOT WIN32)
   set_target_properties(${_target} PROPERTIES OUTPUT_NAME "jxl_threads")
 endif()
-install(TARGETS ${_target} DESTINATION ${CMAKE_INSTALL_LIBDIR})
+install(TARGETS ${_target}
+  RUNTIME DESTINATION ${CMAKE_INSTALL_BINDIR}
+  LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR}
+  ARCHIVE DESTINATION ${CMAKE_INSTALL_LIBDIR}
+)
 
 endfunction()
 
From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Wed, 9 Jun 2021 19:38:33 +0200
Subject: [PATCH 5/9] tsc_timer.h: sync with nanobenchmark.cc from Highway (#797)

This file was originally originated from nanobenchmark.cc on the
Highway project. Re-syncing this file ensures that the fixes from
commit google/highway@3769cb2, google/highway@1df8ed4 and
google/highway@f2efb75 are incorporated.

Including these commits also resolves the compilation with
llvm-mingw targeting i686 when build with support for profiling.

Upstream-Status: Accepted [https://github.com/libjxl/libjxl/commit/0b70567432ab630c2d71a70ebdf3792fbdbf5768]

diff --git a/lib/profiler/tsc_timer.h b/lib/profiler/tsc_timer.h
index 1111111..2222222 100644
--- a/lib/profiler/tsc_timer.h
+++ b/lib/profiler/tsc_timer.h
@@ -10,20 +10,43 @@
 // ensure exactly the desired regions are measured.
 
 #include <stdint.h>
+#include <time.h>  // clock_gettime
+
+#if defined(_WIN32) || defined(_WIN64)
+#ifndef WIN32_LEAN_AND_MEAN
+#define WIN32_LEAN_AND_MEAN
+#endif  // WIN32_LEAN_AND_MEAN
+#ifndef NOMINMAX
+#define NOMINMAX
+#endif  // NOMINMAX
+#include <windows.h>
+// Undef macros to avoid collisions
+#undef LoadFence
+#undef StoreFence
+#endif
+
+#if defined(__MACH__)
+#include <mach/mach.h>
+#include <mach/mach_time.h>
+#endif
+
+#if defined(__HAIKU__)
+#include <OS.h>
+#endif
 
 #include <ctime>
 #include <hwy/base.h>
 #include <hwy/cache_control.h>  // LoadFence
 
-#if HWY_COMPILER_MSVC
-#include <chrono>
-#endif  // HWY_COMPILER_MSVC
-
 namespace profiler {
 
+// Ticks := platform-specific timer values (CPU cycles on x86). Must be
+// unsigned to guarantee wraparound on overflow.
+using Ticks = uint64_t;
+
 // TicksBefore/After return absolute timestamps and must be placed immediately
-// before and after the region to measure. The functions are distinct because
-// they use different fences.
+// before and after the region to measure. We provide separate Before/After
+// functions because they use different fences.
 //
 // Background: RDTSC is not 'serializing'; earlier instructions may complete
 // after it, and/or later instructions may complete before it. 'Fences' ensure
@@ -59,7 +82,7 @@ namespace profiler {
 // Using Before+Before leads to higher variance and overhead than After+After.
 // However, After+After includes an LFENCE in the region measurements, which
 // adds a delay dependent on earlier loads. The combination of Before+After
-// is faster than Before+Before and more consistent than Stop+Stop because
+// is faster than Before+Before and more consistent than After+After because
 // the first LFENCE already delayed subsequent loads before the measured
 // region. This combination seems not to have been considered in prior work:
 // http://akaros.cs.berkeley.edu/lxr/akaros/kern/arch/x86/rdtsc_test.c
@@ -71,19 +94,18 @@ namespace profiler {
 // by several under/over-count errata, so we use the TSC instead.
 
 // Returns a 64-bit timestamp in unit of 'ticks'; to convert to seconds,
-// divide by InvariantTicksPerSecond. Although 32-bit ticks are faster to read,
-// they overflow too quickly to measure long regions.
-static HWY_INLINE HWY_MAYBE_UNUSED uint64_t TicksBefore() {
-  uint64_t t;
-#if HWY_ARCH_PPC
+// divide by InvariantTicksPerSecond.
+static HWY_INLINE HWY_MAYBE_UNUSED Ticks TicksBefore() {
+  Ticks t;
+#if HWY_ARCH_PPC && defined(__GLIBC__)
   asm volatile("mfspr %0, %1" : "=r"(t) : "i"(268));
-#elif HWY_ARCH_X86_64 && HWY_COMPILER_MSVC
+#elif HWY_ARCH_X86 && HWY_COMPILER_MSVC
   hwy::LoadFence();
   HWY_FENCE;
   t = __rdtsc();
   hwy::LoadFence();
   HWY_FENCE;
-#elif HWY_ARCH_X86_64 && (HWY_COMPILER_CLANG || HWY_COMPILER_GCC)
+#elif HWY_ARCH_X86_64
   asm volatile(
       "lfence\n\t"
       "rdtsc\n\t"
@@ -95,30 +117,35 @@ static HWY_INLINE HWY_MAYBE_UNUSED uint64_t TicksBefore() {
       // "memory" avoids reordering. rdx = TSC >> 32.
       // "cc" = flags modified by SHL.
       : "rdx", "memory", "cc");
-#elif HWY_COMPILER_MSVC
-  // Use std::chrono in MSVC 32-bit.
-  t = std::chrono::time_point_cast<std::chrono::nanoseconds>(
-          std::chrono::steady_clock::now())
-          .time_since_epoch()
-          .count();
-#else
-  // Fall back to OS - unsure how to reliably query cntvct_el0 frequency.
+#elif HWY_ARCH_RVV
+  asm volatile("rdcycle %0" : "=r"(t));
+#elif defined(_WIN32) || defined(_WIN64)
+  LARGE_INTEGER counter;
+  (void)QueryPerformanceCounter(&counter);
+  t = counter.QuadPart;
+#elif defined(__MACH__)
+  t = mach_absolute_time();
+#elif defined(__HAIKU__)
+  t = system_time_nsecs();  // since boot
+#else  // POSIX
   timespec ts;
   clock_gettime(CLOCK_MONOTONIC, &ts);
-  t = ts.tv_sec * 1000000000LL + ts.tv_nsec;
+  t = static_cast<Ticks>(ts.tv_sec * 1000000000LL + ts.tv_nsec);
 #endif
   return t;
 }
 
-static HWY_INLINE HWY_MAYBE_UNUSED uint64_t TicksAfter() {
-  uint64_t t;
-#if HWY_ARCH_X86_64 && HWY_COMPILER_MSVC
+static HWY_INLINE HWY_MAYBE_UNUSED Ticks TicksAfter() {
+  Ticks t;
+#if HWY_ARCH_PPC && defined(__GLIBC__)
+  asm volatile("mfspr %0, %1" : "=r"(t) : "i"(268));
+#elif HWY_ARCH_X86 && HWY_COMPILER_MSVC
   HWY_FENCE;
   unsigned aux;
   t = __rdtscp(&aux);
   hwy::LoadFence();
   HWY_FENCE;
-#elif HWY_ARCH_X86_64 && (HWY_COMPILER_CLANG || HWY_COMPILER_GCC)
+#elif HWY_ARCH_X86_64
   // Use inline asm because __rdtscp generates code to store TSC_AUX (ecx).
   asm volatile(
       "rdtscp\n\t"

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Sun, 10 Oct 2021 18:50:00 +0200
Subject: [PATCH 6/9] --exclude-libs=ALL is only supported on ELF platforms

This linker option is not available for COFF and Mach-O platforms.

diff --git a/lib/jxl.cmake b/lib/jxl.cmake
index 1111111..2222222 100644
--- a/lib/jxl.cmake
+++ b/lib/jxl.cmake
@@ -538,11 +538,13 @@ foreach(target IN ITEMS jxl jxl_dec)
   set_property(TARGET ${target} APPEND_STRING PROPERTY
       LINK_FLAGS " -Wl,--version-script=${CMAKE_CURRENT_SOURCE_DIR}/jxl/jxl.version")
   endif()  # APPLE
+  if(UNIX)
   # This hides the default visibility symbols from static libraries bundled into
   # the shared library. In particular this prevents exposing symbols from hwy
   # and skcms in the shared library.
   set_property(TARGET ${target} APPEND_STRING PROPERTY
       LINK_FLAGS " -Wl,--exclude-libs=ALL")
+  endif()  # UNIX
 endforeach()
 
 # Only install libjxl shared library. The libjxl_dec is not installed since it

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jan Wassenberg <janwas@google.com>
Date: Fri, 12 Nov 2021 09:12:35 +0100
Subject: [PATCH 7/9] Avoid deprecated Highway functions

Instead use the newer overloads with the extra d arg required to
support SVE/RISC-V.

Upstream-Status: Accepted [https://github.com/libjxl/libjxl/commit/e0107a6ca637eb3997131e966e19fcd6001b37ad]

diff --git a/lib/jxl/dec_reconstruct.cc b/lib/jxl/dec_reconstruct.cc
index 1111111..2222222 100644
--- a/lib/jxl/dec_reconstruct.cc
+++ b/lib/jxl/dec_reconstruct.cc
@@ -357,8 +357,8 @@ void DoYCbCrUpsampling(size_t hs, size_t vs, ImageF* plane_in, const Rect& rect,
         Store(left, d, out + x);
         Store(right, d, out + x + 1);
 #else
-        Store(InterleaveLower(left, right), d, out + x);
-        Store(InterleaveUpper(left, right), d, out + x + Lanes(d));
+        Store(InterleaveLower(d, left, right), d, out + x);
+        Store(InterleaveUpper(d, left, right), d, out + x + Lanes(d));
 #endif
       }
     }
diff --git a/lib/jxl/dec_upsample.cc b/lib/jxl/dec_upsample.cc
index 1111111..2222222 100644
--- a/lib/jxl/dec_upsample.cc
+++ b/lib/jxl/dec_upsample.cc
@@ -176,8 +176,8 @@ void Upsample(const ImageF& src, const Rect& src_rect, ImageF* dst,
         min = Min(LoadU(df, raw_min_row + sx + fx), min);
         max = Max(LoadU(df, raw_max_row + sx + fx), max);
       }
-      min = MinOfLanes(min);
-      max = MaxOfLanes(max);
+      min = MinOfLanes(df, min);
+      max = MaxOfLanes(df, max);
       for (size_t lx = 0; lx < N; lx += V) {
         StoreU(min, df, min_row + N * sx + lx);
         StoreU(max, df, max_row + N * sx + lx);
diff --git a/lib/jxl/enc_ac_strategy.cc b/lib/jxl/enc_ac_strategy.cc
index 1111111..2222222 100644
--- a/lib/jxl/enc_ac_strategy.cc
+++ b/lib/jxl/enc_ac_strategy.cc
@@ -429,8 +429,8 @@ float EstimateEntropy(const AcStrategy& acs, size_t x, size_t y,
     }
     entropy_v += nzeros_v * cost1;
 
-    entropy += GetLane(SumOfLanes(entropy_v));
-    size_t num_nzeros = GetLane(SumOfLanes(nzeros_v));
+    entropy += GetLane(SumOfLanes(df, entropy_v));
+    size_t num_nzeros = GetLane(SumOfLanes(df, nzeros_v));
     // Add #bit of num_nonzeros, as an estimate of the cost for encoding the
     // number of non-zeros of the block.
     size_t nbits = CeilLog2Nonzero(num_nzeros + 1) + 1;
@@ -441,9 +441,9 @@ float EstimateEntropy(const AcStrategy& acs, size_t x, size_t y,
   float ret =
       entropy +
       masking *
-          ((config.info_loss_multiplier * GetLane(SumOfLanes(info_loss))) +
+          ((config.info_loss_multiplier * GetLane(SumOfLanes(df, info_loss))) +
            (config.info_loss_multiplier2 *
-            sqrt(num_blocks * GetLane(SumOfLanes(info_loss2)))));
+            sqrt(num_blocks * GetLane(SumOfLanes(df, info_loss2)))));
   return ret;
 }
 
diff --git a/lib/jxl/enc_adaptive_quantization.cc b/lib/jxl/enc_adaptive_quantization.cc
index 1111111..2222222 100644
--- a/lib/jxl/enc_adaptive_quantization.cc
+++ b/lib/jxl/enc_adaptive_quantization.cc
@@ -189,7 +189,7 @@ V GammaModulation(const D d, const size_t x, const size_t y,
       overall_ratio += avg_ratio;
     }
   }
-  overall_ratio = SumOfLanes(overall_ratio);
+  overall_ratio = SumOfLanes(d, overall_ratio);
   overall_ratio *= Set(d, 1.0f / 64);
   // ideally -1.0, but likely optimal correction adds some entropy, so slightly
   // less than that.
@@ -246,12 +246,12 @@ V ColorModulation(const D d, const size_t x, const size_t y,
   // blue we consider as if it was fully red or blue.
   static const float ratio = 30.610615782142737f;  // out of 64 pixels.
 
-  auto overall_red_coverage = SumOfLanes(red_coverage);
+  auto overall_red_coverage = SumOfLanes(d, red_coverage);
   overall_red_coverage =
       Min(overall_red_coverage, Set(d, ratio * kRedRampLength));
   overall_red_coverage *= Set(d, red_strength / ratio);
 
-  auto overall_blue_coverage = SumOfLanes(blue_coverage);
+  auto overall_blue_coverage = SumOfLanes(d, blue_coverage);
   overall_blue_coverage =
       Min(overall_blue_coverage, Set(d, ratio * kBlueRampLength));
   overall_blue_coverage *= Set(d, blue_strength / ratio);
@@ -295,7 +295,7 @@ V HfModulation(const D d, const size_t x, const size_t y, const ImageF& xyb,
     }
   }
 
-  sum = SumOfLanes(sum);
+  sum = SumOfLanes(d, sum);
   return MulAdd(sum, Set(d, -2.0052193233688884f / 112), out_val);
 }
 
diff --git a/lib/jxl/enc_ar_control_field.cc b/lib/jxl/enc_ar_control_field.cc
index 1111111..2222222 100644
--- a/lib/jxl/enc_ar_control_field.cc
+++ b/lib/jxl/enc_ar_control_field.cc
@@ -157,7 +157,7 @@ void ProcessTile(const Image3F& opsin, PassesEncoderState* enc_state,
           sum += LoadU(df4, rows_in[iy] + x * 4 + ix + 2);
         }
       }
-      row_out[x] = GetLane(Sqrt(SumOfLanes(sum))) * (1.0f / 4.0f);
+      row_out[x] = GetLane(Sqrt(SumOfLanes(df4, sum))) * (1.0f / 4.0f);
     }
   }
   // Indexing iy and ix is a bit tricky as we include a 2 pixel border
@@ -193,7 +193,7 @@ void ProcessTile(const Image3F& opsin, PassesEncoderState* enc_state,
             sum += Load(df4, rows_in[iy] + sx + ix);
           }
         }
-        row_out[x] = GetLane(Sqrt(SumOfLanes(sum))) * (1.0f / 4.0f);
+        row_out[x] = GetLane(Sqrt(SumOfLanes(df4, sum))) * (1.0f / 4.0f);
       } else {
         float sum = 0;
         for (size_t iy = sy; iy < ey; iy++) {
diff --git a/lib/jxl/enc_butteraugli_pnorm.cc b/lib/jxl/enc_butteraugli_pnorm.cc
index 1111111..2222222 100644
--- a/lib/jxl/enc_butteraugli_pnorm.cc
+++ b/lib/jxl/enc_butteraugli_pnorm.cc
@@ -95,13 +95,13 @@ double ComputeDistanceP(const ImageF& distmap, const ButteraugliParams& params,
     }
     double v = 0;
     v += pow(
-        onePerPixels * (sum1[0] + GetLane(SumOfLanes(Load(d, sum_totals0)))),
+        onePerPixels * (sum1[0] + GetLane(SumOfLanes(d, Load(d, sum_totals0)))),
         1.0 / (p * 1.0));
     v += pow(
-        onePerPixels * (sum1[1] + GetLane(SumOfLanes(Load(d, sum_totals1)))),
+        onePerPixels * (sum1[1] + GetLane(SumOfLanes(d, Load(d, sum_totals1)))),
         1.0 / (p * 2.0));
     v += pow(
-        onePerPixels * (sum1[2] + GetLane(SumOfLanes(Load(d, sum_totals2)))),
+        onePerPixels * (sum1[2] + GetLane(SumOfLanes(d, Load(d, sum_totals2)))),
         1.0 / (p * 4.0));
     v /= 3.0;
     return v;
diff --git a/lib/jxl/enc_chroma_from_luma.cc b/lib/jxl/enc_chroma_from_luma.cc
index 1111111..2222222 100644
--- a/lib/jxl/enc_chroma_from_luma.cc
+++ b/lib/jxl/enc_chroma_from_luma.cc
@@ -91,9 +91,9 @@ struct CFLFunction {
       fdme_v += IfThenElse(av >= thres, zero, dme);
     }
 
-    *fpeps = first_derivative_peps + GetLane(SumOfLanes(fdpe_v));
-    *fmeps = first_derivative_meps + GetLane(SumOfLanes(fdme_v));
-    return first_derivative + GetLane(SumOfLanes(fd_v));
+    *fpeps = first_derivative_peps + GetLane(SumOfLanes(df, fdpe_v));
+    *fmeps = first_derivative_meps + GetLane(SumOfLanes(df, fdme_v));
+    return first_derivative + GetLane(SumOfLanes(df, fd_v));
   }
 
   const float* JXL_RESTRICT values_m;
@@ -124,8 +124,8 @@ int32_t FindBestMultiplier(const float* values_m, const float* values_s,
       cb = MulAdd(a, b, cb);
     }
     // + distance_mul * x^2 * num
-    x = -GetLane(SumOfLanes(cb)) /
-        (GetLane(SumOfLanes(ca)) + num * distance_mul * 0.5f);
+    x = -GetLane(SumOfLanes(df, cb)) /
+        (GetLane(SumOfLanes(df, ca)) + num * distance_mul * 0.5f);
   } else {
     constexpr float eps = 1;
     constexpr float kClamp = 20.0f;
diff --git a/lib/jxl/enc_cluster.cc b/lib/jxl/enc_cluster.cc
index 1111111..2222222 100644
--- a/lib/jxl/enc_cluster.cc
+++ b/lib/jxl/enc_cluster.cc
@@ -49,7 +49,7 @@ void HistogramEntropy(const Histogram& a) {
     const auto counts = LoadU(di, &a.data_[i]);
     entropy_lanes += Entropy(ConvertTo(df, counts), inv_tot, total);
   }
-  a.entropy_ += GetLane(SumOfLanes(entropy_lanes));
+  a.entropy_ += GetLane(SumOfLanes(df, entropy_lanes));
 }
 
 float HistogramDistance(const Histogram& a, const Histogram& b) {
@@ -71,7 +71,7 @@ float HistogramDistance(const Histogram& a, const Histogram& b) {
     const auto counts = ConvertTo(df, a_counts + b_counts);
     distance_lanes += Entropy(counts, inv_tot, total);
   }
-  const float total_distance = GetLane(SumOfLanes(distance_lanes));
+  const float total_distance = GetLane(SumOfLanes(df, distance_lanes));
   return total_distance - a.entropy_ - b.entropy_;
 }
 
diff --git a/lib/jxl/enc_entropy_coder.cc b/lib/jxl/enc_entropy_coder.cc
index 1111111..2222222 100644
--- a/lib/jxl/enc_entropy_coder.cc
+++ b/lib/jxl/enc_entropy_coder.cc
@@ -86,7 +86,7 @@ int32_t NumNonZeroExceptLLF(const size_t cx, const size_t cy,
 
   // We want area - sum_zero, add because neg_sum_zero is already negated.
   const int32_t nzeros =
-      int32_t(cx * cy * kDCTBlockSize) + GetLane(SumOfLanes(neg_sum_zero));
+      int32_t(cx * cy * kDCTBlockSize) + GetLane(SumOfLanes(di, neg_sum_zero));
 
   const int32_t shifted_nzeros = static_cast<int32_t>(
       (nzeros + covered_blocks - 1) >> log2_covered_blocks);
@@ -135,7 +135,7 @@ int32_t NumNonZero8x8ExceptDC(const int32_t* JXL_RESTRICT block,
 
   // We want 64 - sum_zero, add because neg_sum_zero is already negated.
   const int32_t nzeros =
-      int32_t(kDCTBlockSize) + GetLane(SumOfLanes(neg_sum_zero));
+      int32_t(kDCTBlockSize) + GetLane(SumOfLanes(di, neg_sum_zero));
 
   *nzeros_pos = nzeros;
 
diff --git a/lib/jxl/enc_fast_heuristics.cc b/lib/jxl/enc_fast_heuristics.cc
index 1111111..2222222 100644
--- a/lib/jxl/enc_fast_heuristics.cc
+++ b/lib/jxl/enc_fast_heuristics.cc
@@ -94,8 +94,8 @@ Status Heuristics(PassesEncoderState* enc_state,
               cb = MulAdd(a, b, cb);
             }
           }
-          float best =
-              -GetLane(SumOfLanes(cb)) / (GetLane(SumOfLanes(ca)) + 1e-9f);
+          float best = -GetLane(SumOfLanes(df, cb)) /
+                       (GetLane(SumOfLanes(df, ca)) + 1e-9f);
           int8_t& res = (c == 0 ? shared.cmap.ytox_map : shared.cmap.ytob_map)
                             .Row(ty)[tx];
           res = std::max(-128.0f, std::min(127.0f, roundf(best)));
@@ -124,8 +124,8 @@ Status Heuristics(PassesEncoderState* enc_state,
                 max = IfThenElse(max > nn, max, nn);
               }
             }
-            row_out_avg[x] = GetLane(SumOfLanes(sum));
-            row_out[x] = GetLane(MaxOfLanes(max));
+            row_out_avg[x] = GetLane(SumOfLanes(df4, sum));
+            row_out[x] = GetLane(MaxOfLanes(df4, max));
           }
         }
       },
diff --git a/lib/jxl/gauss_blur.cc b/lib/jxl/gauss_blur.cc
index 1111111..2222222 100644
--- a/lib/jxl/gauss_blur.cc
+++ b/lib/jxl/gauss_blur.cc
@@ -421,7 +421,7 @@ ImageF ConvolveXSampleAndTranspose(const ImageF& in,
       for (int i = -r; i <= r; i += Lanes(df)) {
         sum = MulAdd(LoadU(df, rowp + x + i), LoadU(df, kernelp + i), sum);
       }
-      out.Row(ox)[y] = GetLane(SumOfLanes(sum));
+      out.Row(ox)[y] = GetLane(SumOfLanes(df, sum));
     }
     for (; x < in.xsize(); x += res, ++ox) {
       float sum = 0.0f;
diff --git a/lib/jxl/modular/encoding/enc_ma.cc b/lib/jxl/modular/encoding/enc_ma.cc
index 1111111..2222222 100644
--- a/lib/jxl/modular/encoding/enc_ma.cc
+++ b/lib/jxl/modular/encoding/enc_ma.cc
@@ -84,7 +84,7 @@ float EstimateBits(const int32_t *counts, int32_t *rounded_counts,
     bits_lanes -=
         IfThenElse(counts_v == zero, zero, counts_v * BitCast(df, nbps));
   }
-  return GetLane(SumOfLanes(bits_lanes));
+  return GetLane(SumOfLanes(df, bits_lanes));
 }
 
 void MakeSplitNode(size_t pos, int property, int splitval, Predictor lpred,
diff --git a/lib/jxl/rational_polynomial_test.cc b/lib/jxl/rational_polynomial_test.cc
index 1111111..2222222 100644
--- a/lib/jxl/rational_polynomial_test.cc
+++ b/lib/jxl/rational_polynomial_test.cc
@@ -51,7 +51,7 @@ struct EvalLog2 {
     const HWY_FULL(int32_t) di;
     const auto x_bits = BitCast(di, vx);
     // Cannot handle negative numbers / NaN.
-    JXL_DASSERT(AllTrue(Abs(x_bits) == x_bits));
+    JXL_DASSERT(AllTrue(di, Abs(x_bits) == x_bits));
 
     // Range reduction to [-1/3, 1/3] - 3 integer, 2 float ops
     const auto exp_bits = x_bits - Set(di, 0x3f2aaaab);  // = 2/3
diff --git a/lib/jxl/splines.cc b/lib/jxl/splines.cc
index 1111111..2222222 100644
--- a/lib/jxl/splines.cc
+++ b/lib/jxl/splines.cc
@@ -52,7 +52,7 @@ float ContinuousIDCT(const float dct[32], float t) {
     auto local_res = LoadU(df, dct + i) * cos;
     result = MulAdd(Set(df, square_root<2>::value), local_res, result);
   }
-  return GetLane(SumOfLanes(result));
+  return GetLane(SumOfLanes(df, result));
 }
 
 template <typename DF>
diff --git a/lib/jxl/transpose-inl.h b/lib/jxl/transpose-inl.h
index 1111111..2222222 100644
--- a/lib/jxl/transpose-inl.h
+++ b/lib/jxl/transpose-inl.h
@@ -137,25 +137,26 @@ JXL_INLINE_TRANSPOSE void GenericTransposeBlock(TransposeSimdTag<true>,
   static_assert(COLS_or_0 % 4 == 0, "Invalid number of columns");
   for (size_t n = 0; n < ROWS; n += 4) {
     for (size_t m = 0; m < COLS; m += 4) {
-      const auto p0 = from.LoadPart(BlockDesc<4>(), n + 0, m + 0);
-      const auto p1 = from.LoadPart(BlockDesc<4>(), n + 1, m + 0);
-      const auto p2 = from.LoadPart(BlockDesc<4>(), n + 2, m + 0);
-      const auto p3 = from.LoadPart(BlockDesc<4>(), n + 3, m + 0);
-
-      const auto q0 = InterleaveLower(p0, p2);
-      const auto q1 = InterleaveLower(p1, p3);
-      const auto q2 = InterleaveUpper(p0, p2);
-      const auto q3 = InterleaveUpper(p1, p3);
-
-      const auto r0 = InterleaveLower(q0, q1);
-      const auto r1 = InterleaveUpper(q0, q1);
-      const auto r2 = InterleaveLower(q2, q3);
-      const auto r3 = InterleaveUpper(q2, q3);
-
-      to.StorePart(BlockDesc<4>(), r0, m + 0, n + 0);
-      to.StorePart(BlockDesc<4>(), r1, m + 1, n + 0);
-      to.StorePart(BlockDesc<4>(), r2, m + 2, n + 0);
-      to.StorePart(BlockDesc<4>(), r3, m + 3, n + 0);
+      const BlockDesc<4> d;
+      const auto p0 = from.LoadPart(d, n + 0, m + 0);
+      const auto p1 = from.LoadPart(d, n + 1, m + 0);
+      const auto p2 = from.LoadPart(d, n + 2, m + 0);
+      const auto p3 = from.LoadPart(d, n + 3, m + 0);
+
+      const auto q0 = InterleaveLower(d, p0, p2);
+      const auto q1 = InterleaveLower(d, p1, p3);
+      const auto q2 = InterleaveUpper(d, p0, p2);
+      const auto q3 = InterleaveUpper(d, p1, p3);
+
+      const auto r0 = InterleaveLower(d, q0, q1);
+      const auto r1 = InterleaveUpper(d, q0, q1);
+      const auto r2 = InterleaveLower(d, q2, q3);
+      const auto r3 = InterleaveUpper(d, q2, q3);
+
+      to.StorePart(d, r0, m + 0, n + 0);
+      to.StorePart(d, r1, m + 1, n + 0);
+      to.StorePart(d, r2, m + 2, n + 0);
+      to.StorePart(d, r3, m + 3, n + 0);
     }
   }
 }

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jan Wassenberg <janwas@google.com>
Date: Thu, 6 Jan 2022 09:36:20 +0100
Subject: [PATCH 8/9] Avoid deprecated Hwy functions - add d arg

Upstream-Status: Accepted [https://github.com/libjxl/libjxl/commit/0902f85ca6e9e305338baf7974192acab8c53ac5]

diff --git a/lib/jxl/transpose-inl.h b/lib/jxl/transpose-inl.h
index 1111111..2222222 100644
--- a/lib/jxl/transpose-inl.h
+++ b/lib/jxl/transpose-inl.h
@@ -74,50 +74,51 @@ JXL_INLINE_TRANSPOSE void GenericTransposeBlock(TransposeSimdTag<true>,
   static_assert(COLS_or_0 % 8 == 0, "Invalid number of columns");
   for (size_t n = 0; n < ROWS; n += 8) {
     for (size_t m = 0; m < COLS; m += 8) {
-      auto i0 = from.LoadPart(BlockDesc<8>(), n + 0, m + 0);
-      auto i1 = from.LoadPart(BlockDesc<8>(), n + 1, m + 0);
-      auto i2 = from.LoadPart(BlockDesc<8>(), n + 2, m + 0);
-      auto i3 = from.LoadPart(BlockDesc<8>(), n + 3, m + 0);
-      auto i4 = from.LoadPart(BlockDesc<8>(), n + 4, m + 0);
-      auto i5 = from.LoadPart(BlockDesc<8>(), n + 5, m + 0);
-      auto i6 = from.LoadPart(BlockDesc<8>(), n + 6, m + 0);
-      auto i7 = from.LoadPart(BlockDesc<8>(), n + 7, m + 0);
+      const BlockDesc<8> d;
+      auto i0 = from.LoadPart(d, n + 0, m + 0);
+      auto i1 = from.LoadPart(d, n + 1, m + 0);
+      auto i2 = from.LoadPart(d, n + 2, m + 0);
+      auto i3 = from.LoadPart(d, n + 3, m + 0);
+      auto i4 = from.LoadPart(d, n + 4, m + 0);
+      auto i5 = from.LoadPart(d, n + 5, m + 0);
+      auto i6 = from.LoadPart(d, n + 6, m + 0);
+      auto i7 = from.LoadPart(d, n + 7, m + 0);
       // Surprisingly, this straightforward implementation (24 cycles on port5)
       // is faster than load128+insert and LoadDup128+ConcatUpperLower+blend.
-      const auto q0 = InterleaveLower(i0, i2);
-      const auto q1 = InterleaveLower(i1, i3);
-      const auto q2 = InterleaveUpper(i0, i2);
-      const auto q3 = InterleaveUpper(i1, i3);
-      const auto q4 = InterleaveLower(i4, i6);
-      const auto q5 = InterleaveLower(i5, i7);
-      const auto q6 = InterleaveUpper(i4, i6);
-      const auto q7 = InterleaveUpper(i5, i7);
-
-      const auto r0 = InterleaveLower(q0, q1);
-      const auto r1 = InterleaveUpper(q0, q1);
-      const auto r2 = InterleaveLower(q2, q3);
-      const auto r3 = InterleaveUpper(q2, q3);
-      const auto r4 = InterleaveLower(q4, q5);
-      const auto r5 = InterleaveUpper(q4, q5);
-      const auto r6 = InterleaveLower(q6, q7);
-      const auto r7 = InterleaveUpper(q6, q7);
-
-      i0 = ConcatLowerLower(r4, r0);
-      i1 = ConcatLowerLower(r5, r1);
-      i2 = ConcatLowerLower(r6, r2);
-      i3 = ConcatLowerLower(r7, r3);
-      i4 = ConcatUpperUpper(r4, r0);
-      i5 = ConcatUpperUpper(r5, r1);
-      i6 = ConcatUpperUpper(r6, r2);
-      i7 = ConcatUpperUpper(r7, r3);
-      to.StorePart(BlockDesc<8>(), i0, m + 0, n + 0);
-      to.StorePart(BlockDesc<8>(), i1, m + 1, n + 0);
-      to.StorePart(BlockDesc<8>(), i2, m + 2, n + 0);
-      to.StorePart(BlockDesc<8>(), i3, m + 3, n + 0);
-      to.StorePart(BlockDesc<8>(), i4, m + 4, n + 0);
-      to.StorePart(BlockDesc<8>(), i5, m + 5, n + 0);
-      to.StorePart(BlockDesc<8>(), i6, m + 6, n + 0);
-      to.StorePart(BlockDesc<8>(), i7, m + 7, n + 0);
+      const auto q0 = InterleaveLower(d, i0, i2);
+      const auto q1 = InterleaveLower(d, i1, i3);
+      const auto q2 = InterleaveUpper(d, i0, i2);
+      const auto q3 = InterleaveUpper(d, i1, i3);
+      const auto q4 = InterleaveLower(d, i4, i6);
+      const auto q5 = InterleaveLower(d, i5, i7);
+      const auto q6 = InterleaveUpper(d, i4, i6);
+      const auto q7 = InterleaveUpper(d, i5, i7);
+
+      const auto r0 = InterleaveLower(d, q0, q1);
+      const auto r1 = InterleaveUpper(d, q0, q1);
+      const auto r2 = InterleaveLower(d, q2, q3);
+      const auto r3 = InterleaveUpper(d, q2, q3);
+      const auto r4 = InterleaveLower(d, q4, q5);
+      const auto r5 = InterleaveUpper(d, q4, q5);
+      const auto r6 = InterleaveLower(d, q6, q7);
+      const auto r7 = InterleaveUpper(d, q6, q7);
+
+      i0 = ConcatLowerLower(d, r4, r0);
+      i1 = ConcatLowerLower(d, r5, r1);
+      i2 = ConcatLowerLower(d, r6, r2);
+      i3 = ConcatLowerLower(d, r7, r3);
+      i4 = ConcatUpperUpper(d, r4, r0);
+      i5 = ConcatUpperUpper(d, r5, r1);
+      i6 = ConcatUpperUpper(d, r6, r2);
+      i7 = ConcatUpperUpper(d, r7, r3);
+      to.StorePart(d, i0, m + 0, n + 0);
+      to.StorePart(d, i1, m + 1, n + 0);
+      to.StorePart(d, i2, m + 2, n + 0);
+      to.StorePart(d, i3, m + 3, n + 0);
+      to.StorePart(d, i4, m + 4, n + 0);
+      to.StorePart(d, i5, m + 5, n + 0);
+      to.StorePart(d, i6, m + 6, n + 0);
+      to.StorePart(d, i7, m + 7, n + 0);
     }
   }
 }

From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Jan Wassenberg <janwas@google.com>
Date: Fri, 4 Feb 2022 11:37:43 +0100
Subject: [PATCH 9/9] Rename deprecated StoreFence to FlushStream

Upstream-Status: Accepted [https://github.com/libjxl/libjxl/commit/600b591538827247f1b2ad6ee6ae627a2173b7ec]

diff --git a/lib/profiler/profiler.cc b/lib/profiler/profiler.cc
index 1111111..2222222 100644
--- a/lib/profiler/profiler.cc
+++ b/lib/profiler/profiler.cc
@@ -139,7 +139,7 @@ class Results {
   void AnalyzePackets(const Packet* HWY_RESTRICT packets,
                       const size_t num_packets) {
     // Ensures prior weakly-ordered streaming stores are globally visible.
-    hwy::StoreFence();
+    hwy::FlushStream();
 
     const uint64_t t0 = TicksBefore();
 
@@ -372,12 +372,12 @@ void ThreadSpecific::ComputeOverhead() {
       const size_t kReps = 10000;
       // Analysis time should not be included => must fit within buffer.
       HWY_ASSERT(kReps * 2 < max_packets_);
-      hwy::StoreFence();
+      hwy::FlushStream();
       const uint64_t t0 = TicksBefore();
       for (size_t i = 0; i < kReps; ++i) {
         PROFILER_ZONE("Dummy");
       }
-      hwy::StoreFence();
+      hwy::FlushStream();
       const uint64_t t1 = TicksAfter();
       HWY_ASSERT(num_packets_ + buffer_size_ == kReps * 2);
       buffer_size_ = 0;
diff --git a/lib/profiler/tsc_timer.h b/lib/profiler/tsc_timer.h
index 1111111..2222222 100644
--- a/lib/profiler/tsc_timer.h
+++ b/lib/profiler/tsc_timer.h
@@ -22,7 +22,6 @@
 #include <windows.h>
 // Undef macros to avoid collisions
 #undef LoadFence
-#undef StoreFence
 #endif
 
 #if defined(__MACH__)
