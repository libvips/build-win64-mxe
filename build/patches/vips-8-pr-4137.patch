From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kleis Auke Wolthuizen <github@kleisauke.nl>
Date: Thu, 5 Sep 2024 14:12:18 +0200
Subject: [PATCH 1/1] threadset: fix a race condition during thread exit

The previous implementation was prone to race conditions under rare
circumstances.

Upstream-Status: Submitted [https://github.com/libvips/libvips/pull/4137]

diff --git a/ChangeLog b/ChangeLog
index 1111111..2222222 100644
--- a/ChangeLog
+++ b/ChangeLog
@@ -5,6 +5,7 @@
 - webpsave: fix memory leak on error [dloebl]
 - heifsave: ensure NCLX profile is freed in lossless mode [kleisauke]
 - threadpool: fix a race condition in error handling [kleisauke]
+- threadset: fix a race condition during thread exit [kleisauke]
 
 11/8/24 8.15.3
 
diff --git a/libvips/iofuncs/threadset.c b/libvips/iofuncs/threadset.c
index 1111111..2222222 100644
--- a/libvips/iofuncs/threadset.c
+++ b/libvips/iofuncs/threadset.c
@@ -52,41 +52,29 @@
 #include <vips/thread.h>
 #include <vips/debug.h>
 
-typedef struct _VipsThreadsetMember {
-	/* The set we are part of.
+typedef struct _VipsThreadExec {
+	/* The source of this function.
 	 */
-	VipsThreadset *set;
-
-	/* The underlying glib thread object.
-	 */
-	GThread *thread;
+	const char *domain;
 
-	/* The task the thread should run next.
+	/* The function to execute within the thread.
 	 */
-	const char *domain;
 	GFunc func;
-	void *data;
-	void *user_data;
 
-	/* The thread waits on this when it's free.
+	/* User data that is handed over to func when it is called.
 	 */
-	VipsSemaphore idle;
-
-	/* Set by our controller to request exit.
-	 */
-	gboolean kill;
-} VipsThreadsetMember;
+	gpointer data;
+} VipsThreadExec;
 
 struct _VipsThreadset {
-	GMutex *lock;
-
-	/* All the VipsThreadsetMember we have created.
+	/* A asynchronous queue of VipsThreadExec.
 	 */
-	GSList *members;
+	GAsyncQueue *queue;
 
-	/* The set of currently idle threads.
+	/* A semaphore used to indicate when the last thread has
+	 * completed its execution.
 	 */
-	GSList *free;
+	VipsSemaphore finish;
 
 	/* The current number of threads, the highwater mark, and
 	 * the max we allow before blocking thread creation.
@@ -94,120 +82,100 @@ struct _VipsThreadset {
 	int n_threads;
 	int n_threads_highwater;
 	int max_threads;
+
+	/* Set by our controller to request exit.
+	 */
+	gboolean exit;
 };
 
 /* The maximum relative time (in microseconds) that a thread waits
- * for work before being stopped.
+ * for work before being stopped, when set->max_threads is 0.
  */
-static const gint64 max_idle_time = 15 * G_TIME_SPAN_SECOND;
+static const guint64 max_idle_time = 15 * G_TIME_SPAN_SECOND;
 
 /* The thread work function.
  */
 static void *
 vips_threadset_work(void *pointer)
 {
-	VipsThreadsetMember *member = (VipsThreadsetMember *) pointer;
-	VipsThreadset *set = member->set;
+	VipsThreadset *set = (VipsThreadset *) pointer;
 
-	VIPS_DEBUG_MSG("vips_threadset_work: starting %p\n", member);
+	VIPS_DEBUG_MSG("vips_threadset_work: starting %p\n", g_thread_self());
 
 	for (;;) {
-		/* Wait for at least 15 seconds to be given work.
+		/* Pop a task from the queue. If the number of threads is limited,
+		 * this will block until a task becomes available. Otherwise, it
+		 * waits for at least 15 seconds before receiving work.
 		 */
-		if (vips_semaphore_down_timeout(&member->idle,
-				max_idle_time) == -1)
-			break;
+		VipsThreadExec *task = set->max_threads > 0
+			? g_async_queue_pop(set->queue)
+			: g_async_queue_timeout_pop(set->queue, max_idle_time);
 
-		/* Killed or no task available? Leave this thread.
+		/* No task available or request to exit? Leave this thread.
 		 */
-		if (member->kill ||
-			!member->func)
+		if (task == NULL || set->exit)
 			break;
 
 		/* If we're profiling, attach a prof struct to this thread.
 		 */
 		if (vips__thread_profile)
-			vips__thread_profile_attach(member->domain);
+			vips__thread_profile_attach(task->domain);
 
 		/* Execute the task.
 		 */
-		member->func(member->data, member->user_data);
+		task->func(task->data, NULL);
 
 		/* Free any thread-private resources -- they will not be
 		 * useful for the next task to use this thread.
 		 */
 		vips_thread_shutdown();
-
-		member->domain = NULL;
-		member->func = NULL;
-		member->data = NULL;
-		member->user_data = NULL;
-
-		/* We are free ... back on the free list!
-		 */
-		g_mutex_lock(set->lock);
-		set->free = g_slist_prepend(set->free, member);
-		g_mutex_unlock(set->lock);
+		VIPS_FREE(task);
 	}
 
-	/* Timed-out or kill has been requested ... remove from both free
-	 * and member list.
+	/* Timed-out or exit has been requested ... decrement number of
+	 * threads.
 	 */
-	g_mutex_lock(set->lock);
-	set->free = g_slist_remove(set->free, member);
-	set->members = g_slist_remove(set->members, member);
+	g_async_queue_lock(set->queue);
 	set->n_threads -= 1;
+	gboolean signal_last = set->exit && set->n_threads == 0;
 	VIPS_DEBUG_MSG("vips_threadset_work: stopping %p (%d remaining)\n",
-		member, set->n_threads);
-	g_mutex_unlock(set->lock);
+		g_thread_self(), set->n_threads);
+	g_async_queue_unlock(set->queue);
 
-	vips_semaphore_destroy(&member->idle);
-
-	VIPS_FREE(member);
+	/* We are the last thread: tell the main thread.
+	 */
+	if (signal_last)
+		vips_semaphore_up(&set->finish);
 
 	return NULL;
 }
 
-/* Create a new idle member for the set.
+/* Add a new idle thread to the set.
  */
-static VipsThreadsetMember *
-vips_threadset_add(VipsThreadset *set)
+static int
+vips_threadset_add_thread(VipsThreadset *set)
 {
-	VipsThreadsetMember *member;
-
-	if (set->max_threads &&
-		set->n_threads >= set->max_threads) {
-		vips_error("VipsThreadset",
-			"%s", _("threadset is exhausted"));
-		return NULL;
-	}
-
-	member = g_new0(VipsThreadsetMember, 1);
-	member->set = set;
-
-	vips_semaphore_init(&member->idle, 0, "idle");
+	GThread *thread;
 
-	if (!(member->thread = vips_g_thread_new("libvips worker",
-			  vips_threadset_work, member))) {
-		vips_semaphore_destroy(&member->idle);
-		VIPS_FREE(member);
+	/* There are already sufficient threads running.
+	 */
+	if (set->max_threads > 0 &&
+		set->n_threads >= set->max_threads)
+		return 0;
 
-		return NULL;
-	}
+	if (!(thread = vips_g_thread_new("libvips worker",
+			  vips_threadset_work, set)))
+		return -1;
 
-	/* Ensure idle threads are freed on exit, this
-	 * ref is increased before the thread is joined.
+	/* Ensure idle threads are freed on exit.
 	 */
-	g_thread_unref(member->thread);
+	g_thread_unref(thread);
 
-	g_mutex_lock(set->lock);
-	set->members = g_slist_prepend(set->members, member);
 	set->n_threads += 1;
 	set->n_threads_highwater =
 		VIPS_MAX(set->n_threads_highwater, set->n_threads);
-	g_mutex_unlock(set->lock);
 
-	return member;
+	return 0;
 }
 
 /**
@@ -220,8 +188,8 @@ vips_threadset_add(VipsThreadset *set)
  * vips_threadset_run(), with no limit on the number of threads.
  *
  * If @max_threads is > 0, then that many threads will be created by
- * vips_threadset_new() during startup and vips_threadset_run() will fail if
- * no free threads are available.
+ * vips_threadset_new() during startup and vips_threadset_run() will
+ * not spawn any additional threads.
  *
  * Returns: the new threadset.
  */
@@ -231,21 +199,25 @@ vips_threadset_new(int max_threads)
 	VipsThreadset *set;
 
 	set = g_new0(VipsThreadset, 1);
-	set->lock = vips_g_mutex_new();
+	set->queue = g_async_queue_new();
+	vips_semaphore_init(&set->finish, 0, "finish");
 	set->max_threads = max_threads;
 
-	if (set->max_threads > 0)
+	if (set->max_threads > 0) {
+		g_async_queue_lock(set->queue);
+
 		for (int i = 0; i < set->max_threads; i++) {
-			VipsThreadsetMember *member;
+			if (vips_threadset_add_thread(set)) {
+				g_async_queue_unlock(set->queue);
 
-			if (!(member = vips_threadset_add(set))) {
 				vips_threadset_free(set);
 				return NULL;
 			}
-
-			set->free = g_slist_prepend(set->free, member);
 		}
 
+		g_async_queue_unlock(set->queue);
+	}
+
 	return set;
 }
 
@@ -256,8 +228,9 @@ vips_threadset_new(int max_threads)
  * @func: the task to execute
  * @data: the task's data
  *
- * Execute a task in a thread. If there are no idle threads, create a new one,
- * provided we are under @max_threads.
+ * Execute a task in a thread. If there are no idle threads and the maximum
+ * thread limit specified by @max_threads has not been reached, a new thread
+ * will be spawned.
  *
  * See also: vips_threadset_new().
  *
@@ -267,58 +240,35 @@ int
 vips_threadset_run(VipsThreadset *set,
 	const char *domain, GFunc func, gpointer data)
 {
-	VipsThreadsetMember *member;
+	VipsThreadExec *task;
 
-	member = NULL;
+	g_async_queue_lock(set->queue);
 
-	/* Try to get an idle thread.
+	/* Create a new thread if no idle threads are available in the
+	 * queue.
 	 */
-	g_mutex_lock(set->lock);
-	if (set->free) {
-		member = (VipsThreadsetMember *) set->free->data;
-		set->free = g_slist_remove(set->free, member);
-	}
-	g_mutex_unlock(set->lock);
+	if (g_async_queue_length_unlocked(set->queue) >= 0)
+		if (vips_threadset_add_thread(set)) {
+			g_async_queue_unlock(set->queue);
 
-	/* None? Make a new idle but not free member.
-	 */
-	if (!member)
-		member = vips_threadset_add(set);
+			/* Thread create has failed.
+			 */
+			return -1;
+		}
 
-	/* Still nothing? Thread create has failed.
+	/* Allocate the task and push it into the queue.
 	 */
-	if (!member)
-		return -1;
+	task = g_new0(VipsThreadExec, 1);
+	task->domain = domain;
+	task->func = func;
+	task->data = data;
 
-	/* Allocate the task and set it going.
-	 */
-	member->domain = domain;
-	member->func = func;
-	member->data = data;
-	member->user_data = NULL;
-	vips_semaphore_up(&member->idle);
+	g_async_queue_push_unlocked(set->queue, task);
+	g_async_queue_unlock(set->queue);
 
 	return 0;
 }
 
-/* Kill a member.
- */
-static void
-vips_threadset_kill_member(VipsThreadsetMember *member)
-{
-	GThread *thread;
-
-	thread = g_thread_ref(member->thread);
-	member->kill = TRUE;
-
-	vips_semaphore_up(&member->idle);
-
-	(void) g_thread_join(thread);
-
-	/* member is freed on thread exit.
-	 */
-}
-
 /**
  * vips_threadset_free:
  * @set: the threadset to free
@@ -329,29 +279,34 @@ vips_threadset_kill_member(VipsThreadsetMember *member)
 void
 vips_threadset_free(VipsThreadset *set)
 {
+	int n_threads;
+
 	VIPS_DEBUG_MSG("vips_threadset_free: %p\n", set);
 
-	/* Try to get and finish a thread.
-	 */
-	for (;;) {
-		VipsThreadsetMember *member;
+	g_async_queue_lock(set->queue);
 
-		member = NULL;
-		g_mutex_lock(set->lock);
-		if (set->members)
-			member = (VipsThreadsetMember *) set->members->data;
-		g_mutex_unlock(set->lock);
+	set->exit = TRUE;
 
-		if (!member)
-			break;
+	n_threads = set->n_threads;
 
-		vips_threadset_kill_member(member);
-	}
+	/* Send dummy data to the queue, causing threads to wake up and
+	 * check the above set->exit condition.
+	 */
+	for (int i = 0; i < n_threads; i++)
+		g_async_queue_push_unlocked(set->queue, GUINT_TO_POINTER(1));
+
+	g_async_queue_unlock(set->queue);
+
+	/* Wait for the last thread to finish.
+	 */
+	if (n_threads > 0)
+		vips_semaphore_down(&set->finish);
+	vips_semaphore_destroy(&set->finish);
 
 	if (vips__leak)
 		printf("vips_threadset_free: peak of %d threads\n",
 			set->n_threads_highwater);
 
-	VIPS_FREEF(vips_g_mutex_free, set->lock);
+	VIPS_FREEF(g_async_queue_unref, set->queue);
 	VIPS_FREE(set);
 }
